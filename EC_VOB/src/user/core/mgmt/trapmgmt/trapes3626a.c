/******************************************************************************
 ******************************************************************************
 **** This file was automatically generated by Epilogue Technology's
 **** Emissary SNMP MIB Compiler, version 6.3.
 **** This file was generated using the -trap.c switch.
 **** 
 **** This file contains functions to generate SNMP TRAP PDUs for all the
 **** trap definitions that Emissary encountered.  To use the functions in
 **** this file, run Emissary with the -trap.h switch to generate a header
 **** file with the corresponding function declarations.
 **** 
 **** DO NOT MODIFY THIS FILE BY HAND.
 **** 
 **** Last build date: Thu Feb 20 10:37:02 2003
 **** from files:
 ****  ..\StdMib\Rfc1213.mib, ..\StdMib\IanaIfType_Rfc1573.mib,
 ****  ..\StdMib\SnmpV2_Rfc1907.mib, ..\StdMib\If_Rfc2863.mib,
 ****  ..\StdMib\Rmon_Rfc2819.mib, ..\StdMib\TokenRingRmon_Rfc1513.mib,
 ****  ..\StdMib\Rmon2_Rfc2021.mib, ..\StdMib\Bridge_Rfc1493.mib,
 ****  ..\StdMib\PBridge_Rfc2674.mib, ..\StdMib\SnmpFramework_Rfc2271.mib,
 ****  ..\StdMib\QBridge_Rfc2674.mib, ..\StdMib\Vrrp_Rfc2787.mib,
 ****  ..\SupersetMib\Es3626a_Superset_82b_TrapV1.mib, ctl\StdTrap.ctl
 ******************************************************************************
 ******************************************************************************
 */
#include <envoy/h/asn1.h>
#include <envoy/h/buffer.h>
#include <envoy/h/snmpdefs.h>
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_sys.h"//for single image
#include "sys_mgr.h"//for single image

static BOOL_T sOidToiOid(UI8_T *sOid, UI32_T *iOid, int *lenOid);
static BOOL_T OidCpy(OIDC_T *Oid1, UI32_T lenOid1, OIDC_T *Oid2, UI32_T lenOid2);
static BOOL_T BuildOID(OIDC_T *SysOid, UI32_T lenSysOid, OIDC_T *SubOid, UI32_T lenSubOid, UI32_T lenIdx,OIDC_T *ResultOid, int *lenResultOid);

    //==================================================
    //es3626aMIB
    static OIDC_T ID_es3626aMIB[SYS_ADPT_MAX_OID_COUNT];
    static int len_es3626aMIB;
    //sysUpTime
    static OIDC_T ID_sysUpTime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
    static int len_sysUpTime = 9;
    static OIDC_T ID_snmpTrapOID[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
    static int len_snmpTrapOID = 11;
    //swIndivPowerUnitIndex
    static OIDC_T SubID_swIndivPowerUnitIndex[] = {1, 1, 6, 1, 1};
    static int lenSubID_swIndivPowerUnitIndex=5;
    static int lenIdx_swIndivPowerUnitIndex=2;
    static OIDC_T ID_swIndivPowerUnitIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerUnitIndex;
    //swIndivPowerIndex
    static OIDC_T SubID_swIndivPowerIndex[] = {1, 1, 6, 1, 2};
    static int lenSubID_swIndivPowerIndex = 5;
    static int lenIdx_swIndivPowerIndex=2;
    static OIDC_T ID_swIndivPowerIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerIndex;
    //swIndivPowerStatus
    static OIDC_T SubID_swIndivPowerStatus[] = {1, 1, 6, 1, 3};
    static int lenSubID_swIndivPowerStatus = 5;
    static int lenIdx_swIndivPowerStatus=2;
    static OIDC_T ID_swIndivPowerStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerStatus;
    //swPowerStatusChangeTrap
    static OIDC_T SubID_swPowerStatusChangeTrap[] = {2, 1, 0, 1};
    static int lenSubID_swPowerStatusChangeTrap=4;
    static int lenIdx_swPowerStatusChangeTrap=0;
    static OIDC_T ID_swPowerStatusChangeTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swPowerStatusChangeTrap;
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
    //swFanFailureTrap
    static OIDC_T SubID_swFanFailureTrap[] = {2, 1, 0, 17};
    static int lenSubID_swFanFailureTrap=4;
    static int lenIdx_swFanFailureTrap=0;
    static OIDC_T ID_swFanFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swFanFailureTrap;
    //swFanRecoverTrap
    static OIDC_T SubID_swFanRecoverTrap[] = {2, 1, 0, 18};
    static int lenSubID_swFanRecoverTrap=4;
    static int lenIdx_swFanRecoverTrap=0;
    static OIDC_T ID_swFanRecoverTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swFanRecoverTrap;
    //switchFanIndex
    static OIDC_T SubID_switchFanIndex[] = {1, 1, 9, 1, 2};
    static int lenSubID_switchFanIndex=5;
    static int lenIdx_switchFanIndex=2;
    static OIDC_T ID_switchFanIndex[SYS_ADPT_MAX_OID_COUNT] ;
    static int len_switchFanIndex;
    //switchUnitIndex
    static OIDC_T SubID_switchUnitIndex[] = {1, 1, 9, 1, 1};
    static int lenSubID_switchUnitIndex=5;
    static int lenIdx_switchUnitIndex=2;
    static OIDC_T ID_switchUnitIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchUnitIndex;
#endif
#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE) 
        //ifIndex
    static OIDC_T ID_ifIndex[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0 };
    static int len_ifIndex = 10;  
        //swPortSecurityTrap
    static OIDC_T SubID_swPortSecurityTrap[] = {2, 1, 0, 36};
    static int lenSubID_swPortSecurityTrap=4;
    static int lenIdx_swPortSecurityTrap=0;
    static OIDC_T ID_swPortSecurityTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swPortSecurityTrap;
#endif  
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    //switchLoopbackTestFailurePorts
    static OIDC_T SubID_switchLoopbackTestFailurePorts[] = {1, 1, 10, 0};
    static int lenSubID_switchLoopbackTestFailurePorts=4;
    static int lenIdx_switchLoopbackTestFailurePorts=0;
    static OIDC_T ID_switchLoopbackTestFailurePorts[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchLoopbackTestFailurePorts;
    //swLoopbackTestFailureTrap
    static OIDC_T SubID_swLoopbackTestFailureTrap[] = {2, 1, 0, 39};
    static int lenSubID_swLoopbackTestFailureTrap=4;
    static int lenIdx_swLoopbackTestFailureTrap=0;
    static OIDC_T ID_swLoopbackTestFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swLoopbackTestFailureTrap;
#endif
#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
    //swIpFilterRejectTrap
    static OIDC_T SubID_swIpFilterRejectTrap[] = {2, 1, 0, 40};
    static int lenSubID_swIpFilterRejectTrap=4;
    static int lenIdx_swIpFilterRejectTrap=0;
    static OIDC_T ID_swIpFilterRejectTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIpFilterRejectTrap;
    //trapIpFilterRejectMode
    static OIDC_T SubID_trapIpFilterRejectMode[] = {1, 14, 2, 6};
    static int lenSubID_trapIpFilterRejectMode=4;
    static int lenIdx_trapIpFilterRejectMode=1;
    static OIDC_T ID_trapIpFilterRejectMode[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectMode;
    //trapIpFilterRejectIp
    static OIDC_T SubID_trapIpFilterRejectIp[] = {1, 14, 2, 7};
    static int lenSubID_trapIpFilterRejectIp=4;
    static int lenIdx_trapIpFilterRejectIp=1;
    static OIDC_T ID_trapIpFilterRejectIp[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectIp;
#endif    
#if (SYS_CPNT_SMTP == TRUE)
    //swSmtpConnFailureTrap
    static OIDC_T SubID_swSmtpConnFailureTrap[] = {2, 1, 0, 41};
    static int lenSubID_swSmtpConnFailureTrap=4;
    static int lenIdx_swSmtpConnFailureTrap=0;
    static OIDC_T ID_swSmtpConnFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swSmtpConnFailureTrap;
    //smtpServerIp
    static OIDC_T SubID_smtpServerIp[] = {1, 19, 7, 4, 1, 1};
    static int lenSubID_smtpServerIp=6;
    static int lenIdx_smtpServerIp=4;
    static OIDC_T ID_smtpServerIp[SYS_ADPT_MAX_OID_COUNT];
    static int len_smtpServerIp;      
#endif
//power ethernet traps
#if (SYS_CPNT_POE == TRUE)
    //pethPsePortOnOffNotification
    static OIDC_T SubID_pethPsePortOnOffNotification[] = {2, 1, 0, 43};
    static int lenSubID_pethPsePortOnOffNotification=4;
    static int lenIdx_pethPsePortOnOffNotification=0;
    static OIDC_T ID_pethPsePortOnOffNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_pethPsePortOnOffNotification;          
    //pethPsePortDetectionStatus
    static OIDC_T SubID_pethPsePortDetectionStatus[] = {1, 28, 1, 1, 7};
    static int lenSubID_pethPsePortDetectionStatus=5;
    static int lenIdx_pethPsePortDetectionStatus=2;
    static OIDC_T ID_pethPsePortDetectionStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_pethPsePortDetectionStatus;     
    //pethMainPowerUsageOnNotification
    static OIDC_T SubID_pethMainPowerUsageOnNotification[] = {2, 1, 0, 45};
    static int lenSubID_pethMainPowerUsageOnNotification=4;
    static int lenIdx_pethMainPowerUsageOnNotification=0;
    static OIDC_T ID_pethMainPowerUsageOnNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_pethMainPowerUsageOnNotification; 
    //pethMainPseConsumptionPower
    static OIDC_T SubID_pethMainPseConsumptionPower[] = {1, 28, 3, 1, 1, 4};
    static int lenSubID_pethMainPseConsumptionPower=6;
    static int lenIdx_pethMainPseConsumptionPower=1;
    static OIDC_T ID_pethMainPseConsumptionPower[SYS_ADPT_MAX_OID_COUNT];
    static int len_pethMainPseConsumptionPower;     
    //pethMainPowerUsageOffNotification
    static OIDC_T SubID_pethMainPowerUsageOffNotification[] = {2, 1, 0, 46};
    static int lenSubID_pethMainPowerUsageOffNotification=4;
    static int lenIdx_pethMainPowerUsageOffNotification=0;
    static OIDC_T ID_pethMainPowerUsageOffNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_pethMainPowerUsageOffNotification;     
#endif   
#if (SYS_CPNT_VDSL == TRUE)  
	//vdslPerfLofsThreshNotification
    static OIDC_T SubID_vdslPerfLofsThreshNotification[] = {2, 1, 0, 48};
    static int lenSubID_vdslPerfLofsThreshNotification=4;
    static int lenIdx_vdslPerfLofsThreshNotification=0;
    static OIDC_T ID_vdslPerfLofsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfLofsThreshNotification;   
    
	//vdslPerfCurr15MinLofs
    static OIDC_T SubID_vdslPerfCurr15MinLofs[] = {1, 15, 8, 4, 1, 12};
    static int lenSubID_vdslPerfCurr15MinLofs=6;
    static int lenIdx_vdslPerfCurr15MinLofs=2;
    static OIDC_T ID_vdslPerfCurr15MinLofs[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinLofs; 
     
	//vdslPerfLossThreshNotification
    static OIDC_T SubID_vdslPerfLossThreshNotification[] = {2, 1, 0, 49};
    static int lenSubID_vdslPerfLossThreshNotification=4;
    static int lenIdx_vdslPerfLossThreshNotification=0;
    static OIDC_T ID_vdslPerfLossThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfLossThreshNotification;
  
  	//vdslPerfCurr15MinLoss
    static OIDC_T SubID_vdslPerfCurr15MinLoss[] = {1, 15, 8, 4, 1, 13};
    static int lenSubID_vdslPerfCurr15MinLoss=6;
    static int lenIdx_vdslPerfCurr15MinLoss=2;
    static OIDC_T ID_vdslPerfCurr15MinLoss[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinLoss;
 
  	//vdslPerfLprsThreshNotification
    static OIDC_T SubID_vdslPerfLprsThreshNotification[] = {2, 1, 0, 50};
    static int lenSubID_vdslPerfLprsThreshNotification=4;
    static int lenIdx_vdslPerfLprsThreshNotification=0;
    static OIDC_T ID_vdslPerfLprsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfLprsThreshNotification;      

  	//vdslPerfCurr15MinLprs
    static OIDC_T SubID_vdslPerfCurr15MinLprs[] = {1, 15, 8, 4, 1, 14};
    static int lenSubID_vdslPerfCurr15MinLprs=6;
    static int lenIdx_vdslPerfCurr15MinLprs=2;
    static OIDC_T ID_vdslPerfCurr15MinLprs[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinLprs; 
    
  	//vdslPerfLolsThreshNotification
    static OIDC_T SubID_vdslPerfLolsThreshNotification[] = {2, 1, 0, 51};
    static int lenSubID_vdslPerfLolsThreshNotification=4;
    static int lenIdx_vdslPerfLolsThreshNotification=0;
    static OIDC_T ID_vdslPerfLolsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfLolsThreshNotification; 

  	//vdslPerfCurr15MinLols
    static OIDC_T SubID_vdslPerfCurr15MinLols[] = {1, 15, 8, 4, 1, 15};
    static int lenSubID_vdslPerfCurr15MinLols=6;
    static int lenIdx_vdslPerfCurr15MinLols=2;
    static OIDC_T ID_vdslPerfCurr15MinLols[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinLols; 

  	//vdslPerfESsThreshNotification
    static OIDC_T SubID_vdslPerfESsThreshNotification[] = {2, 1, 0, 52};
    static int lenSubID_vdslPerfESsThreshNotification=4;
    static int lenIdx_vdslPerfESsThreshNotification=0;
    static OIDC_T ID_vdslPerfESsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfESsThreshNotification;     

  	//vdslPerfCurr15MinESs
    static OIDC_T SubID_vdslPerfCurr15MinESs[] = {1, 15, 8, 4, 1, 16};
    static int lenSubID_vdslPerfCurr15MinESs=6;
    static int lenIdx_vdslPerfCurr15MinESs=2;
    static OIDC_T ID_vdslPerfCurr15MinESs[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinESs;     

  	//vdslPerfSESsThreshNotification
    static OIDC_T SubID_vdslPerfSESsThreshNotification[] = {2, 1, 0, 53};
    static int lenSubID_vdslPerfSESsThreshNotification=4;
    static int lenIdx_vdslPerfSESsThreshNotification=0;
    static OIDC_T ID_vdslPerfSESsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfSESsThreshNotification;   
    
  	//vdslPerfCurr15MinSESs
    static OIDC_T SubID_vdslPerfCurr15MinSESs[] = {1, 15, 8, 4, 1, 17};
    static int lenSubID_vdslPerfCurr15MinSESs=6;
    static int lenIdx_vdslPerfCurr15MinSESs=2;
    static OIDC_T ID_vdslPerfCurr15MinSESs[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinSESs;
     
  	//vdslPerfUASsThreshNotification
    static OIDC_T SubID_vdslPerfUASsThreshNotification[] = {2, 1, 0, 54};
    static int lenSubID_vdslPerfUASsThreshNotification=4;
    static int lenIdx_vdslPerfUASsThreshNotification=0;
    static OIDC_T ID_vdslPerfUASsThreshNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfUASsThreshNotification;     

  	//vdslPerfCurr15MinUASs
    static OIDC_T SubID_vdslPerfCurr15MinUASs[] = {1, 15, 8, 4, 1, 18};
    static int lenSubID_vdslPerfCurr15MinUASs=6;
    static int lenIdx_vdslPerfCurr15MinUASs=2;
    static OIDC_T ID_vdslPerfCurr15MinUASs[SYS_ADPT_MAX_OID_COUNT];
    static int len_vdslPerfCurr15MinUASs;     	      
#endif//end of #if (SYS_CPNT_VDSL == TRUE)
    static OIDC_T SubID_swMainBoardVerMismatchNotificaiton[] = {2, 1, 0, 56};
    static int lenSubID_swMainBoardVerMismatchNotificaiton=4;
    static int lenIdx_swMainBoardVerMismatchNotificaiton=0;
    static OIDC_T ID_swMainBoardVerMismatchNotificaiton[SYS_ADPT_MAX_OID_COUNT];
    static int len_swMainBoardVerMismatchNotificaiton;    

    static OIDC_T SubID_swOpCodeVer[] = {1, 1, 3, 1, 6};
    static int lenSubID_swOpCodeVer=5;
    static int lenIdx_swOpCodeVer=1;
    static OIDC_T ID_swOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swOpCodeVer;  
    
    static OIDC_T SubID_swModuleVerMismatchNotificaiton[] = {2, 1, 0, 57};
    static int lenSubID_swModuleVerMismatchNotificaiton=4;
    static int lenIdx_swModuleVerMismatchNotificaiton=0;
    static OIDC_T ID_swModuleVerMismatchNotificaiton[SYS_ADPT_MAX_OID_COUNT];
    static int len_swModuleVerMismatchNotificaiton;  
    
    static OIDC_T SubID_swModuleOpCodeVer[] = {1, 1, 13, 1, 7};
    static int lenSubID_swModuleOpCodeVer=5;
    static int lenIdx_swModuleOpCodeVer=2;
    static OIDC_T ID_swModuleOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swModuleOpCodeVer;   
    
    static OIDC_T SubID_swExpectedModuleOpCodeVer[] = {1, 1, 3, 1, 16};
    static int lenSubID_swExpectedModuleOpCodeVer=5;
    static int lenIdx_swExpectedModuleOpCodeVer=1;
    static OIDC_T ID_swExpectedModuleOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swExpectedModuleOpCodeVer;   
#if (SYS_CPNT_THERMAL_DETECT == TRUE)
    static OIDC_T SubID_swThermalRisingNotification[] = {2, 1, 0, 58};
    static int lenSubID_swThermalRisingNotification=4;
    static int lenIdx_swThermalRisingNotification=0;
    static OIDC_T ID_swThermalRisingNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swThermalRisingNotification;   
    

    static OIDC_T SubID_switchThermalTempValue[] = {1, 1, 11, 1, 3};
    static int lenSubID_switchThermalTempValue=5;
    static int lenIdx_switchThermalTempValue=2;
    static OIDC_T ID_switchThermalTempValue[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalTempValue;   
        
    static OIDC_T SubID_switchThermalActionRisingThreshold[] = {1, 1, 12, 1, 4};
    static int lenSubID_switchThermalActionRisingThreshold=5;
    static int lenIdx_switchThermalActionRisingThreshold=3;
    static OIDC_T ID_switchThermalActionRisingThreshold[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalActionRisingThreshold;   
    
    static OIDC_T SubID_swThermalFallingNotification[] = {2, 1, 0, 59};
    static int lenSubID_swThermalFallingNotification=4;
    static int lenIdx_swThermalFallingNotification=0;
    static OIDC_T ID_swThermalFallingNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swThermalFallingNotification;  
    
    static OIDC_T SubID_switchThermalActionFallingThreshold[] = {1, 1, 12, 1, 5};
    static int lenSubID_switchThermalActionFallingThreshold=5;
    static int lenIdx_switchThermalActionFallingThreshold=3;
    static OIDC_T ID_switchThermalActionFallingThreshold[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalActionFallingThreshold;       
#endif

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
    static OIDC_T SubID_swModuleInsertionNotificaiton[] = {2, 1, 0, 60};
    static int lenSubID_swModuleInsertionNotificaiton=4;
    static int lenIdx_swModuleInsertionNotificaiton=0;
    static OIDC_T ID_swModuleInsertionNotificaiton[SYS_ADPT_MAX_OID_COUNT];
    static int len_swModuleInsertionNotificaiton;  
    
    static OIDC_T SubID_swModuleRemovalNotificaiton[] = {2, 1, 0, 61};
    static int lenSubID_swModuleRemovalNotificaiton=4;
    static int lenIdx_swModuleRemovalNotificaiton=0;
    static OIDC_T ID_swModuleRemovalNotificaiton[SYS_ADPT_MAX_OID_COUNT];
    static int len_swModuleRemovalNotificaiton;      
#endif

static OIDC_T SubID_tcnTrap[] = {2, 1, 0, 63 };
static int lenSubID_tcnTrap = 4;
static int lenIdx_tcnTrap=0;
static OIDC_T ID_tcnTrap[SYS_ADPT_MAX_OID_COUNT];
static int len_tcnTrap;  
    
static OIDC_T SubID_trapVarTcnReason[] = { 1, 14, 2, 9, 0 };
static int lenSubID_trapVarTcnReason = 5;
static int lenIdx_trapVarTcnReason=0;
static OIDC_T ID_trapVarTcnReason[SYS_ADPT_MAX_OID_COUNT];
static int len_trapVarTcnReason;  

 
static BOOL_T BuildOID(OIDC_T *SysOid, UI32_T lenSysOid, OIDC_T *SubOid, 
					   UI32_T lenSubOid, UI32_T lenIdx,OIDC_T *ResultOid, int *lenResultOid)
{
    OIDC_T ZeroOid[SYS_ADPT_MAX_OID_COUNT];
    memset(ZeroOid,0,sizeof(ZeroOid));
    OidCpy(ResultOid, 0, SysOid, lenSysOid);
    OidCpy(ResultOid, lenSysOid, SubOid, lenSubOid);
    OidCpy(ResultOid,lenSysOid + lenSubOid, ZeroOid, lenIdx);
    *lenResultOid=lenSysOid+lenSubOid;
	return TRUE;
}

static BOOL_T sOidToiOid(UI8_T *sOid, OIDC_T *iOid, int *lenOid)
{
	UI32_T i,idx=0;
	UI8_T *ptr;
	ptr=sOid;
	iOid[idx++]=atoi(ptr);
	for (i=0; i < strlen(sOid); i++)
	{
		if (sOid[i]=='.')
		{
			ptr=sOid+i+1;
			iOid[idx++]=atoi(ptr);
		}
	}
	*lenOid=idx;
	return TRUE;
}

static BOOL_T OidCpy(OIDC_T *Oid1, UI32_T lenOid1, OIDC_T *Oid2, UI32_T lenOid2)
{
	UI32_T i;
	for(i=1; i<=lenOid2; i++)
	{
	    Oid1[lenOid1+i-1]=Oid2[i-1];
	}
	return TRUE;
}

BOOL_T initTrapEs3626a(void)
{     
	#define DEFAULT_MIB_ROOT "1.3.6.1.4.1.259.6.10.999"
	UI8_T privateMibRoot[SYS_ADPT_MAX_OID_STRING_LEN + 1];

	if (!SYS_MGR_GetPrivateMibRoot(SYS_VAL_LOCAL_UNIT_ID, privateMibRoot)) 
	{
		printf("initTrapEs3626a:SYS_MGR_GetPrivateMibRoot return false\n");
		strcpy(privateMibRoot, DEFAULT_MIB_ROOT);
	}  
	
    sOidToiOid(privateMibRoot, ID_es3626aMIB, &len_es3626aMIB);
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerUnitIndex, 
            lenSubID_swIndivPowerUnitIndex, lenIdx_swIndivPowerUnitIndex, 
            ID_swIndivPowerUnitIndex, &len_swIndivPowerUnitIndex);
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerIndex, 
            lenSubID_swIndivPowerIndex, lenIdx_swIndivPowerIndex, 
            ID_swIndivPowerIndex, &len_swIndivPowerIndex);  
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerStatus, 
            lenSubID_swIndivPowerStatus, lenIdx_swIndivPowerStatus, 
            ID_swIndivPowerStatus, &len_swIndivPowerStatus); 
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swPowerStatusChangeTrap, 
            lenSubID_swPowerStatusChangeTrap, lenIdx_swPowerStatusChangeTrap, 
            ID_swPowerStatusChangeTrap, &len_swPowerStatusChangeTrap);              
#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)                          
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swPortSecurityTrap, 
            lenSubID_swPortSecurityTrap, lenIdx_swPortSecurityTrap, 
            ID_swPortSecurityTrap, &len_swPortSecurityTrap);  
#endif  
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)                         
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swLoopbackTestFailureTrap, 
            lenSubID_swLoopbackTestFailureTrap, lenIdx_swLoopbackTestFailureTrap, 
            ID_swLoopbackTestFailureTrap, &len_swLoopbackTestFailureTrap);         
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchLoopbackTestFailurePorts, 
            lenSubID_switchLoopbackTestFailurePorts, lenIdx_switchLoopbackTestFailurePorts, 
            ID_switchLoopbackTestFailurePorts, &len_switchLoopbackTestFailurePorts);  
#endif      
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)                  
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swFanFailureTrap, 
            lenSubID_swFanFailureTrap, lenIdx_swFanFailureTrap, 
            ID_swFanFailureTrap, &len_swFanFailureTrap);
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swFanRecoverTrap, 
            lenSubID_swFanRecoverTrap, lenIdx_swFanRecoverTrap, 
            ID_swFanRecoverTrap, &len_swFanRecoverTrap);
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchFanIndex, 
            lenSubID_switchFanIndex, lenIdx_switchFanIndex, 
            ID_switchFanIndex, &len_switchFanIndex);
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchUnitIndex, 
            lenSubID_switchUnitIndex, lenIdx_switchUnitIndex, 
            ID_switchUnitIndex, &len_switchUnitIndex);
#endif   
#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIpFilterRejectTrap, 
            lenSubID_swIpFilterRejectTrap, lenIdx_swIpFilterRejectTrap, 
            ID_swIpFilterRejectTrap, &len_swIpFilterRejectTrap);     
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectMode, 
            lenSubID_trapIpFilterRejectMode, lenIdx_trapIpFilterRejectMode, 
            ID_trapIpFilterRejectMode, &len_trapIpFilterRejectMode); 
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectIp, 
            lenSubID_trapIpFilterRejectIp, lenIdx_trapIpFilterRejectIp, 
            ID_trapIpFilterRejectIp, &len_trapIpFilterRejectIp);                                   
#endif               
#if (SYS_CPNT_SMTP == TRUE)
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swSmtpConnFailureTrap, 
            lenSubID_swSmtpConnFailureTrap, lenIdx_swSmtpConnFailureTrap, 
            ID_swSmtpConnFailureTrap, &len_swSmtpConnFailureTrap);     
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_smtpServerIp, 
            lenSubID_smtpServerIp, lenIdx_smtpServerIp, 
            ID_smtpServerIp, &len_smtpServerIp);                 
#endif                                                                                                                                                                                                                                                                                                                                              
//power ethernet traps
#if (SYS_CPNT_POE == TRUE)
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_pethPsePortOnOffNotification, 
            lenSubID_pethPsePortOnOffNotification, lenIdx_pethPsePortOnOffNotification, 
            ID_pethPsePortOnOffNotification, &len_pethPsePortOnOffNotification);     
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_pethPsePortDetectionStatus, 
            lenSubID_pethPsePortDetectionStatus, lenIdx_pethPsePortDetectionStatus, 
            ID_pethPsePortDetectionStatus, &len_pethPsePortDetectionStatus); 
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_pethMainPowerUsageOnNotification, 
            lenSubID_pethMainPowerUsageOnNotification, lenIdx_pethMainPowerUsageOnNotification, 
            ID_pethMainPowerUsageOnNotification, &len_pethMainPowerUsageOnNotification);     
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_pethMainPseConsumptionPower, 
            lenSubID_pethMainPseConsumptionPower, lenIdx_pethMainPseConsumptionPower, 
            ID_pethMainPseConsumptionPower, &len_pethMainPseConsumptionPower);             
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_pethMainPowerUsageOffNotification, 
            lenSubID_pethMainPowerUsageOffNotification, lenIdx_pethMainPowerUsageOffNotification, 
            ID_pethMainPowerUsageOffNotification, &len_pethMainPowerUsageOffNotification);        
#endif 
#if (SYS_CPNT_VDSL == TRUE)  
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfLofsThreshNotification, 
            lenSubID_vdslPerfLofsThreshNotification, lenIdx_vdslPerfLofsThreshNotification, 
            ID_vdslPerfLofsThreshNotification, &len_vdslPerfLofsThreshNotification); 
	
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinLofs, 
            lenSubID_vdslPerfCurr15MinLofs, lenIdx_vdslPerfCurr15MinLofs, 
            ID_vdslPerfCurr15MinLofs, &len_vdslPerfCurr15MinLofs);     
	
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfLossThreshNotification, 
        lenSubID_vdslPerfLossThreshNotification, lenIdx_vdslPerfLossThreshNotification, 
        ID_vdslPerfLossThreshNotification, &len_vdslPerfLossThreshNotification);   

   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinLoss, 
        lenSubID_vdslPerfCurr15MinLoss, lenIdx_vdslPerfCurr15MinLoss, 
        ID_vdslPerfCurr15MinLoss, &len_vdslPerfCurr15MinLoss); 

   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfLprsThreshNotification, 
        lenSubID_vdslPerfLprsThreshNotification, lenIdx_vdslPerfLprsThreshNotification, 
        ID_vdslPerfLprsThreshNotification, &len_vdslPerfLprsThreshNotification); 

   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinLprs, 
        lenSubID_vdslPerfCurr15MinLprs, lenIdx_vdslPerfCurr15MinLprs, 
        ID_vdslPerfCurr15MinLprs, &len_vdslPerfCurr15MinLprs); 
   
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfLolsThreshNotification, 
        lenSubID_vdslPerfLolsThreshNotification, lenIdx_vdslPerfLolsThreshNotification, 
        ID_vdslPerfLolsThreshNotification, &len_vdslPerfLolsThreshNotification);
    
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinLols, 
        lenSubID_vdslPerfCurr15MinLols, lenIdx_vdslPerfCurr15MinLols, 
        ID_vdslPerfCurr15MinLols, &len_vdslPerfCurr15MinLols);

   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfESsThreshNotification, 
        lenSubID_vdslPerfESsThreshNotification, lenIdx_vdslPerfESsThreshNotification, 
        ID_vdslPerfESsThreshNotification, &len_vdslPerfESsThreshNotification);
   
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinESs, 
        lenSubID_vdslPerfCurr15MinESs, lenIdx_vdslPerfCurr15MinESs, 
        ID_vdslPerfCurr15MinESs, &len_vdslPerfCurr15MinESs);
 
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfSESsThreshNotification, 
        lenSubID_vdslPerfSESsThreshNotification, lenIdx_vdslPerfSESsThreshNotification, 
        ID_vdslPerfSESsThreshNotification, &len_vdslPerfSESsThreshNotification);
 
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinSESs, 
        lenSubID_vdslPerfCurr15MinSESs, lenIdx_vdslPerfCurr15MinSESs, 
        ID_vdslPerfCurr15MinSESs, &len_vdslPerfCurr15MinSESs);   

   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfUASsThreshNotification, 
        lenSubID_vdslPerfUASsThreshNotification, lenIdx_vdslPerfUASsThreshNotification, 
        ID_vdslPerfUASsThreshNotification, &len_vdslPerfUASsThreshNotification);     
   
   BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_vdslPerfCurr15MinUASs, 
        lenSubID_vdslPerfCurr15MinUASs, lenIdx_vdslPerfCurr15MinUASs, 
        ID_vdslPerfCurr15MinUASs, &len_vdslPerfCurr15MinUASs);          
#endif//end of #if (SYS_CPNT_VDSL == TRUE) 
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swMainBoardVerMismatchNotificaiton, 
        lenSubID_swMainBoardVerMismatchNotificaiton, lenIdx_swMainBoardVerMismatchNotificaiton, 
        ID_swMainBoardVerMismatchNotificaiton, &len_swMainBoardVerMismatchNotificaiton); 
   
    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swOpCodeVer, 
        lenSubID_swOpCodeVer, lenIdx_swOpCodeVer, 
        ID_swOpCodeVer, &len_swOpCodeVer); 

    BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swModuleVerMismatchNotificaiton, 
        lenSubID_swModuleVerMismatchNotificaiton, lenIdx_swModuleVerMismatchNotificaiton, 
        ID_swModuleVerMismatchNotificaiton, &len_swModuleVerMismatchNotificaiton);     

     BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swModuleOpCodeVer, 
        lenSubID_swModuleOpCodeVer, lenIdx_swModuleOpCodeVer, 
        ID_swModuleOpCodeVer, &len_swModuleOpCodeVer);     
   
     BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swExpectedModuleOpCodeVer, 
        lenSubID_swExpectedModuleOpCodeVer, lenIdx_swExpectedModuleOpCodeVer, 
        ID_swExpectedModuleOpCodeVer, &len_swExpectedModuleOpCodeVer);                   
#if (SYS_CPNT_THERMAL_DETECT == TRUE)

     BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swThermalRisingNotification, 
        lenSubID_swThermalRisingNotification, lenIdx_swThermalRisingNotification, 
        ID_swThermalRisingNotification, &len_swThermalRisingNotification); 
        
     BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchThermalTempValue, 
        lenSubID_switchThermalTempValue, lenIdx_switchThermalTempValue, 
        ID_switchThermalTempValue, &len_switchThermalTempValue); 
    
      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchThermalActionRisingThreshold, 
        lenSubID_switchThermalActionRisingThreshold, lenIdx_switchThermalActionRisingThreshold, 
        ID_switchThermalActionRisingThreshold, &len_switchThermalActionRisingThreshold); 
        
      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swThermalFallingNotification, 
        lenSubID_swThermalFallingNotification, lenIdx_swThermalFallingNotification, 
        ID_swThermalFallingNotification, &len_swThermalFallingNotification);  
    
      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchThermalActionFallingThreshold, 
        lenSubID_switchThermalActionFallingThreshold, lenIdx_switchThermalActionFallingThreshold, 
        ID_switchThermalActionFallingThreshold, &len_switchThermalActionFallingThreshold);  
     
#endif

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)

      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swModuleInsertionNotificaiton, 
        lenSubID_swModuleInsertionNotificaiton, lenIdx_swModuleInsertionNotificaiton, 
        ID_swModuleInsertionNotificaiton, &len_swModuleInsertionNotificaiton);  

      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swModuleRemovalNotificaiton, 
        lenSubID_swModuleRemovalNotificaiton, lenIdx_swModuleRemovalNotificaiton, 
        ID_swModuleRemovalNotificaiton, &len_swModuleRemovalNotificaiton);  
#endif

      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_tcnTrap, 
        lenSubID_tcnTrap, lenIdx_tcnTrap, 
        ID_tcnTrap, &len_tcnTrap); 

      BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVarTcnReason, 
        lenSubID_trapVarTcnReason, lenIdx_trapVarTcnReason, 
        ID_trapVarTcnReason, &len_trapVarTcnReason);         

    return TRUE;                                                
}    


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swPowerStatusChangeTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the power state changes.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swPowerStatusChangeTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswIndivPowerUnitIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerUnitIndex,	/* Instance */
	int		ILswIndivPowerUnitIndex,	/* Instance length */
	INT_32_T	AswIndivPowerIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerIndex,	/* Instance */
	int		ILswIndivPowerIndex,	/* Instance length */
	INT_32_T	AswIndivPowerStatus,	/* INTEGER */
	OIDC_T		*IswIndivPowerStatus,	/* Instance */
	int		ILswIndivPowerStatus)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswIndivPowerUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)IswIndivPowerUnitIndex, ILswIndivPowerUnitIndex * sizeof(OIDC_T));
	ILswIndivPowerUnitIndex += len_swIndivPowerUnitIndex;

	if (ILswIndivPowerIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)IswIndivPowerIndex, ILswIndivPowerIndex * sizeof(OIDC_T));
	ILswIndivPowerIndex += len_swIndivPowerIndex;

	if (ILswIndivPowerStatus != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerStatus + len_swIndivPowerStatus), (char*)IswIndivPowerStatus, ILswIndivPowerStatus * sizeof(OIDC_T));
	ILswIndivPowerStatus += len_swIndivPowerStatus;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    1,
				    timestamp,
				    3);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswIndivPowerUnitIndex, ID_swIndivPowerUnitIndex, AswIndivPowerUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswIndivPowerIndex, ID_swIndivPowerIndex, AswIndivPowerIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswIndivPowerStatus, ID_swIndivPowerStatus, AswIndivPowerStatus) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swActivePowerChangeTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the active power is changed(from main to
 **** redundant or redundant to main power).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swActivePowerChangeTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswIndivPowerUnitIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerUnitIndex,	/* Instance */
	int		ILswIndivPowerUnitIndex,	/* Instance length */
	INT_32_T	AswIndivPowerIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerIndex,	/* Instance */
	int		ILswIndivPowerIndex)	/* Instance length */
	
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswIndivPowerUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)IswIndivPowerUnitIndex, ILswIndivPowerUnitIndex * sizeof(OIDC_T));
	ILswIndivPowerUnitIndex += len_swIndivPowerUnitIndex;

	if (ILswIndivPowerIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)IswIndivPowerIndex, ILswIndivPowerIndex * sizeof(OIDC_T));
	ILswIndivPowerIndex += len_swIndivPowerIndex;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    198,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswIndivPowerUnitIndex, ID_swIndivPowerUnitIndex, AswIndivPowerUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswIndivPowerIndex, ID_swIndivPowerIndex, AswIndivPowerIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swPowerStatusChangeTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the power state changes.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swPowerStatusChangeTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswIndivPowerUnitIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerUnitIndex,	/* Instance */
	int		ILswIndivPowerUnitIndex,	/* Instance length */
	INT_32_T	AswIndivPowerIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerIndex,	/* Instance */
	int		ILswIndivPowerIndex,	/* Instance length */
	INT_32_T	AswIndivPowerStatus,	/* INTEGER */
	OIDC_T		*IswIndivPowerStatus,	/* Instance */
	int		ILswIndivPowerStatus)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswIndivPowerUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)IswIndivPowerUnitIndex, ILswIndivPowerUnitIndex * sizeof(OIDC_T));
	ILswIndivPowerUnitIndex += len_swIndivPowerUnitIndex;

	if (ILswIndivPowerIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)IswIndivPowerIndex, ILswIndivPowerIndex * sizeof(OIDC_T));
	ILswIndivPowerIndex += len_swIndivPowerIndex;

	if (ILswIndivPowerStatus != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerStatus + len_swIndivPowerStatus), (char*)IswIndivPowerStatus, ILswIndivPowerStatus * sizeof(OIDC_T));
	ILswIndivPowerStatus += len_swIndivPowerStatus;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   5, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swPowerStatusChangeTrap, ID_swPowerStatusChangeTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswIndivPowerUnitIndex, ID_swIndivPowerUnitIndex, AswIndivPowerUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswIndivPowerIndex, ID_swIndivPowerIndex, AswIndivPowerIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILswIndivPowerStatus, ID_swIndivPowerStatus, AswIndivPowerStatus) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swActivePowerChangeTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the active power is changed(from main to
 **** redundant or redundant to main power).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swActivePowerChangeTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswIndivPowerUnitIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerUnitIndex,	/* Instance */
	int		ILswIndivPowerUnitIndex,	/* Instance length */
	INT_32_T	AswIndivPowerIndex,	/* INTEGER */
	OIDC_T		*IswIndivPowerIndex,	/* Instance */
	int		ILswIndivPowerIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswIndivPowerUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)IswIndivPowerUnitIndex, ILswIndivPowerUnitIndex * sizeof(OIDC_T));
	ILswIndivPowerUnitIndex += len_swIndivPowerUnitIndex;

	if (ILswIndivPowerIndex != 2)
		return -1;
	memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)IswIndivPowerIndex, ILswIndivPowerIndex * sizeof(OIDC_T));
	ILswIndivPowerIndex += len_swIndivPowerIndex;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   5, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swActivePowerChangeTrap, ID_swActivePowerChangeTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswIndivPowerUnitIndex, ID_swIndivPowerUnitIndex, AswIndivPowerUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswIndivPowerIndex, ID_swIndivPowerIndex, AswIndivPowerIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swFanFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the fan is failure.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swFanFailureTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswitchUnitIndex,	/* INTEGER */
	OIDC_T		*IswitchUnitIndex,	/* Instance */
	int		ILswitchUnitIndex,	/* Instance length */
	INT_32_T	AswitchFanIndex,	/* INTEGER */
	OIDC_T		*IswitchFanIndex,	/* Instance */
	int		ILswitchFanIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)IswitchUnitIndex, ILswitchUnitIndex * sizeof(OIDC_T));
	ILswitchUnitIndex += len_switchUnitIndex;

	if (ILswitchFanIndex != 2)
		return -1;
	memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)IswitchFanIndex, ILswitchFanIndex * sizeof(OIDC_T));
	ILswitchFanIndex += len_switchFanIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    17,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswitchUnitIndex, ID_switchUnitIndex, AswitchUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswitchFanIndex, ID_switchFanIndex, AswitchFanIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swFanFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the fan is failure.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swFanFailureTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswitchUnitIndex,	/* INTEGER */
	OIDC_T		*IswitchUnitIndex,	/* Instance */
	int		ILswitchUnitIndex,	/* Instance length */
	INT_32_T	AswitchFanIndex,	/* INTEGER */
	OIDC_T		*IswitchFanIndex,	/* Instance */
	int		ILswitchFanIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)IswitchUnitIndex, ILswitchUnitIndex * sizeof(OIDC_T));
	ILswitchUnitIndex += len_switchUnitIndex;

	if (ILswitchFanIndex != 2)
		return -1;
	memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)IswitchFanIndex, ILswitchFanIndex * sizeof(OIDC_T));
	ILswitchFanIndex += len_switchFanIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swFanFailureTrap, ID_swFanFailureTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswitchUnitIndex, ID_switchUnitIndex, AswitchUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswitchFanIndex, ID_switchFanIndex, AswitchFanIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swFanRecoverTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when fan failure has recovered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swFanRecoverTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswitchUnitIndex,	/* INTEGER */
	OIDC_T		*IswitchUnitIndex,	/* Instance */
	int		ILswitchUnitIndex,	/* Instance length */
	INT_32_T	AswitchFanIndex,	/* INTEGER */
	OIDC_T		*IswitchFanIndex,	/* Instance */
	int		ILswitchFanIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)IswitchUnitIndex, ILswitchUnitIndex * sizeof(OIDC_T));
	ILswitchUnitIndex += len_switchUnitIndex;

	if (ILswitchFanIndex != 2)
		return -1;
	memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)IswitchFanIndex, ILswitchFanIndex * sizeof(OIDC_T));
	ILswitchFanIndex += len_switchFanIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    18,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswitchUnitIndex, ID_switchUnitIndex, AswitchUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswitchFanIndex, ID_switchFanIndex, AswitchFanIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/*****************************************************************************
 ****
 ****
 **** Trap creation function for swFanRecoverTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when fan failure has recovered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swFanRecoverTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswitchUnitIndex,	/* INTEGER */
	OIDC_T		*IswitchUnitIndex,	/* Instance */
	int		ILswitchUnitIndex,	/* Instance length */
	INT_32_T	AswitchFanIndex,	/* INTEGER */
	OIDC_T		*IswitchFanIndex,	/* Instance */
	int		ILswitchFanIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchUnitIndex != 2)
		return -1;
	memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)IswitchUnitIndex, ILswitchUnitIndex * sizeof(OIDC_T));
	ILswitchUnitIndex += len_switchUnitIndex;

	if (ILswitchFanIndex != 2)
		return -1;
	memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)IswitchFanIndex, ILswitchFanIndex * sizeof(OIDC_T));
	ILswitchFanIndex += len_switchFanIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swFanRecoverTrap, ID_swFanRecoverTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswitchUnitIndex, ID_switchUnitIndex, AswitchUnitIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswitchFanIndex, ID_switchFanIndex, AswitchFanIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

#endif

#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE) 
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swPortSecurityTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the port is being intruded. This trap will only be
 **** sent when the portSecAction is set to trap(2) or trapAndShutdown(4).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swPortSecurityTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    36,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swPortSecurityTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the port is being intruded. This trap will only be
 **** sent when the portSecAction is set to trap(2) or trapAndShutdown(4).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swPortSecurityTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swPortSecurityTrap, ID_swPortSecurityTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#endif

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)  
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swLoopbackTestFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the loopback test is fail.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swLoopbackTestFailureTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	int		LswitchLoopbackTestFailurePorts,	/* Length of AswitchLoopbackTestFailurePorts */
	OCTET_T*	AswitchLoopbackTestFailurePorts)	/* OCTET STRING */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    39,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_String(trap_pkt, 0, len_switchLoopbackTestFailurePorts, ID_switchLoopbackTestFailurePorts, VT_STRING, LswitchLoopbackTestFailurePorts, AswitchLoopbackTestFailurePorts, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swLoopbackTestFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the loopback test is fail.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swLoopbackTestFailureTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	int		LswitchLoopbackTestFailurePorts,	/* Length of AswitchLoopbackTestFailurePorts */
	OCTET_T*	AswitchLoopbackTestFailurePorts)	/* OCTET STRING */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swLoopbackTestFailureTrap, ID_swLoopbackTestFailureTrap) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 2, len_switchLoopbackTestFailurePorts, ID_switchLoopbackTestFailurePorts, VT_STRING, LswitchLoopbackTestFailurePorts, AswitchLoopbackTestFailurePorts, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

#endif


#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swIpFilterRejectTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when a incorrect IP address is rejected by the
 **** ipfilter.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swIpFilterRejectTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AtrapIpFilterRejectMode,	/* INTEGER */
	INT_32_T	AtrapIpFilterRejectIp)	/* INTEGER */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    40,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, len_trapIpFilterRejectMode, ID_trapIpFilterRejectMode, AtrapIpFilterRejectMode) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, len_trapIpFilterRejectIp, ID_trapIpFilterRejectIp, AtrapIpFilterRejectIp) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}




/*****************************************************************************
 ****
 ****
 **** Trap creation function for swIpFilterRejectTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when a incorrect IP address is rejected by the
 **** ipfilter.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swIpFilterRejectTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AtrapIpFilterRejectMode,	/* INTEGER */
	INT_32_T	AtrapIpFilterRejectIp)	/* INTEGER */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swIpFilterRejectTrap, ID_swIpFilterRejectTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, len_trapIpFilterRejectMode, ID_trapIpFilterRejectMode, AtrapIpFilterRejectMode) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, len_trapIpFilterRejectIp, ID_trapIpFilterRejectIp, AtrapIpFilterRejectIp) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#endif//end of #if (SYS_CPNT_MGMT_IP_FLT == TRUE)

#if (SYS_CPNT_SMTP == TRUE)

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swSmtpConnFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap will be triggered if the SMTP system cannot open a connection
 **** to the mail server successfully.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swSmtpConnFailureTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	OCTET_T*	AsmtpServerIp,	/* IpAddress */
	OIDC_T		*IsmtpServerIp,	/* Instance */
	int		ILsmtpServerIp)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILsmtpServerIp != 4)
		return -1;
	memcpy((char*)(ID_smtpServerIp + len_smtpServerIp), (char*)IsmtpServerIp, ILsmtpServerIp * sizeof(OIDC_T));
	ILsmtpServerIp += len_smtpServerIp;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    41,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_IP_Address(trap_pkt, 0, ILsmtpServerIp, ID_smtpServerIp, AsmtpServerIp) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swSmtpConnFailureTrap trap
 ****
 **** DESCRIPTION:
 **** This trap will be triggered if the SMTP system cannot open a connection
 **** to the mail server successfully.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swSmtpConnFailureTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	OCTET_T*	AsmtpServerIp,	/* IpAddress */
	OIDC_T		*IsmtpServerIp,	/* Instance */
	int		ILsmtpServerIp)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILsmtpServerIp != 4)
		return -1;
	memcpy((char*)(ID_smtpServerIp + len_smtpServerIp), (char*)IsmtpServerIp, ILsmtpServerIp * sizeof(OIDC_T));
	ILsmtpServerIp += len_smtpServerIp;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swSmtpConnFailureTrap, ID_swSmtpConnFailureTrap) == -1)
		goto fail;

	if (SNMP_Bind_IP_Address(trap_pkt, 2, ILsmtpServerIp, ID_smtpServerIp, AsmtpServerIp) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

#endif

//power ethernet traps
#if (SYS_CPNT_POE == TRUE)

/*****************************************************************************
 ****
 ****
 **** Trap creation function for pethPsePortOnOffNotification trap
 ****
 **** DESCRIPTION:
 **** This Notification indicates if Pse Port is delivering or not power to the
 **** PD. This Notification SHOULD be sent on every status change except in the
 **** searching mode.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_pethPsePortOnOffNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	ApethPsePortDetectionStatus,	/* INTEGER */
	OIDC_T		*IpethPsePortDetectionStatus,	/* Instance */
	int		ILpethPsePortDetectionStatus)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILpethPsePortDetectionStatus != 2)
		return -1;
	memcpy((char*)(ID_pethPsePortDetectionStatus + len_pethPsePortDetectionStatus), (char*)IpethPsePortDetectionStatus, ILpethPsePortDetectionStatus * sizeof(OIDC_T));
	ILpethPsePortDetectionStatus += len_pethPsePortDetectionStatus;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_pethPsePortOnOffNotification, ID_pethPsePortOnOffNotification) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILpethPsePortDetectionStatus, ID_pethPsePortDetectionStatus, ApethPsePortDetectionStatus) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for pethMainPowerUsageOnNotification trap
 ****
 **** DESCRIPTION:
 **** This Notification indicate PSE Threshold usage indication is on, the
 **** usage power is above the threshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_pethMainPowerUsageOnNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_32_T	ApethMainPseConsumptionPower,	/* Gauge */
	OIDC_T		*IpethMainPseConsumptionPower,	/* Instance */
	int		ILpethMainPseConsumptionPower)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILpethMainPseConsumptionPower != 1)
		return -1;
	memcpy((char*)(ID_pethMainPseConsumptionPower + len_pethMainPseConsumptionPower), (char*)IpethMainPseConsumptionPower, ILpethMainPseConsumptionPower * sizeof(OIDC_T));
	ILpethMainPseConsumptionPower += len_pethMainPseConsumptionPower;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_pethMainPowerUsageOnNotification, ID_pethMainPowerUsageOnNotification) == -1)
		goto fail;

	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 2, ILpethMainPseConsumptionPower, ID_pethMainPseConsumptionPower, VT_GAUGE, ApethMainPseConsumptionPower) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for pethMainPowerUsageOffNotification trap
 ****
 **** DESCRIPTION:
 **** This Notification indicate PSE Threshold usage indication off, the usage
 **** power is below the threshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_pethMainPowerUsageOffNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_32_T	ApethMainPseConsumptionPower,	/* Gauge */
	OIDC_T		*IpethMainPseConsumptionPower,	/* Instance */
	int		ILpethMainPseConsumptionPower)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILpethMainPseConsumptionPower != 1)
		return -1;
	memcpy((char*)(ID_pethMainPseConsumptionPower + len_pethMainPseConsumptionPower), (char*)IpethMainPseConsumptionPower, ILpethMainPseConsumptionPower * sizeof(OIDC_T));
	ILpethMainPseConsumptionPower += len_pethMainPseConsumptionPower;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_pethMainPowerUsageOffNotification, ID_pethMainPowerUsageOffNotification) == -1)
		goto fail;

	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 2, ILpethMainPseConsumptionPower, ID_pethMainPseConsumptionPower, VT_GAUGE, ApethMainPseConsumptionPower) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#endif//end of #if (SYS_CPNT_POE == TRUE)

#if (SYS_CPNT_VDSL == TRUE)



/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfLofsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Loss of Framing 15-minute interval threshold (vdslThresh15MinLofs)
 **** reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfLofsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinLofs,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinLofs,	/* Instance */
	int		ILvdslPerfCurr15MinLofs)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinLofs != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinLofs + len_vdslPerfCurr15MinLofs), (char*)IvdslPerfCurr15MinLofs, ILvdslPerfCurr15MinLofs * sizeof(OIDC_T));
	ILvdslPerfCurr15MinLofs += len_vdslPerfCurr15MinLofs;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfLofsThreshNotification, ID_vdslPerfLofsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinLofs, ID_vdslPerfCurr15MinLofs, VT_COUNTER64, UI64High(AvdslPerfCurr15MinLofs), UI64Low(AvdslPerfCurr15MinLofs)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfLossThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Loss of Signal 15-minute interval threshold (vdslThresh15MinLoss)
 **** reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfLossThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinLoss,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinLoss,	/* Instance */
	int		ILvdslPerfCurr15MinLoss)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinLoss != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinLoss + len_vdslPerfCurr15MinLoss), (char*)IvdslPerfCurr15MinLoss, ILvdslPerfCurr15MinLoss * sizeof(OIDC_T));
	ILvdslPerfCurr15MinLoss += len_vdslPerfCurr15MinLoss;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfLossThreshNotification, ID_vdslPerfLossThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinLoss, ID_vdslPerfCurr15MinLoss, VT_COUNTER64, UI64High(AvdslPerfCurr15MinLoss), UI64Low(AvdslPerfCurr15MinLoss)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfLprsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Loss of Power 15-minute interval threshold (vdslThresh15MinLprs) reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfLprsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinLprs,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinLprs,	/* Instance */
	int		ILvdslPerfCurr15MinLprs)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinLprs != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinLprs + len_vdslPerfCurr15MinLprs), (char*)IvdslPerfCurr15MinLprs, ILvdslPerfCurr15MinLprs * sizeof(OIDC_T));
	ILvdslPerfCurr15MinLprs += len_vdslPerfCurr15MinLprs;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfLprsThreshNotification, ID_vdslPerfLprsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinLprs, ID_vdslPerfCurr15MinLprs, VT_COUNTER64, UI64High(AvdslPerfCurr15MinLprs), UI64Low(AvdslPerfCurr15MinLprs)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfLolsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Loss of Link 15-minute interval threshold (vdslThresh15MinLols) reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfLolsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinLols,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinLols,	/* Instance */
	int		ILvdslPerfCurr15MinLols)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinLols != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinLols + len_vdslPerfCurr15MinLols), (char*)IvdslPerfCurr15MinLols, ILvdslPerfCurr15MinLols * sizeof(OIDC_T));
	ILvdslPerfCurr15MinLols += len_vdslPerfCurr15MinLols;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfLolsThreshNotification, ID_vdslPerfLolsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinLols, ID_vdslPerfCurr15MinLols, VT_COUNTER64, UI64High(AvdslPerfCurr15MinLols), UI64Low(AvdslPerfCurr15MinLols)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfESsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Errored Seconds 15-minute interval threshold (vdslThresh15MinESs)
 **** reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfESsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinESs,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinESs,	/* Instance */
	int		ILvdslPerfCurr15MinESs)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinESs != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinESs + len_vdslPerfCurr15MinESs), (char*)IvdslPerfCurr15MinESs, ILvdslPerfCurr15MinESs * sizeof(OIDC_T));
	ILvdslPerfCurr15MinESs += len_vdslPerfCurr15MinESs;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfESsThreshNotification, ID_vdslPerfESsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinESs, ID_vdslPerfCurr15MinESs, VT_COUNTER64, UI64High(AvdslPerfCurr15MinESs), UI64Low(AvdslPerfCurr15MinESs)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfSESsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Severely Errored Seconds 15-minute interval threshold
 **** (vdslThresh15MinSESs) reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfSESsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinSESs,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinSESs,	/* Instance */
	int		ILvdslPerfCurr15MinSESs)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinSESs != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinSESs + len_vdslPerfCurr15MinSESs), (char*)IvdslPerfCurr15MinSESs, ILvdslPerfCurr15MinSESs * sizeof(OIDC_T));
	ILvdslPerfCurr15MinSESs += len_vdslPerfCurr15MinSESs;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfSESsThreshNotification, ID_vdslPerfSESsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinSESs, ID_vdslPerfCurr15MinSESs, VT_COUNTER64, UI64High(AvdslPerfCurr15MinSESs), UI64Low(AvdslPerfCurr15MinSESs)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*****************************************************************************
 ****
 ****
 **** Trap creation function for vdslPerfUASsThreshNotification trap
 ****
 **** DESCRIPTION:
 **** Unavailable Seconds 15-minute interval threshold (vdslThresh15MinUASs)
 **** reached.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_vdslPerfUASsThreshNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	UINT_64_T*	AvdslPerfCurr15MinUASs,	/* Counter64 */
	OIDC_T		*IvdslPerfCurr15MinUASs,	/* Instance */
	int		ILvdslPerfCurr15MinUASs)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILvdslPerfCurr15MinUASs != 2)
		return -1;
	memcpy((char*)(ID_vdslPerfCurr15MinUASs + len_vdslPerfCurr15MinUASs), (char*)IvdslPerfCurr15MinUASs, ILvdslPerfCurr15MinUASs * sizeof(OIDC_T));
	ILvdslPerfCurr15MinUASs += len_vdslPerfCurr15MinUASs;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_vdslPerfUASsThreshNotification, ID_vdslPerfUASsThreshNotification) == -1)
		goto fail;

	if (SNMP_Bind_64_Unsigned_Integer(trap_pkt, 2, ILvdslPerfCurr15MinUASs, ID_vdslPerfCurr15MinUASs, VT_COUNTER64, UI64High(AvdslPerfCurr15MinUASs), UI64Low(AvdslPerfCurr15MinUASs)) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

#endif//end of #if (SYS_CPNT_VDSL == TRUE)

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swMainBoardVerMismatchNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the slave version is mismatch with the master
 **** version. This trap will binds two object, the first object indicate the
 **** master version, whereas the second represent the slave version.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swMainBoardVerMismatchNotificaiton_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	int		LswOpCodeVer1,	/* Length of AswOpCodeVer */
	OCTET_T*	AswOpCodeVer1,	/* OCTET STRING */
	OIDC_T		*IswOpCodeVer1,	/* Instance */
	int		ILswOpCodeVer1,	/* Instance length */
	int		LswOpCodeVer2,	/* Length of AswOpCodeVer */
	OCTET_T*	AswOpCodeVer2,	/* OCTET STRING */
	OIDC_T		*IswOpCodeVer2,	/* Instance */
	int		ILswOpCodeVer2)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswOpCodeVer1 != 1)
		return -1;
	memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)IswOpCodeVer1, ILswOpCodeVer1 * sizeof(OIDC_T));
	ILswOpCodeVer1 += len_swOpCodeVer;

	if (ILswOpCodeVer2 != 1)
		return -1;
	memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)IswOpCodeVer2, ILswOpCodeVer2 * sizeof(OIDC_T));
	ILswOpCodeVer2 += len_swOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    56,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_String(trap_pkt, 0, ILswOpCodeVer1, ID_swOpCodeVer, VT_STRING, LswOpCodeVer1, AswOpCodeVer1, 1) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 1, ILswOpCodeVer2, ID_swOpCodeVer, VT_STRING, LswOpCodeVer2, AswOpCodeVer2, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swMainBoardVerMismatchNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the slave version is mismatch with the master
 **** version. This trap will binds two object, the first object indicate the
 **** master version, whereas the second represent the slave version.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swMainBoardVerMismatchNotificaiton_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	int		LswOpCodeVer1,	/* Length of AswOpCodeVer */
	OCTET_T*	AswOpCodeVer1,	/* OCTET STRING */
	OIDC_T		*IswOpCodeVer1,	/* Instance */
	int		ILswOpCodeVer1,	/* Instance length */
	int		LswOpCodeVer2,	/* Length of AswOpCodeVer */
	OCTET_T*	AswOpCodeVer2,	/* OCTET STRING */
	OIDC_T		*IswOpCodeVer2,	/* Instance */
	int		ILswOpCodeVer2)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswOpCodeVer1 != 1)
		return -1;
	memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)IswOpCodeVer1, ILswOpCodeVer1 * sizeof(OIDC_T));
	ILswOpCodeVer1 += len_swOpCodeVer;

	if (ILswOpCodeVer2 != 1)
		return -1;
	memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)IswOpCodeVer2, ILswOpCodeVer2 * sizeof(OIDC_T));
	ILswOpCodeVer2 += len_swOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swMainBoardVerMismatchNotificaiton, ID_swMainBoardVerMismatchNotificaiton) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 2, ILswOpCodeVer1, ID_swOpCodeVer, VT_STRING, LswOpCodeVer1, AswOpCodeVer1, 1) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 3, ILswOpCodeVer2, ID_swOpCodeVer, VT_STRING, LswOpCodeVer2, AswOpCodeVer2, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleVerMismatchNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module version is mismatch with the main board
 **** version.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleVerMismatchNotificaiton_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	int		LswExpectedModuleOpCodeVer,	/* Length of AswExpectedModuleOpCodeVer */
	OCTET_T*	AswExpectedModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswExpectedModuleOpCodeVer,	/* Instance */
	int		ILswExpectedModuleOpCodeVer,	/* Instance length */
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswExpectedModuleOpCodeVer != 1)
		return -1;
	memcpy((char*)(ID_swExpectedModuleOpCodeVer + len_swExpectedModuleOpCodeVer), (char*)IswExpectedModuleOpCodeVer, ILswExpectedModuleOpCodeVer * sizeof(OIDC_T));
	ILswExpectedModuleOpCodeVer += len_swExpectedModuleOpCodeVer;

	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    57,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_String(trap_pkt, 0, ILswExpectedModuleOpCodeVer, ID_swExpectedModuleOpCodeVer, VT_STRING, LswExpectedModuleOpCodeVer, AswExpectedModuleOpCodeVer, 1) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 1, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleVerMismatchNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module version is mismatch with the main board
 **** version.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleVerMismatchNotificaiton_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	int		LswExpectedModuleOpCodeVer,	/* Length of AswExpectedModuleOpCodeVer */
	OCTET_T*	AswExpectedModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswExpectedModuleOpCodeVer,	/* Instance */
	int		ILswExpectedModuleOpCodeVer,	/* Instance length */
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswExpectedModuleOpCodeVer != 1)
		return -1;
	memcpy((char*)(ID_swExpectedModuleOpCodeVer + len_swExpectedModuleOpCodeVer), (char*)IswExpectedModuleOpCodeVer, ILswExpectedModuleOpCodeVer * sizeof(OIDC_T));
	ILswExpectedModuleOpCodeVer += len_swExpectedModuleOpCodeVer;

	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swModuleVerMismatchNotificaiton, ID_swModuleVerMismatchNotificaiton) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 2, ILswExpectedModuleOpCodeVer, ID_swExpectedModuleOpCodeVer, VT_STRING, LswExpectedModuleOpCodeVer, AswExpectedModuleOpCodeVer, 1) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 3, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


#if (SYS_CPNT_THERMAL_DETECT == TRUE)
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swThermalRisingNotification trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the temperature is over the
 **** switchThermalActionRisingThreshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swThermalRisingNotification_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswitchThermalTempValue,	/* INTEGER */
	OIDC_T		*IswitchThermalTempValue,	/* Instance */
	int		ILswitchThermalTempValue,	/* Instance length */
	INT_32_T	AswitchThermalActionRisingThreshold,	/* INTEGER */
	OIDC_T		*IswitchThermalActionRisingThreshold,	/* Instance */
	int		ILswitchThermalActionRisingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchThermalTempValue != 2)
		return -1;
	memcpy((char*)(ID_switchThermalTempValue + len_switchThermalTempValue), (char*)IswitchThermalTempValue, ILswitchThermalTempValue * sizeof(OIDC_T));
	ILswitchThermalTempValue += len_switchThermalTempValue;

	if (ILswitchThermalActionRisingThreshold != 3)
		return -1;
	memcpy((char*)(ID_switchThermalActionRisingThreshold + len_switchThermalActionRisingThreshold), (char*)IswitchThermalActionRisingThreshold, ILswitchThermalActionRisingThreshold * sizeof(OIDC_T));
	ILswitchThermalActionRisingThreshold += len_switchThermalActionRisingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    58,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswitchThermalTempValue, ID_switchThermalTempValue, AswitchThermalTempValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswitchThermalActionRisingThreshold, ID_switchThermalActionRisingThreshold, AswitchThermalActionRisingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swThermalRisingNotification trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the temperature is over the
 **** switchThermalActionRisingThreshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swThermalRisingNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswitchThermalTempValue,	/* INTEGER */
	OIDC_T		*IswitchThermalTempValue,	/* Instance */
	int		ILswitchThermalTempValue,	/* Instance length */
	INT_32_T	AswitchThermalActionRisingThreshold,	/* INTEGER */
	OIDC_T		*IswitchThermalActionRisingThreshold,	/* Instance */
	int		ILswitchThermalActionRisingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchThermalTempValue != 2)
		return -1;
	memcpy((char*)(ID_switchThermalTempValue + len_switchThermalTempValue), (char*)IswitchThermalTempValue, ILswitchThermalTempValue * sizeof(OIDC_T));
	ILswitchThermalTempValue += len_switchThermalTempValue;

	if (ILswitchThermalActionRisingThreshold != 3)
		return -1;
	memcpy((char*)(ID_switchThermalActionRisingThreshold + len_switchThermalActionRisingThreshold), (char*)IswitchThermalActionRisingThreshold, ILswitchThermalActionRisingThreshold * sizeof(OIDC_T));
	ILswitchThermalActionRisingThreshold += len_switchThermalActionRisingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swThermalRisingNotification, ID_swThermalRisingNotification) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswitchThermalTempValue, ID_switchThermalTempValue, AswitchThermalTempValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswitchThermalActionRisingThreshold, ID_switchThermalActionRisingThreshold, AswitchThermalActionRisingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for swThermalFallingNotification trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the temperature is below the
 **** switchThermalActionFallingThreshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swThermalFallingNotification_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AswitchThermalTempValue,	/* INTEGER */
	OIDC_T		*IswitchThermalTempValue,	/* Instance */
	int		ILswitchThermalTempValue,	/* Instance length */
	INT_32_T	AswitchThermalActionFallingThreshold,	/* INTEGER */
	OIDC_T		*IswitchThermalActionFallingThreshold,	/* Instance */
	int		ILswitchThermalActionFallingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchThermalTempValue != 2)
		return -1;
	memcpy((char*)(ID_switchThermalTempValue + len_switchThermalTempValue), (char*)IswitchThermalTempValue, ILswitchThermalTempValue * sizeof(OIDC_T));
	ILswitchThermalTempValue += len_switchThermalTempValue;

	if (ILswitchThermalActionFallingThreshold != 3)
		return -1;
	memcpy((char*)(ID_switchThermalActionFallingThreshold + len_switchThermalActionFallingThreshold), (char*)IswitchThermalActionFallingThreshold, ILswitchThermalActionFallingThreshold * sizeof(OIDC_T));
	ILswitchThermalActionFallingThreshold += len_switchThermalActionFallingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    59,
				    timestamp,
				    2);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILswitchThermalTempValue, ID_switchThermalTempValue, AswitchThermalTempValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 1, ILswitchThermalActionFallingThreshold, ID_switchThermalActionFallingThreshold, AswitchThermalActionFallingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swThermalFallingNotification trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the temperature is below the
 **** switchThermalActionFallingThreshold.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swThermalFallingNotification_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AswitchThermalTempValue,	/* INTEGER */
	OIDC_T		*IswitchThermalTempValue,	/* Instance */
	int		ILswitchThermalTempValue,	/* Instance length */
	INT_32_T	AswitchThermalActionFallingThreshold,	/* INTEGER */
	OIDC_T		*IswitchThermalActionFallingThreshold,	/* Instance */
	int		ILswitchThermalActionFallingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswitchThermalTempValue != 2)
		return -1;
	memcpy((char*)(ID_switchThermalTempValue + len_switchThermalTempValue), (char*)IswitchThermalTempValue, ILswitchThermalTempValue * sizeof(OIDC_T));
	ILswitchThermalTempValue += len_switchThermalTempValue;

	if (ILswitchThermalActionFallingThreshold != 3)
		return -1;
	memcpy((char*)(ID_switchThermalActionFallingThreshold + len_switchThermalActionFallingThreshold), (char*)IswitchThermalActionFallingThreshold, ILswitchThermalActionFallingThreshold * sizeof(OIDC_T));
	ILswitchThermalActionFallingThreshold += len_switchThermalActionFallingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   4, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swThermalFallingNotification, ID_swThermalFallingNotification) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILswitchThermalTempValue, ID_switchThermalTempValue, AswitchThermalTempValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILswitchThermalActionFallingThreshold, ID_switchThermalActionFallingThreshold, AswitchThermalActionFallingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#endif//end of #if (SYS_CPNT_THERMAL_DETECT == TRUE)



#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleInsertionNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module is inserted.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleInsertionNotificaiton_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    60,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_String(trap_pkt, 0, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleInsertionNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module is inserted.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleInsertionNotificaiton_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swModuleInsertionNotificaiton, ID_swModuleInsertionNotificaiton) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 2, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleRemovalNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module is removed.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleRemovalNotificaiton_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    61,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_String(trap_pkt, 0, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for swModuleRemovalNotificaiton trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when the module is removed.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_swModuleRemovalNotificaiton_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	int		LswModuleOpCodeVer,	/* Length of AswModuleOpCodeVer */
	OCTET_T*	AswModuleOpCodeVer,	/* OCTET STRING */
	OIDC_T		*IswModuleOpCodeVer,	/* Instance */
	int		ILswModuleOpCodeVer)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILswModuleOpCodeVer != 2)
		return -1;
	memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)IswModuleOpCodeVer, ILswModuleOpCodeVer * sizeof(OIDC_T));
	ILswModuleOpCodeVer += len_swModuleOpCodeVer;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_swModuleRemovalNotificaiton, ID_swModuleRemovalNotificaiton) == -1)
		goto fail;

	if (SNMP_Bind_String(trap_pkt, 2, ILswModuleOpCodeVer, ID_swModuleOpCodeVer, VT_STRING, LswModuleOpCodeVer, AswModuleOpCodeVer, 1) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
#endif//end of #if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
//========

/*****************************************************************************
 ****
 ****
 **** Trap creation function for tcnTrap trap
 ****
 **** DESCRIPTION:
 **** This trap is sent when TCN happens.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_tcnTrap_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AtrapVarTcnReason)	/* INTEGER */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_es3626aMIB, ID_es3626aMIB,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    63,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, len_trapVarTcnReason, ID_trapVarTcnReason, AtrapVarTcnReason) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*****************************************************************************
 ****
 ****
 **** Trap creation function for tcnTrap trap
 ****
 **** DESCRIPTION:
 **** The variabele descibe the reason of TCN. pushButton(1),
 **** stackingLinkDown(2), stackingLinkUp(3), hbtTimeout(4), hbtError(5),
 **** slave(6).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_tcnTrap_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AtrapVarTcnReason)	/* INTEGER */
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   3, 0, 0);
				   
	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_tcnTrap, ID_tcnTrap) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, len_trapVarTcnReason, ID_trapVarTcnReason, AtrapVarTcnReason) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for craft port linkDown trap
 ****
 **** DESCRIPTION:
 **** A linkDown trap signifies that the SNMP entity, acting in an agent role,
 **** has detected that link of craft port is about to enter the down
 **** state from some other state.(but not from the notPresent state)
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_craftLinkDown_trap(
    EBUFFER_T   *ebuff,
    OCTET_T     *local_ip,
    char        *community,
    unsigned    comlen,
    UINT_32_T   timestamp)
{
    SNMP_PKT_T    *trap_pkt;

    /* Create the SNMP packet structure. */
    trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
                    system_oid.num_components, system_oid.component_list,
                    local_ip,
                    6,/* enterpriseSpecific(6) */
                    206,/* LEAF_craftPortLinkDown */
                    timestamp,
                    0);

    /* Verify that SNMP_Create_Trap succeeded. */
    if (trap_pkt == (SNMP_PKT_T*)0)
        return 0;

    /* Encode the packet as bytes into the user-supplied buffer. */
    if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
        goto fail;

    /* Free the SNMP packet structure. */
    SNMP_Free(trap_pkt);

    /* Return the number of bytes used in the buffer. */
    return EBufferUsed(ebuff);

fail:
    /* Come here on failure during bind or encode. */
    SNMP_Free(trap_pkt);
    return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for craft port linkDown trap
 ****
 **** DESCRIPTION:
 **** A linkDown trap signifies that the SNMP entity, acting in an agent role,
 **** has detected that the ifOperStatus object for the link of craft port
 **** is about to enter the down state from some other state (but not
 **** from the notPresent state).
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_craftLinkDown_trapV2(
    EBUFFER_T   *ebuff,
    char        *community,
    int         comlen,
    INT_32_T    request_id,
    UINT_32_T   timestamp)
{
    SNMP_PKT_T    *trap_pkt;

    /* Create the SNMP packet structure. */
    trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
                   comlen, community, request_id,
                   5, 0, 0);

    /* Verify that SNMP_Create_V2_Request succeeded. */
    if (trap_pkt == (SNMP_PKT_T*)0)
        return 0;

    /* Bind the variables in the trap. */
    if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
        goto fail;

    /* Encode the packet as bytes into the user-supplied buffer. */
    if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
        goto fail;

    /* Free the SNMP packet structure. */
    SNMP_Free(trap_pkt);

    /* Return the number of bytes used in the buffer. */
    return EBufferUsed(ebuff);

fail:
    /* Come here on failure during bind or encode. */
    SNMP_Free(trap_pkt);
    return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for craft port linkUp trap
 ****
 **** DESCRIPTION:
 **** A linkUp trap signifies that the sending protocol entity recognizes that
 **** the link of craft port has come up.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_craftLinkUp_trap(
    EBUFFER_T   *ebuff,
    OCTET_T     *local_ip,
    char        *community,
    unsigned    comlen,
    UINT_32_T   timestamp)
{
    SNMP_PKT_T    *trap_pkt;

    /* Create the SNMP packet structure. */
    trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
                    system_oid.num_components, system_oid.component_list,
                    local_ip,
                    6,/* enterpriseSpecific(6) */
                    207,/* LEAF_craftPortLinkUp */
                    timestamp,
                    0);

    /* Verify that SNMP_Create_Trap succeeded. */
    if (trap_pkt == (SNMP_PKT_T*)0)
        return 0;

    /* Encode the packet as bytes into the user-supplied buffer. */
    if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
        goto fail;

    /* Free the SNMP packet structure. */
    SNMP_Free(trap_pkt);

    /* Return the number of bytes used in the buffer. */
    return EBufferUsed(ebuff);

fail:
    /* Come here on failure during bind or encode. */
    SNMP_Free(trap_pkt);
    return 0;
}

/*****************************************************************************
 ****
 ****
 **** Trap creation function for craft port linkUp trap
 ****
 **** DESCRIPTION:
 **** A linkUp trap signifies that the sending protocol entity recognizes that
 **** the link of craft port has come up.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_craftLinkUp_trapV2(
    EBUFFER_T   *ebuff,
    char        *community,
    int         comlen,
    INT_32_T    request_id,
    UINT_32_T   timestamp)
{
    SNMP_PKT_T    *trap_pkt;

    /* Create the SNMP packet structure. */
    trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
                   comlen, community, request_id,
                   5, 0, 0);

    /* Verify that SNMP_Create_V2_Request succeeded. */
    if (trap_pkt == (SNMP_PKT_T*)0)
        return 0;

    /* Bind the variables in the trap. */
    if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
        goto fail;

    /* Encode the packet as bytes into the user-supplied buffer. */
    if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
        goto fail;

    /* Free the SNMP packet structure. */
    SNMP_Free(trap_pkt);

    /* Return the number of bytes used in the buffer. */
    return EBufferUsed(ebuff);

fail:
    /* Come here on failure during bind or encode. */
    SNMP_Free(trap_pkt);
    return 0;
}

