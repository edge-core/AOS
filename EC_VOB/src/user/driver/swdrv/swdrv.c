/* Module Name: SWDRV.C
 * Purpose:
 *        ( 1. Whole module function and scope.                 )
 *         This file provides switch driver interface.
 *        ( 2.  The domain MUST be handled by this module.      )
 *         This module includes port configuration, VLAN, port mirroring,
 *         trunking, spanning tree, IGMP, broadcast storm control, and
 *         port mapping.
 *        ( 3.  The domain would not be handled by this module. )
 *         But this module doesn't include MAC address manipulation and
 *         port statistics.
 * Notes:
 *        ( Something must be known or noticed by developer     )
 * History:
 *       Date        Modifier        Reason
 *       2001/6/1    Jimmy Lin       Create this file
 *       2002/9/20   Jeff Kao        Add Stacking & Transition Mode
 *       2002/10/23  Dino King       Change called drv from BCMDRV to DEV_SWDRV
 *       2002/10/24  Jeff Kao        move l3swdrv API. to here
 *       2003/1/24   Charles Cheng   Add MAU MIB code.
 *
 * Copyright(C)      Accton Corporation, 1999, 2000
 */

/* INCLUDE FILE DECLARATIONS
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sysfun.h"
#include "sys_cpnt.h"
#include "sys_bld.h"
#include "sys_adpt.h"
#include "sys_hwcfg.h"
#include "leaf_1493.h"
#include "leaf_2674p.h"
#include "leaf_2674q.h"
#include "leaf_es3626a.h"
#include "leaf_sys.h"
#include "swdrv.h"
#include "leaf_2863.h"
#include "sys_dflt.h"
#include "sysrsc_mgr.h"


#if defined (XGS_SWITCH)
#include "dev_swdrv.h"
#include "dev_swdrvl4.h"
#include "hrdrv.h"
#endif

#include "stktplg_type.h"
#include "stktplg_om.h"
#include "stktplg_pom.h"
#include "stktplg_pmgr.h"
#include "stktplg_shom.h"
#if (SYS_CPNT_SYSLOG == TRUE)
#include "syslog_type.h"
#include "syslog_pmgr.h"
#include "syslog_task.h"
#endif
#include "uc_mgr.h"
#include "swdrv_type.h"
#include "swdrv_lib.h"

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
#include "swdrv_cache_mgr.h"
#endif

#if (SYS_CPNT_HRDRV == TRUE)
#include "hrdrv.h"
#endif

#if (SYS_CPNT_MGMT_PORT == TRUE)
#include "adm_nic.h"
#endif

#define BACKDOOR_OPEN

#ifdef BACKDOOR_OPEN
#include "backdoor_mgr.h"
#endif

#include "sys_module.h"
#include "swdrv_om.h"
#include "dev_swdrv_pmgr.h"
#include "dev_swdrvl4_pmgr.h"
#include "sys_callback_mgr.h"

#include "rule_ctrl.h"
#include "sys_time.h"

#if (SYS_CPNT_SYNCE==TRUE)
#include "stktplg_board.h"
#endif

#include "sysdrv.h"
#include "i2cdrv.h"

#if 0
#define DBG_PRINT(format,...) printf("%s(%d): "format"\r\n",__FUNCTION__,__LINE__,##__VA_ARGS__); fflush(stdout);
#else
#define DBG_PRINT(format,...)
#endif

/* NAMING CONSTANT DECLARATIONS
 */
#define LOCAL_HOST                      1

#if (SYS_CPNT_STACKING == TRUE)
#define SWDRV_TIME_OUT                  2400            /* time to wait for ISC reply */
#define SWDRV_TRY_TIMES                 4
#define SWDRV_ALL_UNIT                  255            /* all unit number  */
#define MASTER_UNIT                     1
#define SWDRV_OPTION_MODULE             255
#endif /*SYS_CPNT_STACKING*/

#define ALL_DEVICE_ID                   -1

#define SWDRV_PORT_FLOW_CONTROL_OPER_STATUS_CHANGED     0x02

/* MACRO FUNCTIONS */


/* TYPE DECLARATIONS
 */

/* Beginning of modifications, Benson 07/04/2002 */

/* if support L2 stacking */

#if (SYS_CPNT_STACKING == TRUE)

/* service ID list
 */
/* For a driver CSC's service ID (CSC internal function call between master and slave),
    1. NO compiler option for it
    2. NO inserting a new service ID -- SHALL append a new service ID and add sys_cpnt_xxx comment
    3. NO hard code the digital numbers as what current swdrv does.
 */
typedef enum
{
    SWDRV_ENABLE_PORT_ADMIN,
    SWDRV_DISABLE_PORT_ADMIN,
    SWDRV_SET_PORT_CFG_SPEED_DUPLEX,
    SWDRV_ENABLE_PORT_AUTONEG,
    SWDRV_DISABLE_PORT_AUTONEG,
    SWDRV_ENABLE_PORT_CFG_FLOWCTRL,
    SWDRV_DISABLE_PORT_CFG_FLOWCTRL,
    SWDRV_SET_PORT_CFG_FLOWCTRL,
    SWDRV_SET_PORT_AUTONEG_CAPABILITY,
    SWDRV_SET_PORT_STA_STATE,
    SWDRV_ENABLE_MULTI_STA,                                 /*SYS_CPNT_STP_TYPE_MSTP*/
    SWDRV_DISABLE_MULTI_STA,                                /*SYS_CPNT_STP_TYPE_MSTP*/
    SWDRV_SET_PORT_XSTP_STATE,
    SWDRV_GET_PORT_TYPE,
    SWDRV_GET_PORT_LOOPBACK_TEST_RESULT,                    /*SYS_CPNT_3COM_LOOPBACK_TEST*/
    SWDRV_SET_PORT_PVID,
    SWDRV_CREATE_VLAN,
    SWDRV_DESTROY_VLAN,
    SWDRV_ADD_PORT_TO_VLAN_MEMBER_SET,
    SWDRV_DELETE_PORT_FROM_VLAN_MEMBER_SET,
    SWDRV_ADD_PORT_TO_VLAN_UNTAGGED_SET,
    SWDRV_DELETE_PORT_FROM_VLAN_UNTAGGED_SET,
    SWDRV_ENABLE_INGRESS_FILTER,
    SWDRV_DISABLE_INGRESS_FILTER,
    SWDRV_ADMIT_VLAN_TAGGED_FRAMES_ONLY,
    SWDRV_ADMIT_VLAN_UNTAGGED_FRAMES_ONLY,
    SWDRV_ADMIT_ALL_FRAMES,
    SWDRV_ENABLE_TRAP_UNSPECIFIED_TAG_FRAME,
    SWDRV_DISABLE_TRAP_UNSPECIFIED_TAG_FRAME,
    SWDRV_ADD_HOST_TO_VLAN,
    SWDRV_DELETE_HOST_FROM_VLAN,
    SWDRV_SET_PORT_MIRRORING,
    SWDRV_DELETE_PORT_MIRRORING,
    SWDRV_ENABLE_PORT_MIRRORING,
    SWDRV_DISABLE_PORT_MIRRORING,
    SWDRV_CREATE_TRUNK,
    SWDRV_DESTROY_TRUNK,
    SWDRV_SET_TRUNK_PORTS,
    SWDRV_ENABLE_IGMP_TRAP,
    SWDRV_DISABLE_IGMP_TRAP,
    SWDRV_SET_ORG_SPECIFIC_TRAP,
    SWDRV_ADD_MULTICAST_ADDR_TO_TRUNK_MEMBER,
    SWDRV_SET_UNKNOWN_IP_MCAST_FWD_PORTLIST,
    SWDRV_SET_BROADCAST_STORM_CONTROL_THRESHOLD,
    SWDRV_ENABLE_BROADCAST_STORM_CONTROL,
    SWDRV_DISABLE_BROADCAST_STORM_CONTROL,
    SWDRV_ENABLE_MULTICAST_STORM_CONTROL,
    SWDRV_DISABLE_MULTICAST_STORM_CONTROL,
    SWDRV_SET_PORT_USER_DEFAULT_PRIORITY,
    SWDRV_SET_PRIORITY_MAPPING,
    SWDRV_SET_STACKING_PORT_PRIORITY_MAPPING,               /*SYS_CPNT_STACKING*/
    SWDRV_ENABLE_TRAFFIC_SEGMATATION,                       /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION*/
    SWDRV_DISABLE_TRAFFIC_SEGMATATION,                      /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION*/
    SWDRV_SET_TRAFFIC_SEGMATATION,                          /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION*/
    SWDRV_RESET_TRAFFIC_SEGMATATION,                        /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION*/
    SWDRV_SET_PORT_INGRESS_RATE_LIMIT,                      /*SYS_CPNT_INGRESS_RATE_LIMIT*/
    SWDRV_ENABLE_PORT_INGRESS_RATE_LIMIT,                   /*SYS_CPNT_INGRESS_RATE_LIMIT*/
    SWDRV_DISABLE_PORT_INGRESS_RATE_LIMIT,                  /*SYS_CPNT_INGRESS_RATE_LIMIT*/
    SWDRV_ENABLE_PORT_EGRESS_RATE_LIMIT,                    /*SYS_CPNT_EGRESS_RATE_LIMIT*/
    SWDRV_DISABLE_PORT_EGRESS_RATE_LIMIT,                   /*SYS_CPNT_EGRESS_RATE_LIMIT*/
    SWDRV_SET_PORT_EGRESS_RATE_LIMIT,                       /*SYS_CPNT_EGRESS_RATE_LIMIT*/
    SWDRV_ENABLE_JUMBO_FRAME,                               /*SYS_CPNT_JUMBO_FRAMES*/
    SWDRV_DISABLE_JUMBO_FRAME,                              /*SYS_CPNT_JUMBO_FRAMES*/
    SWDRV_SET_PORT_FORCED_MODE,                             /*SYS_CPNT_COMBO_PORT_FORCE_MODE*/
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
    SWDRV_SET_EGRESS_SCHEDULING_METHOD,
#endif
    SWDRV_SET_PORT_EGRESS_SCHEDULING_METHOD,
    SWDRV_ENABLE_PORT_WRR_QUEUE_WEIGHT,
    SWDRV_DISABLE_PORT_WRR_QUEUE_WEIGHT,
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
    SWDRV_SET_WRR_QUEUE_WEIGHT,
    SWDRV_SET_STRICT_PRIORITY_QUEUE,
#endif
    SWDRV_SET_PORT_WRR_QUEUE_WEIGHT,
    SWDRV_ENABLE_PORT_SECURITY,                             /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_DISABLE_PORT_SECURITY,                            /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_PORT_SECURITY_ACTION_NONE,                        /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_PORT_SECURITY_ACTION_TRAP,                        /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_PORT_SECURITY_ACTION_SHUTDOWN,                    /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_PORT_SECURITY_ACTION_TRAP_AND_SHUTDOWN,           /*SYS_CPNT_PORT_SECURITY*/
    SWDRV_PORT_DISABLE_LEARNING,
    SWDRV_PORT_ENABLE_LEARNING,
    SWDRV_ENABLE_IPMC,
    SWDRV_DISABLE_IPMC,
    SWDRV_SET_PORT_RESTART_AUTO_NEGO,                       /*SYS_CPNT_MAU_MIB*/
    SWDRV_SET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT,    /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT,    /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_SIGNALING_STATE,  /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_AUTO_NEGO_PROCESS_STATE,                 /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_CAPA,             /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_REMOTE_FAULT,     /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_JABBER_STATE,                            /*SYS_CPNT_MAU_MIB*/
    SWDRV_GET_PORT_FALSE_CARRIER_SENSE_COUNTER,             /*SYS_CPNT_MAU_MIB*/
    SWDRV_ENABLE_UMCAST_IP_TRAP,
    SWDRV_DISABLE_UMCAST_IP_TRAP,
    SWDRV_ENABLE_UMCAST_MAC_TRAP,
    SWDRV_DISABLE_UMCAST_MAC_TRAP,
    /* Event Notification ID */
    SWDRV_HOT_SWAP_INSERT,
    SWDRV_HOT_SWAP_REMOVE,
    SWDRV_PORT_LINK_UP,   /*useless; water_huang 2005.9.28*/
    SWDRV_PORT_LINK_DOWN,   /*useless; water_huang 2005.9.28*/
    SWDRV_PORT_TYPE_CHANGED,
    SWDRV_PORT_CFG_SPEED_DUPLEX,
    SWDRV_PORT_FLOW_CONTROL,
    SWDRV_PROVISION_COMPLETE,
    SWDRV_ENABLE_OSPF_TRAP,
    SWDRV_DISABLE_OSPF_TRAP,
    SWDRV_ADD_VLAN_TO_MST,                                  /*SYS_CPNT_STP_TYPE_MSTP*/
    SWDRV_DELETE_VLAN_FROM_MST,                             /*SYS_CPNT_STP_TYPE_MSTP*/
    SWDRV_SET_PORT_STATE_WITH_MSTIDX,
    SWDRV_ADD_MY_MAC_IP_TO_CPU,
    SWDRV_REMOVE_MY_MAC_IP_TO_CPU,
    SWDRV_SET_PRIORITY_MAPPING_PER_SYSTEM,
    SWDRV_SET_GLOBAL_DEFAULT_VLAN,
    SWDRV_SET_DOT1X_AUTH_TRAP,                              /*SYS_CPNT_DOT1X*/
    SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD,
    SWDRV_SET_FORCE_1000T_PORT_CFG_MODE,                    /*SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE*/
    SWDRV_GET_COPPEER_ENERGY_DETECT,
    SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST,             /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION*/
    SWDRV_PORT_LINK_STATUS,
    SWDRV_SET_PORT_TO_VLAN_MEMBER_SET,
    SWDRV_SET_PORT_TO_VLAN_UNTAGGED_SET,
    SWDRV_GET_CABLE_DIAG,                                   /*SYS_CPNT_SWCTRL_CABLE_DIAG*/
    SWDRV_GET_CABLE_DIAG_RESULT,                            /*SYS_CPNT_SWCTRL_CABLE_DIAG*/
    SWDRV_ENABLE_MLD_PACKET_TRAP,
    SWDRV_DISABLE_MLD_PACKET_TRAP,
    SWDRV_SET_RATE_BASED_STORM_CONTROL,                     /*SYS_CPNT_RATE_BASED_STORM_CONTROL*/
    SWDRV_SET_OAM_LOOPBACK,                                 /*SYS_CPNT_EFM_OAM*/
    SWDRV_SET_INTERNAL_LOOPBACK,                            /*SYS_CPNT_INTERNAL_LOOPBACK_TEST*/
    SWDRV_SET_PORT_DOT1Q_TUNNEL_MTU,                        /*SYS_CPNT_QINQ*/
    SWDRV_SET_PORT_DOT1Q_TUNNEL_MODE,                       /*SYS_CPNT_QINQ*/
    SWDRV_SET_PORT_DOT1Q_TUNNEL_TPID,                       /*SYS_CPNT_QINQ*/
    SWDRV_GET_PORT_DOT1Q_TUNNEL_MODE,                       /*SYS_CPNT_QINQ*/
    SWDRV_GET_PORT_DOT1Q_TUNNEL_TPID,                       /*SYS_CPNT_QINQ*/
    SWDRV_SET_PORT_LIST_INFO,                               /*SYS_CPNT_REFINE_ISC_MSG*/
    SWDRV_SET_PORTMTU,
    SWDRV_SET_DOT1X_AUTH_CONTROL_MODE,                      /*SYS_CPNT_DOT1X*/
    SWDRV_SET_ATC_BROADCAST_STORM_CONTROL_THRESHOLD,        /*SYS_CPNT_ATC_BSTORM*/
    SWDRV_ENABLE_ATC_BROADCAST_STORM_CONTROL,               /*SYS_CPNT_ATC_BSTORM*/
    SWDRV_DISABLE_ATC_BROADCAST_STORM_CONTROL,              /*SYS_CPNT_ATC_BSTORM*/
    SWDRV_SET_ATC_MULTICAST_STORM_CONTROL_THRESHOLD,        /*SYS_CPNT_ATC_MSTORM*/
    SWDRV_ENABLE_ATC_MULTICAST_STORM_CONTROL,               /*SYS_CPNT_ATC_MSTORM*/
    SWDRV_DISABLE_ATC_MULTICAST_STORM_CONTROL,              /*SYS_CPNT_ATC_MSTORM*/
    SWDRV_SET_MDIX_MODE,                                    /*SYS_CPNT_SWCTRL_MDIX_CONFIG*/
    SWDRV_SET_MAC_VLAN,                                     /*SYS_CPNT_MAC_VLAN*/
    SWDRV_DELETE_MAC_VLAN,                                  /*SYS_CPNT_MAC_VLAN*/
    SWDRV_SET_PORT_POWER_SAVE,                              /*SYS_CPNT_POWER_SAVE*/
    SWDRV_SET_EAPOL_FRAME_PASS_THROUGH,                     /*SYS_CPNT_DOT1X*/
    SWDRV_SET_UNKNOWN_UNICAST_STORM_CONTROL_THRESHOLD,
    SWDRV_ENABLE_UNKNOWN_UNICAST_STORM_CONTROL,
    SWDRV_DISABLE_UNKNOWN_UNICAST_STORM_CONTROL,
    SWDRV_GET_PORT_STORM_GRANULARITY,
    SWDRV_TRAP_UNKNOWN_IPMC_TO_CPU,
    SWDRV_TRAP_UNKNOWN_IPV6MC_TO_CPU,
    SWDRV_TRAP_IPV6PIM_TO_CPU,
    SWDRV_TRAP_IPV4PIM_TO_CPU,
    SWDRV_ADD_VLAN_MIRROR,                                  /*SYS_CPNT_VLAN_MIRROR*/
    SWDRV_DELETE_VLAN_MIRROR,                               /*SYS_CPNT_VLAN_MIRROR*/
    SWDRV_SET_MAC_MIRROR_ENTRY,                             /*SYS_CPNT_MAC_BASED_MIRROR*/
    SWDRV_DELETE_MAC_MIRROR_ENTRY,                          /*SYS_CPNT_MAC_BASED_MIRROR*/
    SWDRV_SET_DEST_PORT_FOR_MAC_MIRROR,                     /*SYS_CPNT_MAC_BASED_MIRROR*/
    SWDRV_SET_PRIVATE_VLAN_PORTLIST_SID,                    /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION*/
    SWDRV_DELETE_PRIVATE_VLAN_PORTLIST_SID,                 /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION*/
    SWDRV_ENABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE, /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION*/
    SWDRV_DISABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE,/*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION*/
    SWDRV_GET_SFP_INFO,                                     /*not used*/
    SWDRV_GET_SFP_DDM_INFO,                                 /*not used*/
    SWDRV_ENABLE_PORT_SFLOW,
    SWDRV_SET_PORT_SFLOW_RATE,
    SWDRV_DROPIPMULTICASTDATA,
    SWDRV_DROPIPV6MULTICASTDATA,
    SWDRV_SET_TRUNK_BALANCE_MODE,
    SWDRV_SET_GBIC_THRESHOLDS,                              /*not used*/
    SWDRV_TRAP_DHCP_SERVER_PACKET,
    SWDRV_TRAP_DHCP_CLIENT_PACKET,
    SWDRV_SET_DOS_PROTECTION_FILTER,                        /*SYS_CPNT_DOS*/
    SWDRV_SET_RA_AND_RR_PACKET_TRAP,                        /*SYS_CPNT_IPV6_RA_GUARD_SW_RELAY*/
    SWDRV_SET_PRIVATE_VLAN_TRUNK_MODE,                      /*SYS_CPNT_PORT_TRAFFIC_SEGMENTATION SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION*/
    SWDRV_SET_DEST_PORT_FOR_ACL_MIRROR,                     /*SYS_CPNT_ACL_MIRROR*/
    SWDRV_SET_PKT_TRAP_STATUS,
    SWDRV_GET_PORT_MAX_FRAME_SIZE,
    SWDRV_SET_PSE_CHECK_STATUS,
    SWDRV_GET_PTP_TIMESTAMP,
    SWDRV_GET_PD_PORT_STATUS,
    SWDRV_SET_RSPAN_VLAN_TAG,                               /*SYS_CPNT_RSPAN*/
    SWDRV_MODIFY_MAX_FRAME_SIZE,                            /*SYS_CPNT_RSPAN*/
    SWDRV_SET_GBIC_DEFAULT_THRESHOLDS,                      /*not used*/
    SWDRV_SET_GBIC_TRAP_ENABLE,                             /*not used*/
    SWDRV_SET_PORT_LEARNING_STATUS,
    SWDRV_SET_PORT_MAC_ADDR,
    SWDRV_SET_PORT_PFC_STATUS,                              /*SYS_CPNT_PFC*/
    SWDRV_SET_PORT_COS_GROUP_MAPPING,                       /*SYS_CPNT_ETS*/
    SWDRV_SET_PORT_COS_GROUP_SCHEDULING_METHOD,             /*SYS_CPNT_ETS*/
    SWDRV_SET_QCN_CNM_PRIORITY,                             /*SYS_CPNT_CN*/
    SWDRV_SET_PORT_QCN_CPQ,                                 /*SYS_CPNT_CN*/
    SWDRV_SET_PORT_QCN_EGR_CNTAG_REMOVAL,                   /*SYS_CPNT_CN*/
    SWDRV_GET_PORT_QCN_CPID,                                /*SYS_CPNT_CN*/
    SWDRV_SET_MIM_SERVICE,                                  /*SYS_CPNT_MAC_IN_MAC*/
    SWDRV_SET_MIM_SERVICE_PORT,                             /*SYS_CPNT_MAC_IN_MAC*/
    SWDRV_SET_MIM_SERVICE_PORT_LEARNING_STATUS_FOR_STATION_MOVE,    /*SYS_CPNT_MAC_IN_MAC & SYS_CPNT_IAAS*/
    SWDRV_SET_CPU_RATE_LIMIT,
    SWDRV_GET_PORT_ABILITY,
    SWDRV_SET_GBIC_THRESHOLDS_AUTO_MODE,                    /*not used*/
    SWDRV_PORT_SFP_PRESENT_STATUS,                          /*SYS_CPNT_SWDRV_MONITOR_SFP_DDM*/
    SWDRV_PORT_SFP_INFO,                                    /*SYS_CPNT_SWDRV_MONITOR_SFP_DDM*/
    SWDRV_PORT_SFP_DDM_INFO,                                /*SYS_CPNT_SWDRV_MONITOR_SFP_DDM*/
    SWDRV_PORT_SFP_DDM_INFO_MEASURED,                       /*SYS_CPNT_SWDRV_MONITOR_SFP_DDM*/
    SWDRV_SET_VLAN_LEARNING_STATUS,                         /*SYS_CPNT_AMTR_VLAN_MAC_LEARNING*/
    SWDRV_SET_PORT_EGRESS_BLOCK,
    SWDRV_UPDATE_PFC_PRI_MAP,                               /*SYS_CPNT_PFC*/
    SWDRV_ENABLE_PORT_OPENFLOW_MODE,
    SWDRV_SET_VLAN_FLOODING_FOR_UKN_UC,
    SWDRV_SET_VLAN_FLOODING_FOR_UKN_MC,
    SWDRV_SET_VLAN_FLOODING_FOR_BC,
    SWDRV_DELETE_ALL_PORT_FROM_VLAN,
    SWDRV_STATIC_MAC_MOVE_PKT_TO_CPU,
    SWDRV_SET_VXLAN_STATUS,
    SWDRV_SET_VXLAN_STATUSPORT,
    SWDRV_SET_VXLAN_UDPPORT,
    SWDRV_SET_VXLAN_VPN,
    SWDRV_ADD_VTEP_INTO_MCASTGROUP,
    SWDRV_CREATE_VTEP,
    SWDRV_DESTROY_VTEP,
    SWDRV_SET_VXLAN_PORT_LEARNING,
    SWDRV_BIND_HASH_SEL_FOR_SERVICE,
    SWDRV_SET_SWITCHING_MODE,
    SWDRV_SET_PORT_FEC,                                     /*SYS_CPNT_SWCTRL_FEC*/
    SWDRV_GET_PORT_FEC_STATUS,                              /*SYS_CPNT_SWCTRL_FEC*/
    SWDRV_SET_RANDOM_DETECT,

    SWDRV_NBR_OF_SERVICE_ID /*Don't hard code, count on compilier*/
} SWDRV_ServicesID_T;

/*add by fen.wang,debug iscagent,and it just called in driver process,so it cannot be share memory
swdrv_isc_max_tick[0] stores the max tick,swdrv_isc_max_tick[1] store the service ID*/
static UI32_T swdrv_isc_rx_counter[SWDRV_NBR_OF_SERVICE_ID+1];
static UI32_T swdrv_isc_max_tick[2];

typedef BOOL_T (*SWDRV_ServiceFunc_t) (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

/* slave callback function */
static BOOL_T SlaveProvisionComplete(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p) ;
static BOOL_T SlaveEnablePortAdmin(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortAdmin(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortCfgSpeedDuplex(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
static BOOL_T SlaveSetPort1000BaseTForceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
static BOOL_T SlaveGetCopperEnergyDetect(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortAutoNeg(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortAutoNeg(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortAutoNegCapability(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortSTAState(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
static BOOL_T SlaveEnableMultiSTA(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableMultiSTA(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddVlanToMst(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeleteVlanFromMst(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
static BOOL_T SlaveSetPortXstpState(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortStateWithMstidx(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortType(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
static BOOL_T SlaveGetPortLoopbackTestResult(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SlaveSetPortPVID(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveCreateVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDestroyVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetGlobalDefaultVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddPortToVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeletePortFromVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddPortToVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeletePortFromVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortMaxFrameSize(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_VXLAN == TRUE)
static BOOL_T SlaveSetVxlanStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetVxlanStatusPort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetVxlanUdpPort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetVxlanVpn(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddVtepIntoMcastGroup(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveCreateVTEP(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDestroyVTEP(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetVxlanPortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SlaveEnableIngressFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p) ;
static BOOL_T SlaveDisableIngressFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAdmitVLANTaggedFramesOnly(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAdmitVLANUntaggedFramesOnly(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAdmitAllFrames(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableTrapUnspecifiedTagFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableTrapUnspecifiedTagFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddHostToVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeleteHostFromVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeletePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveCreateTrunk(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDestroyTrunk(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetTrunkPorts(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetTrunkBalanceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableIgmpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableIgmpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveTrapDhcpServerPacket(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveTrapDhcpClientPacket(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);;
static BOOL_T SlaveSetOrgSpecificTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveAddMulticastAddrToTrunkMember(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetUnknownIPMcastFwdPortlist(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetBroadcastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetMulticastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetUnknownUnicastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableUnknownUnicastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableUnknownUnicastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortStormGranularity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortUserDefaultPriority(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPriorityMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPriorityMappingPerSystem(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_ATC_BSTORM == TRUE)
static BOOL_T SlaveSetATCBroadcastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableATCBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableATCBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
static BOOL_T SlaveSetATCMulticastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableATCMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableATCMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetStackingPortPriorityMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SlaveEnableTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveResetTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetTrafficSegmatationByPortList(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static BOOL_T SlaveSetPrivateVlanPortlistBySessionId(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeletePrivateVlanPortlistBySessionId(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePrivateVlanUplinkToUplinkBlockingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePrivateVlanUplinkToUplinkBlockingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPrivateVlanTrunkMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
static BOOL_T SlaveSetPortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
static BOOL_T SlaveEnablePortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
static BOOL_T SlaveEnableJumboFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableJumboFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
static BOOL_T SlaveSetEgressSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
static BOOL_T SlaveSetPortEgressSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
static BOOL_T SlaveSetWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetStrictPriorityQueue(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
static BOOL_T SlaveSetPortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_PORT_SECURITY == TRUE)
static BOOL_T SlaveEnablePortSecurity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisablePortSecurity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlavePortSecurityActionNone(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlavePortSecurityActionTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlavePortSecurityActionShutdown(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlavePortSecurityActionTrapAndShutdown(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SWDRV_LocalSetSystemMTU(UI32_T status,UI32_T mtu);
static BOOL_T SWDRV_LocalSetPortMTU(UI32_T unit,UI32_T port,UI32_T mtu);

static BOOL_T SlaveDisablePortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnablePortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortLearningStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetVlanLearningStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);


static BOOL_T SlaveEnableIPMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableIPMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SlaveEnableUMCASTIpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableUMCASTIpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveEnableUMCASTMacTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableUMCASTMacTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SlaveSetPortRestartAutoNego                   (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortAutoNegoRemoteFaultAdvertisement  (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortAutoNegoRemoteFaultAdvertisement  (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortLinkPartnerAutoNegoSignalingState (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortAutoNegoProcessState              (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortLinkPartnerAutoNegoCapa           (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortLinkPartnerAutoNegoRemoteFault    (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortJabberState                       (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortFalseCarrierSenseCounter          (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_HWCFG_SUPPORT_PD==TRUE)
static BOOL_T SlaveGetPDPortStatus                       (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_DOT1X == TRUE)
static BOOL_T SlaveSetDot1xAuthTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetDot1xAuthControlMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetEapolFramePassThrough(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif /* SYS_CPNT_DOT1X == TRUE */

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
static BOOL_T SlaveSetPortForceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_OSPF == TRUE)
static BOOL_T Slave_EnableOSPFTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T Slave_DisableOSPFTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
static BOOL_T SlaveAddMyMACIP2Cpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveRemoveMyMACIP2Cpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SlaveSetPortToVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortToVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
static BOOL_T SlaveGetCableDiag(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
static BOOL_T SlaveGetCableDiagResult(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SlaveEnableMldPacketTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDisableMldPacketTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_RATE_BASED_STORM_CONTROL == TRUE)
static BOOL_T SlaveSetRateBasedStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    static BOOL_T SlaveSetOamLoopback(ISC_Key_T * key, SWDRV_Rx_IscBuf_T * request_p);
#endif

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
static BOOL_T SlaveSetInternalLoopback(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
static BOOL_T SlaveSetLocalPortListInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SlaveSetLocalPortMtu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
static void SlaveSetMDIXMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

/* callback master function */
static BOOL_T CallbackMasterHotSwapInsert(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterHotSwapRemove(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortLinkStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortTypeChanged(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortSpeedDuplex(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortFlowControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortSfpPresentStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortSfpInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortSfpDdmInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T CallbackMasterPortSfpDdmInfoMeasured(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
static void SWDRV_WaitForRemotePortLoopBackGot(UI32_T unit_bitmap_waiting_for);
#endif

#if (SYS_HWCFG_SUPPORT_PD==FALSE) || (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==FALSE)
#define SWDRV_OM_UpdateLocalPortAdminStatus(unit, port, is_admin_eable) ({TRUE})
#endif

/* service function table
 */
static SWDRV_ServiceFunc_t SWDRV_func_tab[SWDRV_NBR_OF_SERVICE_ID];
#endif /* SYS_CPNT_STACKING */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
static BOOL_T SWDRV_LocalSetInternaLoopback(UI32_T unit, UI32_T port, BOOL_T is_enable);
#endif
extern void vxSpawn(int tid, int type, int socket);

#if 0/*do not call this interface ,call new interface,michael.wang 20080829*/
static BOOL_T SWDRV_IsComboPort(UI32_T unit, UI32_T port);
#endif
#ifdef BACKDOOR_OPEN
static BOOL_T SWDRV_BD_IsUnitExist(UI32_T unit);
static void SWDRV_DB_EnablePortAdmin(void);
static void SWDRV_DB_DisablePortAdmin(void);
static void SWDRV_BackDoor_Port_SubMenu(void);
static void SWDRV_BackDoor_Debug_SubMenu(void);
static void SWDRV_BackDoor_Port_Mapping_Table_SubMenu(void);
static void SWDRV_BackDoor_Menu(void);
#endif /*BACKDOOR_OPEN*/

#if (SYS_CPNT_MAC_VLAN == TRUE)
static BOOL_T SlaveSetMacVlanEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeleteMacVlanEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
static BOOL_T SWDRV_SlaveSetPortPowerSave(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_RSPAN == TRUE)
static BOOL_T SlaveSetRspanVlanTag(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveModifyMaxFrameSize(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SlaveTrapUnknownIpMcastToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SlaveTrapUnknownIpv6McastToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SlaveTrapIpv6PIMToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static BOOL_T SlaveAddVlanMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeleteVlanMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
static BOOL_T SlaveSetMacMirrorEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveDeleteMacMirrorEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetDestPortForMacMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
static BOOL_T SlaveSetDestPortForAclMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_DOS == TRUE)
static BOOL_T SlaveSetDosProtectionFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SlaveSetPktTrapStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

/* End of modifications, Benson 07/04/2002 */

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
static BOOL_T SlaveSetPSECheckStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SWDRV_SlaveSetPortMacAddr(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_PFC == TRUE)
static BOOL_T SWDRV_SlaveSetPortPfcStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_SlaveUpdatePfcPriMap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_ETS == TRUE)
static BOOL_T SWDRV_SlaveSetPortCosGroupMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_SlaveSetPortCosGroupSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_CN == TRUE)
static BOOL_T SWDRV_SlaveSetQcnCnmPriority(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_SlaveSetPortQcnCpq(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_SlaveSetPortQcnEgrCnTagRemoval(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_SlaveGetPortQcnCpid(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_MAC_IN_MAC == TRUE)
static BOOL_T SlaveSetMimService(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetMimServicePort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#if (SYS_CPNT_IAAS == TRUE)
static BOOL_T SlaveSetMimServicePortLearningStatusForStationMove(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif
#endif

static BOOL_T SlaveSetCpuRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortAbility(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortEgressBlock(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

/* LOCAL VARIABLES
 */
#if (SYS_CPNT_SFLOW == TRUE)
static BOOL_T SlaveEnablePortSflow(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveSetPortSflowRate(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static void SWDRV_BackDoor_Enable_Sflow();
static void SWDRV_BackDoor_Set_Sflow_Rate();
#endif

static SYS_TYPE_CallBack_T *HotSwapInsert_callbacklist;
static SYS_TYPE_CallBack_T *HotSwapRemove_callbacklist;
static SYS_TYPE_CallBack_T *PortLinkUp_callbacklist;
static SYS_TYPE_CallBack_T *PortLinkDown_callbacklist;
static SYS_TYPE_CallBack_T *PortTypeChanged_callbacklist;
static SYS_TYPE_CallBack_T *PortSpeedDuplex_callbacklist;
static SYS_TYPE_CallBack_T *PortFlowCtrl_callbacklist;

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
typedef enum
{
    WORKAROUND_STATUS_INIT = 0,
    WORKAROUND_STATUS_AUTO,
    WORKAROUND_STATUS_FORCED
};
#endif

/* LOCAL FUNCTIONS
 */
static void SWDRV_InitFuncTab(void);
static void SWDRV_InitDataBase(void);

#if 0
static void SWDRV_MonitorTrunking(void);
#endif

static void SWDRV_Notify_PortTypeChanged(UI32_T unit, UI32_T port, UI32_T port_type);
static void SWDRV_Notify_ModuleTypeChanged(UI32_T unit, UI32_T port, UI32_T module_id, UI32_T port_type);

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
static BOOL_T SWDRV_LocalSetPort1000BaseTForceMode(UI32_T unit, UI32_T port, UI32_T mode);
#endif
static BOOL_T SWDRV_LocalGetCopperEnergyDetect(UI32_T unit, UI32_T port, UI32_T *copper_energy_detect);



static BOOL_T SWDRV_LocalEnablePortAdmin(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisablePortAdmin(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableAllPortAdmin(void);
static BOOL_T SWDRV_LocalSetPortCfgSpeedDuplex(UI32_T unit, UI32_T port,UI32_T speed_duplex);
static BOOL_T SWDRV_LocalEnablePortAutoNeg(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisablePortAutoNeg(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalEnablePortCfgFlowCtrl(UI32_T unit, UI32_T port);
static UI8_T  SWDRV_LocalDisablePortCfgFlowCtrl(UI32_T unit, UI32_T port);
static UI8_T  SWDRV_LocalSetPortCfgFlowCtrl(UI32_T unit, UI32_T port, UI32_T mode);
static BOOL_T SWDRV_LocalSetPortAutoNegCapability(UI32_T unit, UI32_T port, UI32_T capability);
static BOOL_T SWDRV_LocalSetPortSTAState(UI32_T unit, UI32_T vid, UI32_T port, UI32_T state);
static BOOL_T SWDRV_LocalGetPortType(UI32_T unit, UI32_T port, UI32_T *port_type);

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
static BOOL_T SWDRV_LocalGetPortLoopbackTestResult(UI8_T test_result[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]);
#endif

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
static BOOL_T SWDRV_LocalSetMDIXMode(UI32_T unit, UI32_T port, UI32_T mode);
#endif

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
static BOOL_T SWDRV_LocalEnableMultiSTA(void);
static BOOL_T SWDRV_LocalDisableMultiSTA(void);
static BOOL_T SWDRV_LocalAddVlanToMst(UI32_T vid, UI32_T mstidx);
static BOOL_T SWDRV_LocalDeleteVlanFromMst(UI32_T vid, UI32_T mstidx);
#endif
static BOOL_T SWDRV_LocalSetPortXstpState(UI32_T mstid,
                                          UI32_T vlan_count,
                                          UI16_T *vlan_list,
                                          UI32_T unit_id,
                                          UI32_T port,
                                          UI32_T state);
static BOOL_T SWDRV_LocalSetPortStateWithMstidx(UI32_T mstidx,
                                                UI32_T unit_id,
                                                UI32_T port,
                                                UI32_T state);
static BOOL_T SWDRV_LocalSetPortPVID(UI32_T unit_id, UI32_T port,UI32_T pvid);
static BOOL_T SWDRV_LocalCreateVlan(UI32_T vid);
static BOOL_T SWDRV_LocalDestroyVlan(UI32_T vid);
static BOOL_T SWDRV_LocalSetGlobalDefaultVlan(UI32_T vid);
static BOOL_T SWDRV_LocalAddPortToVlanMemberSet(UI32_T unit, UI32_T port, UI32_T vid);
static BOOL_T SWDRV_LocalDeletePortFromVlanMemberSet(UI32_T unit, UI32_T port,UI32_T vid);
static BOOL_T SWDRV_localAddPortToVlanUntaggedSet(UI32_T unit, UI32_T port, UI32_T vid);
static BOOL_T SWDRV_LocalDeletePortFromVlanUntaggedSet(UI32_T unit, UI32_T port,UI32_T vid);
static BOOL_T SWDRV_LocalGetPortMaxFrameSize(UI32_T unit, UI32_T port, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p);
#if (SYS_CPNT_VXLAN == TRUE)
static BOOL_T SWDRV_LocalSetVxlanStatus(BOOL_T is_enable, BOOL_T is_random_src_port);
static BOOL_T SWDRV_LocalSetVxlanStatusPort(UI32_T, UI32_T, BOOL_T, BOOL_T);
static BOOL_T SWDRV_LocalSetVxlanUdpPort(UI32_T);
static BOOL_T SWDRV_LocalSetVxlanVpn(SWDRV_VxlanVpnInfo_T *, BOOL_T);
static BOOL_T SWDRV_LocalAddVtepIntoMcastGroup(UI32_T, UI32_T, BOOL_T);
static BOOL_T SWDRV_LocalCreateVTEP(UI32_T, UI32_T, UI32_T, UI32_T,
                                   UI32_T, UI8_T [SYS_ADPT_MAC_ADDR_LEN], BOOL_T, BOOL_T,
                                   L_INET_AddrIp_T *, L_INET_AddrIp_T *, UI32_T *);
static BOOL_T SWDRV_LocalDestroyVTEP(UI32_T, UI32_T);
static BOOL_T SWDRV_LocalSetVxlanPortLearning(UI32_T vxlan_port_id, BOOL_T is_learning);
#endif

static BOOL_T SWDRV_LocalEnableIngressFilter(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableIngressFilter(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalAdmitVLANTaggedFramesOnly(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalAdmitVLANUntaggedFramesOnly(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalAdmitAllFrames(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalEnableTrapUnspecifiedTagFrame(void);
static BOOL_T SWDRV_LocalDisableTrapUnspecifiedTagFrame(void);
static BOOL_T SWDRV_LocalAddHostToVlan(UI32_T vid);
static BOOL_T SWDRV_LocalDeleteHostFromVlan(UI32_T vid);
static BOOL_T SWDRV_LocalSetPortMirroring(SYS_TYPE_Uport_T from_port,       /*? ? ?*/
                              SYS_TYPE_Uport_T rx_to_port,
                              SYS_TYPE_Uport_T tx_to_port);

static BOOL_T SWDRV_LocalDeletePortMirroring(SYS_TYPE_Uport_T from_port,SYS_TYPE_Uport_T to_port);
static BOOL_T SWDRV_LocalEnablePortMirroring(SYS_TYPE_Uport_T from_port);
static BOOL_T SWDRV_LocalDisablePortMirroring(SYS_TYPE_Uport_T from_port);

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static BOOL_T SWDRV_LocalAddVlanMirror(UI32_T unit, UI32_T port, UI32_T vid);
static BOOL_T SWDRV_LocalDeleteVlanMirror(UI32_T unit, UI32_T port, UI32_T vid);
#endif /* End of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
static BOOL_T SWDRV_LocalSetMacMirrorEntry(UI8_T *mac_address);
static BOOL_T SWDRV_LocalDeleteMacMirrorEntry(UI8_T *mac_address);
static BOOL_T SWDRV_LocalSetDestPortForMacMirror(UI32_T unit, UI32_T port, BOOL_T mode);
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
static BOOL_T SWDRV_LocalSetDestPortForAclMirror(UI32_T unit, UI32_T port, BOOL_T mode);
#endif

static BOOL_T SWDRV_LocalCreateTrunk(UI32_T trunk_id);
static BOOL_T SWDRV_LocalDestroyTrunk(UI32_T trunk_id);
static BOOL_T SWDRV_LocalSetTrunkPorts(UI32_T trunk_id,UI32_T port_count,
                                       SYS_TYPE_Uport_T *port_member);
static BOOL_T SWDRV_LocalSetTrunkBalanceMode(UI32_T mode);
static BOOL_T SWDRV_LocalEnableIgmpTrap(void);
static BOOL_T SWDRV_LocalDisableIgmpTrap(void);
static BOOL_T SWDRV_LocalTrapDhcpServerPacket(BOOL_T to_cpu, BOOL_T flood);
static BOOL_T SWDRV_LocalTrapDhcpClientPacket(BOOL_T to_cpu, BOOL_T flood);
static BOOL_T SWDRV_LocalSetOrgSpecificTrap(BOOL_T to_cpu, BOOL_T flood);
static BOOL_T SWDRV_LocalAddMulticastAddrToTrunkMember(UI8_T *mac,UI32_T vid,UI32_T trunk_id,
                                                       SYS_TYPE_Uport_T trunk_member);
static BOOL_T SWDRV_LocalSetBroadcastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode);
static BOOL_T SWDRV_LocalSetMulticastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode);
static BOOL_T SWDRV_LocalEnableBroadcastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableBroadcastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalEnableMulticastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableMulticastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalSetUnknownUnicastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode);
static BOOL_T SWDRV_LocalEnableUnknownUnicastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableUnknownUnicastStormControl(UI32_T unit, UI32_T port);
#if (SYS_CPNT_ATC_BSTORM == TRUE)
static BOOL_T SWDRV_LocalSetATCBroadcastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode);
static BOOL_T SWDRV_LocalEnableATCBroadcastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableATCBroadcastStormControl(UI32_T unit, UI32_T port);
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
static BOOL_T SWDRV_LocalSetATCMulticastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode);
static BOOL_T SWDRV_LocalEnableATCMulticastStormControl(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisableATCMulticastStormControl(UI32_T unit, UI32_T port);
#endif
static BOOL_T SWDRV_LocalGetPortStormGranularity(UI32_T unit, UI32_T port, UI32_T mode, UI32_T *storm_granularity);
static BOOL_T SWDRV_LocalSetPortUserDefaultPriority(UI32_T unit, UI32_T port, UI32_T priority);
static BOOL_T SWDRV_LocalSetPriorityMapping(UI32_T unit, UI32_T port, UI8_T mapping[8]);
static BOOL_T SWDRV_LocalSetPriorityMappingPerSystem(UI8_T mapping[8]);
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_LocalSetStackingPortPriorityMapping(UI32_T unit, UI32_T port, UI8_T mapping[8]);
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SWDRV_LocalEnableTrafficSegmatation(void);
static BOOL_T SWDRV_LocalDisableTrafficSegmatation(void);
static BOOL_T SWDRV_LocalSetTrafficSegmatation( SYS_TYPE_Uport_T    *uplink_uport_list,
                                                UI32_T              uplink_uport_list_cnt,
                                                SYS_TYPE_Uport_T    *downlink_uport_list,
                                                UI32_T              downlink_uport_list_cnt);
static BOOL_T SWDRV_LocalResetTrafficSegmatation(void);
static BOOL_T SWDRV_LocalSetTrafficSegmatationByPortlist(UI8_T *uplink_port_list,
                                                         UI8_T *downlink_port_list);
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static BOOL_T SWDRV_LocalSetPrivateVlanPortlistBySessionId(UI32_T session_id,
                                                           UI8_T  *uplink_port_list,
                                                           UI8_T  *downlink_port_list);
static BOOL_T SWDRV_LocalDeletePrivateVlanPortlistBySessionId(UI32_T session_id,
                                                           UI8_T  *uplink_port_list,
                                                           UI8_T  *downlink_port_list);
static BOOL_T SWDRV_LocalEnablePrivateVlanUplinkToUplinkBlockingMode();
static BOOL_T SWDRV_LocalDisablePrivateVlanUplinkToUplinkBlockingMode();
static BOOL_T SWDRV_LocalSetPrivateVlanTrunkMode(UI32_T session_id, UI32_T trunk_id, BOOL_T is_uplink);
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWDRV_LocalSetPortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id, UI32_T rate);
static BOOL_T SWDRV_LocalEnablePortIngressRateLimit(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisablePortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id);
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWDRV_LocalEnablePortEgressRateLimit(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisablePortEgressRateLimit(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalSetPortEgressRateLimit(UI32_T unit, UI32_T port, UI32_T rate);
#endif
#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
static BOOL_T SWDRV_LocalEnableJumboFrame(void);
static BOOL_T SWDRV_LocalDisableJumboFrame(void);
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
static BOOL_T SWDRV_LocalSetEgressSchedulingMethod(UI32_T method);
#endif
static BOOL_T SWDRV_LocalSetPortEgressSchedulingMethod(UI32_T unit, UI32_T port, UI32_T method);
static BOOL_T SWDRV_LocalEnablePortWrrQueueWeight(void);
static BOOL_T SWDRV_LocalDisablePortWrrQueueWeight(void);
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
static BOOL_T SWDRV_LocalSetWrrQueueWeight(UI32_T q_id, UI32_T weight);
static BOOL_T SWDRV_LocalSetStrictPriorityQueue(UI32_T q_id);
#endif
static BOOL_T SWDRV_LocalSetPortWrrQueueWeight(UI32_T unit, UI32_T port, UI32_T q_id, UI32_T weight);
#if (SYS_CPNT_PORT_SECURITY == TRUE)
static BOOL_T SWDRV_LocalEnablePortSecurity(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalDisablePortSecurity(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalPortSecurityActionNone(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalPortSecurityActionTrap(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalPortSecurityActionShutdown(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalPortSecurityActionTrapAndShutdown(UI32_T unit, UI32_T port);
#endif
static BOOL_T SWDRV_LocalEnableIPMC(void);
static BOOL_T SWDRV_LocalDisableIPMC(void);
static BOOL_T SWDRV_LocalEnableUMCASTIpTrap(void);
static BOOL_T SWDRV_LocalDisableUMCASTIpTrap(void);
static BOOL_T SWDRV_LocalEnableUMCASTMacTrap(void);
static BOOL_T SWDRV_LocalDisableUMCASTMacTrap(void);

#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SWDRV_LocalSetPortRestartAutoNego (UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalSetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T remote_fault);
static BOOL_T SWDRV_LocalGetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T *remote_fault);
static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoSignalingState (UI32_T unit, UI32_T port, UI32_T *state);
static BOOL_T SWDRV_LocalGetPortAutoNegoProcessState (UI32_T unit, UI32_T port, UI32_T *state);
static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoCapa (UI32_T unit, UI32_T port, UI32_T *capabilities);
static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoRemoteFault (UI32_T unit, UI32_T port, UI32_T *remote_fault);
static BOOL_T SWDRV_LocalGetPortJabberState (UI32_T unit, UI32_T port, UI32_T *state);
static BOOL_T SWDRV_LocalGetPortFalseCarrierSenseCounter (UI32_T unit, UI32_T port, UI32_T *cntr);
#endif
#if (SYS_HWCFG_SUPPORT_PD==TRUE)
static BOOL_T SWDRV_LocalGetPDPortStatus (UI32_T unit, UI32_T port, UI8_T *status_p, UI8_T *mode_p);
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
static BOOL_T SWDRV_LocalSetPortComboForcedMode(UI32_T unit, UI32_T port, UI32_T forcedmode, UI32_T fiber_speed);
#else
static BOOL_T SWDRV_LocalSetPortComboForcedMode(UI32_T unit, UI32_T port, UI32_T forcedmode);
#endif
static BOOL_T SWDRV_LocalSetPortComboForcedModeToChip(UI32_T port, BOOL_T is_user_cfg, UI32_T forcedmode, UI32_T fiber_speed);
static BOOL_T SWDRV_LocalGetSfpPortType(UI32_T port, UI32_T *port_type_p, UI32_T *mau_type_p, UI32_T *mau_type_speed_p);
static BOOL_T SWDRV_LocalGetSfpMauType(UI32_T port, UI32_T *mau_type_p, UI32_T *mau_type_speed_p);
static BOOL_T SWDRV_ConvertPortTypeToMauType(UI32_T port_type, UI32_T *mau_type_p, UI32_T *mau_type_speed_p);
static BOOL_T SWDRV_IsSfpPortTypeSupported(UI32_T unit, UI32_T port, UI32_T port_type);
#endif

static BOOL_T SWDRV_LocalSetUnknownIPMcastFwdPortList (UI8_T port_list[]);
static BOOL_T SWDRV_LocalDisablePortLearning(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalEnablePortLearning(UI32_T unit, UI32_T port);
static BOOL_T SWDRV_LocalSetPortLearningStatus(UI32_T unit, UI32_T port, BOOL_T learning, BOOL_T to_cpu, BOOL_T drop);
static BOOL_T SWDRV_LocalSetVlanLearningStatus(UI32_T vid, BOOL_T learning);

#if (SYS_CPNT_OSPF == TRUE)
static BOOL_T SWDRV_LocalEnableOSPFTrap(UI8_T *cpu_mac);
static BOOL_T SWDRV_LocalDisableOSPFTrap(UI8_T *cpu_mac);
#endif

#if (SYS_CPNT_DOT1X == TRUE)
static BOOL_T SWDRV_LocalSetDot1xAuthTrap(UI32_T unit, UI32_T port, UI32_T mode);
static BOOL_T SWDRV_LocalSetDot1xAuthControlMode(UI32_T unit, UI32_T port, UI32_T mode);
#endif /* SYS_CPNT_DOT1X == TRUE */
#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
static BOOL_T SWDRV_LocalSetEapolFramePassThrough(BOOL_T state);
#endif /* #if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE) */



static BOOL_T SWDRV_LocalSetPortToVlanMemberSet(UI32_T unit_id, UI32_T vid, UI8_T *port_list);
static BOOL_T SWDRV_LocalSetPortToVlanUntaggedSet(UI32_T unit_id, UI32_T vid, UI8_T *port_list);

static UI16_T SWDRV_GetValidDrvUnitBmp(void);
static UI16_T SWDRV_GetValidUnitBmp(void);
static UI16_T SWDRV_GetValidDrvUnitBmpByUnitPort(UI32_T unit, UI32_T port, UI16_T *unit_bmp);

static BOOL_T SWDRV_CheckPortIsExist(UI32_T port);
#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
static BOOL_T SWDRV_LocalGetCableDiag(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_info);
#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
static BOOL_T SWDRV_LocalGetCableDiagResult(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_info);
#endif
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    static BOOL_T SWDRV_LocalSetOamLoopback(UI32_T unit, UI32_T port, BOOL_T is_enable, UI32_T type);
#endif
static void SWDRV_BD_IncRxCounter(UI16_T type);
static BOOL_T SWDRV_CheckModulePortExist(UI32_T maxport, UI8_T *port_list,UI16_T maxlist);


#if (SYS_CPNT_MAC_VLAN == TRUE)
static BOOL_T SWDRV_LocalSetMacVlanEntry(UI8_T *mac_address, UI8_T *mask, UI16_T vid, UI8_T priority);
static BOOL_T SWDRV_LocalDeleteMacVlanEntry(UI8_T *mac_address, UI8_T *mask);
#endif

static BOOL_T SWDRV_LocalTrapUnknownIpMcastToCPU(UI8_T to_cpu, BOOL_T flood, UI32_T vid);
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SWDRV_LocalTrapUnknownIpv6McastToCPU(UI8_T to_cpu, BOOL_T flood, UI32_T vid);
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SWDRV_LocalTrapIpv6PIMToCPU(BOOL_T to_cpu);
#endif

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
static BOOL_T SWDRV_SlaveDropIpv6MulticastData(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_LocalDropIpv6MulticastData(UI32_T unit, UI32_T port, BOOL_T enabled);
#endif

#if (SYS_CPNT_DOS == TRUE)
static BOOL_T SWDRV_LocalSetDosProtectionFilter(UI32_T type, BOOL_T arg);
#endif

static BOOL_T SWDRV_LocalSetPktTrapStatus(UI32_T port, UI32_T pkt_type, BOOL_T to_cpu, BOOL_T drop);

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
static BOOL_T SWDRV_LocalSetPSECheckStatus(BOOL_T pse_check_status);
#endif

#if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE)
static BOOL_T SlaveSetRaAndRrPacketTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

static BOOL_T SWDRV_LocalSetPortMacAddr(UI32_T unit, UI32_T port, UI8_T *mac_addr);

#if (SYS_CPNT_PFC == TRUE)
static BOOL_T SWDRV_LocalSetPortPfcStatus(UI32_T unit, UI32_T port, BOOL_T rx_en, BOOL_T tx_en, UI16_T pri_en_vec);
static BOOL_T SWDRV_LocalUpdatePfcPriMap(void);
#endif

#if (SYS_CPNT_ETS == TRUE)
static BOOL_T SWDRV_LocalSetPortCosGroupMapping(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq2group[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE]);
static BOOL_T SWDRV_LocalSetPortCosGroupSchedulingMethod(
    UI32_T unit,
    UI32_T port,
    UI32_T method,
    UI32_T weights[SYS_ADPT_ETS_MAX_NBR_OF_TRAFFIC_CLASS]);
#endif

#if (SYS_CPNT_CN == TRUE)
static BOOL_T SWDRV_LocalSetQcnCnmPriority(UI32_T pri);

static BOOL_T SWDRV_LocalSetPortQcnCpq(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI32_T cpq);

static BOOL_T SWDRV_LocalSetPortQcnEgrCnTagRemoval(
    UI32_T unit,
    UI32_T port,
    UI8_T no_cntag_bitmap);

static BOOL_T SWDRV_LocalGetPortQcnCpid(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI8_T cpid[8]);
#endif

#if (SYS_CPNT_MAC_IN_MAC == TRUE)
static BOOL_T SWDRV_LocalSetMimService(SWDRV_MimServiceInfo_T *mim_p, BOOL_T is_valid);
static BOOL_T SWDRV_LocalSetMimServicePort(SWDRV_MimPortInfo_T *mim_port_p, BOOL_T is_valid);
#if (SYS_CPNT_IAAS == TRUE)
static BOOL_T SWDRV_LocalSetMimServicePortLearningStatusForStationMove(BOOL_T learning, BOOL_T to_cpu, BOOL_T drop);
#endif
#endif

static BOOL_T SWDRV_LocalSetCpuRateLimit(UI32_T pkt_type, UI32_T rate);
static BOOL_T SWDRV_LocalGetPortAbility(UI32_T unit, UI32_T port, SWDRV_PortAbility_T *ability_p);
static void   SWDRV_Notify_LocalPortSfpPresent(void);
static BOOL_T SWDRV_LocalSetPortEgressBlock(
    UI32_T unit,
    UI32_T port,
    UI8_T egr_blk_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST]);

static BOOL_T SWDRV_LocalEnablePortOpenFlowMode(UI32_T unit, UI32_T port);
static BOOL_T SlaveEnablePortOpenFlowMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SWDRV_LocalSetVlanFloodingForUknUC(UI32_T vid, BOOL_T flood);
static BOOL_T SlaveSetVlanFloodingForUknUC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SWDRV_LocalSetVlanFloodingForUknMC(UI32_T vid, BOOL_T flood);
static BOOL_T SlaveSetVlanFloodingForUknMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SWDRV_LocalSetVlanFloodingForBC(UI32_T vid, BOOL_T flood);
static BOOL_T SlaveSetVlanFloodingForBC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

static BOOL_T SWDRV_LocalDeleteAllPortFromVlan(UI32_T vid);
static BOOL_T SlaveDeleteAllPortFromVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);


static BOOL_T SWDRV_LocalStaticMacMovePktToCpu(UI32_T is_enable);
static BOOL_T SlaveStaticMacMovePktToCpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);

#if (SYS_CPNT_HASH_SELECTION == TRUE)
static BOOL_T SlaveBindHashSelForService(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SWDRV_LocalBindHashSelForService(SWDRV_HashSelService_T service, SWDRV_HashSelBlockInfo_T *block_info_p);
#endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
static BOOL_T SlaveSetSwitchingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
static BOOL_T SlaveSetPortFec(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
static BOOL_T SlaveGetPortFecStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

#if(SYS_CPNT_WRED == TRUE)
static BOOL_T SWDRV_SlaveRandomDetect(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p);
#endif

/*  declare stacking variables  */




/* EXPORTED SUBPROGRAM SPECIFICATIONS
 */
/****************************************************************************/
/* Switch Initialization                                                    */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Init
 * -------------------------------------------------------------------------
 * FUNCTION: This function allocates and initiates the system resource for
 *           Switch Control module
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Init(void)
{
    SWDRV_OM_Init();
    SWDRV_OM_SetChipTaskStatus(FALSE);
    SWDRV_OM_SetTrunkMode(DEV_SWDRV_TRUNK_MAC_SA_DA);
    SWDRV_OM_SetUnitBitMap(0);

#if (SYS_CPNT_STACKING == TRUE)

    SWDRV_InitFuncTab();

#endif  /*SYS_CPNT_STACKING*/
     memset(swdrv_isc_rx_counter,0,sizeof(swdrv_isc_rx_counter));
     memset(swdrv_isc_max_tick,0,sizeof(swdrv_isc_max_tick));
#if 0
#if defined(XGS_SWITCH)
    DEV_SWDRV_PMGR_Init();  /* initialize here? what table ? */
#endif
#endif

    return;
} /* End of SWDRV_Init() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Create_InterCSC_Relation
 * -------------------------------------------------------------------------
 * FUNCTION: This function initializes all function pointer registration operations.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Create_InterCSC_Relation(void)
{
#ifdef  BACKDOOR_OPEN
    BACKDOOR_MGR_Register_SubsysBackdoorFunc_CallBack("swdrv", SYS_BLD_DRIVER_GROUP_IPCMSGQ_KEY, SWDRV_BackDoor_Menu);
#endif  /* BACKDOOR_OPEN */
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_InitFuncTab
 * -------------------------------------------------------------------------
 * FUNCTION: This API is used to init the table that used to service the ISC
 *           callback.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWDRV_InitFuncTab(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    memset(SWDRV_func_tab, 0, sizeof(SWDRV_func_tab));
    SWDRV_func_tab[SWDRV_ENABLE_PORT_ADMIN]                 = SlaveEnablePortAdmin;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_ADMIN]                = SlaveDisablePortAdmin;
    SWDRV_func_tab[SWDRV_SET_PORT_CFG_SPEED_DUPLEX]         = SlaveSetPortCfgSpeedDuplex;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_AUTONEG]               = SlaveEnablePortAutoNeg;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_AUTONEG]              = SlaveDisablePortAutoNeg;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_CFG_FLOWCTRL]          = SlaveEnablePortCfgFlowCtrl;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_CFG_FLOWCTRL]         = SlaveDisablePortCfgFlowCtrl;
    SWDRV_func_tab[SWDRV_SET_PORT_CFG_FLOWCTRL]             = SlaveSetPortCfgFlowCtrl;
    SWDRV_func_tab[SWDRV_SET_PORT_AUTONEG_CAPABILITY]       = SlaveSetPortAutoNegCapability;
    SWDRV_func_tab[SWDRV_SET_PORT_STA_STATE]                = SlaveSetPortSTAState;

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    SWDRV_func_tab[SWDRV_ENABLE_MULTI_STA]                  = SlaveEnableMultiSTA;
    SWDRV_func_tab[SWDRV_DISABLE_MULTI_STA]                 = SlaveDisableMultiSTA;
#endif

    SWDRV_func_tab[SWDRV_SET_PORT_XSTP_STATE]               = SlaveSetPortXstpState;
    SWDRV_func_tab[SWDRV_GET_PORT_TYPE]                     = SlaveGetPortType;

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    SWDRV_func_tab[SWDRV_GET_PORT_LOOPBACK_TEST_RESULT]     = SlaveGetPortLoopbackTestResult;
#endif

    SWDRV_func_tab[SWDRV_SET_PORT_PVID]                         = SlaveSetPortPVID;
    SWDRV_func_tab[SWDRV_CREATE_VLAN]                           = SlaveCreateVlan;
    SWDRV_func_tab[SWDRV_DESTROY_VLAN]                          = SlaveDestroyVlan;
    SWDRV_func_tab[SWDRV_SET_GLOBAL_DEFAULT_VLAN]               = SlaveSetGlobalDefaultVlan;
    SWDRV_func_tab[SWDRV_ADD_PORT_TO_VLAN_MEMBER_SET]           = SlaveAddPortToVlanMemberSet;
    SWDRV_func_tab[SWDRV_DELETE_PORT_FROM_VLAN_MEMBER_SET]      = SlaveDeletePortFromVlanMemberSet;
    SWDRV_func_tab[SWDRV_ADD_PORT_TO_VLAN_UNTAGGED_SET]         = SlaveAddPortToVlanUntaggedSet;
    SWDRV_func_tab[SWDRV_DELETE_PORT_FROM_VLAN_UNTAGGED_SET]    = SlaveDeletePortFromVlanUntaggedSet;
    SWDRV_func_tab[SWDRV_ENABLE_INGRESS_FILTER]                 = SlaveEnableIngressFilter;
    SWDRV_func_tab[SWDRV_DISABLE_INGRESS_FILTER]                = SlaveDisableIngressFilter;
    SWDRV_func_tab[SWDRV_ADMIT_VLAN_TAGGED_FRAMES_ONLY]         = SlaveAdmitVLANTaggedFramesOnly;
    SWDRV_func_tab[SWDRV_ADMIT_VLAN_UNTAGGED_FRAMES_ONLY]       = SlaveAdmitVLANUntaggedFramesOnly;
    SWDRV_func_tab[SWDRV_ADMIT_ALL_FRAMES]                      = SlaveAdmitAllFrames;
    SWDRV_func_tab[SWDRV_ENABLE_TRAP_UNSPECIFIED_TAG_FRAME]    = SlaveEnableTrapUnspecifiedTagFrame;
    SWDRV_func_tab[SWDRV_DISABLE_TRAP_UNSPECIFIED_TAG_FRAME]   = SlaveDisableTrapUnspecifiedTagFrame;
    SWDRV_func_tab[SWDRV_ADD_HOST_TO_VLAN]                      = SlaveAddHostToVlan;
    SWDRV_func_tab[SWDRV_DELETE_HOST_FROM_VLAN]                 = SlaveDeleteHostFromVlan;
    SWDRV_func_tab[SWDRV_SET_PORT_MIRRORING]                    = SlaveSetPortMirroring;
    SWDRV_func_tab[SWDRV_DELETE_PORT_MIRRORING]                 = SlaveDeletePortMirroring;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_MIRRORING]                 = SlaveEnablePortMirroring;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_MIRRORING]                = SlaveDisablePortMirroring;
    SWDRV_func_tab[SWDRV_CREATE_TRUNK]                          = SlaveCreateTrunk;
    SWDRV_func_tab[SWDRV_DESTROY_TRUNK]                         = SlaveDestroyTrunk;
    SWDRV_func_tab[SWDRV_SET_TRUNK_PORTS]                       = SlaveSetTrunkPorts;
    SWDRV_func_tab[SWDRV_ENABLE_IGMP_TRAP]                      = SlaveEnableIgmpTrap;
    SWDRV_func_tab[SWDRV_DISABLE_IGMP_TRAP]                     = SlaveDisableIgmpTrap;
    SWDRV_func_tab[SWDRV_ADD_MULTICAST_ADDR_TO_TRUNK_MEMBER]    = SlaveAddMulticastAddrToTrunkMember;
    SWDRV_func_tab[SWDRV_SET_UNKNOWN_IP_MCAST_FWD_PORTLIST]     = SlaveSetUnknownIPMcastFwdPortlist;
    SWDRV_func_tab[SWDRV_SET_BROADCAST_STORM_CONTROL_THRESHOLD] = SlaveSetBroadcastStormControlThreshold;
    SWDRV_func_tab[SWDRV_ENABLE_BROADCAST_STORM_CONTROL]        = SlaveEnableBroadcastStormControl;
    SWDRV_func_tab[SWDRV_DISABLE_BROADCAST_STORM_CONTROL]       = SlaveDisableBroadcastStormControl;
    SWDRV_func_tab[SWDRV_ENABLE_MULTICAST_STORM_CONTROL]        = SlaveEnableMulticastStormControl;
    SWDRV_func_tab[SWDRV_DISABLE_MULTICAST_STORM_CONTROL]       = SlaveDisableMulticastStormControl;
    SWDRV_func_tab[SWDRV_SET_PORT_USER_DEFAULT_PRIORITY]        = SlaveSetPortUserDefaultPriority;
    SWDRV_func_tab[SWDRV_SET_PRIORITY_MAPPING]                  = SlaveSetPriorityMapping;

#if (SYS_CPNT_STACKING == TRUE)
    SWDRV_func_tab[SWDRV_SET_STACKING_PORT_PRIORITY_MAPPING]    = SlaveSetStackingPortPriorityMapping;
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_TRAFFIC_SEGMATATION]            = SlaveEnableTrafficSegmatation;
    SWDRV_func_tab[SWDRV_DISABLE_TRAFFIC_SEGMATATION]           = SlaveDisableTrafficSegmatation;
    SWDRV_func_tab[SWDRV_SET_TRAFFIC_SEGMATATION]               = SlaveSetTrafficSegmatation;
    SWDRV_func_tab[SWDRV_RESET_TRAFFIC_SEGMATATION]             = SlaveResetTrafficSegmatation;
    SWDRV_func_tab[SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST]  = SlaveSetTrafficSegmatationByPortList;
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    SWDRV_func_tab[SWDRV_SET_PRIVATE_VLAN_PORTLIST_SID]         = SlaveSetPrivateVlanPortlistBySessionId;
    SWDRV_func_tab[SWDRV_DELETE_PRIVATE_VLAN_PORTLIST_SID]      = SlaveDeletePrivateVlanPortlistBySessionId;
    SWDRV_func_tab[SWDRV_ENABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE]  = SlaveEnablePrivateVlanUplinkToUplinkBlockingMode;
    SWDRV_func_tab[SWDRV_DISABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE] = SlaveDisablePrivateVlanUplinkToUplinkBlockingMode;
    SWDRV_func_tab[SWDRV_SET_PRIVATE_VLAN_TRUNK_MODE]           = SlaveSetPrivateVlanTrunkMode;
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_INGRESS_RATE_LIMIT]           = SlaveSetPortIngressRateLimit;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_INGRESS_RATE_LIMIT]        = SlaveEnablePortIngressRateLimit;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_INGRESS_RATE_LIMIT]       = SlaveDisablePortIngressRateLimit;
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_PORT_EGRESS_RATE_LIMIT]         = SlaveEnablePortEgressRateLimit;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_EGRESS_RATE_LIMIT]        = SlaveDisablePortEgressRateLimit;
    SWDRV_func_tab[SWDRV_SET_PORT_EGRESS_RATE_LIMIT]            = SlaveSetPortEgressRateLimit;
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_JUMBO_FRAME]                    = SlaveEnableJumboFrame;
    SWDRV_func_tab[SWDRV_DISABLE_JUMBO_FRAME]                   = SlaveDisableJumboFrame;
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_FORCED_MODE]                  = SlaveSetPortForceMode;
#endif

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
    SWDRV_func_tab[SWDRV_SET_EGRESS_SCHEDULING_METHOD]          = SlaveSetEgressSchedulingMethod;
#endif
    SWDRV_func_tab[SWDRV_SET_PORT_EGRESS_SCHEDULING_METHOD]     = SlaveSetPortEgressSchedulingMethod;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_WRR_QUEUE_WEIGHT]          = SlaveEnablePortWrrQueueWeight;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_WRR_QUEUE_WEIGHT]         = SlaveDisablePortWrrQueueWeight;
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
    SWDRV_func_tab[SWDRV_SET_WRR_QUEUE_WEIGHT]                  = SlaveSetWrrQueueWeight;
    SWDRV_func_tab[SWDRV_SET_STRICT_PRIORITY_QUEUE]             = SlaveSetStrictPriorityQueue;
#endif
    SWDRV_func_tab[SWDRV_SET_PORT_WRR_QUEUE_WEIGHT]             = SlaveSetPortWrrQueueWeight;

#if (SYS_CPNT_PORT_SECURITY == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_PORT_SECURITY]                  = SlaveEnablePortSecurity;
    SWDRV_func_tab[SWDRV_DISABLE_PORT_SECURITY]                 = SlaveDisablePortSecurity;
    SWDRV_func_tab[SWDRV_PORT_SECURITY_ACTION_NONE]             = SlavePortSecurityActionNone;
    SWDRV_func_tab[SWDRV_PORT_SECURITY_ACTION_TRAP]             = SlavePortSecurityActionTrap;
    SWDRV_func_tab[SWDRV_PORT_SECURITY_ACTION_SHUTDOWN]         = SlavePortSecurityActionShutdown;
    SWDRV_func_tab[SWDRV_PORT_SECURITY_ACTION_TRAP_AND_SHUTDOWN]=SlavePortSecurityActionTrapAndShutdown;
#endif

    SWDRV_func_tab[SWDRV_PORT_DISABLE_LEARNING]                 = SlaveDisablePortLearning;
    SWDRV_func_tab[SWDRV_PORT_ENABLE_LEARNING]                  = SlaveEnablePortLearning;
    SWDRV_func_tab[SWDRV_SET_PORT_LEARNING_STATUS]              = SlaveSetPortLearningStatus;
#if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE)
    SWDRV_func_tab[SWDRV_SET_VLAN_LEARNING_STATUS]              = SlaveSetVlanLearningStatus;
#endif
    SWDRV_func_tab[SWDRV_ENABLE_IPMC]                           = SlaveEnableIPMC;
    SWDRV_func_tab[SWDRV_DISABLE_IPMC]                          = SlaveDisableIPMC;

#if (SYS_CPNT_MAU_MIB == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_RESTART_AUTO_NEGO]                        = SlaveSetPortRestartAutoNego;
    SWDRV_func_tab[SWDRV_SET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT]     = SlaveSetPortAutoNegoRemoteFaultAdvertisement;
    SWDRV_func_tab[SWDRV_GET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT]     = SlaveGetPortAutoNegoRemoteFaultAdvertisement;
    SWDRV_func_tab[SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_SIGNALING_STATE]   = SlaveGetPortLinkPartnerAutoNegoSignalingState;
    SWDRV_func_tab[SWDRV_GET_PORT_AUTO_NEGO_PROCESS_STATE]                  = SlaveGetPortAutoNegoProcessState;
    SWDRV_func_tab[SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_CAPA]              = SlaveGetPortLinkPartnerAutoNegoCapa;
    SWDRV_func_tab[SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_REMOTE_FAULT]      = SlaveGetPortLinkPartnerAutoNegoRemoteFault;
    SWDRV_func_tab[SWDRV_GET_PORT_JABBER_STATE]                             = SlaveGetPortJabberState;
    SWDRV_func_tab[SWDRV_GET_PORT_FALSE_CARRIER_SENSE_COUNTER]              = SlaveGetPortFalseCarrierSenseCounter;
#endif
#if (SYS_HWCFG_SUPPORT_PD==TRUE)
    SWDRV_func_tab[SWDRV_GET_PD_PORT_STATUS]                       = SlaveGetPDPortStatus;
#endif
    SWDRV_func_tab[SWDRV_ENABLE_UMCAST_IP_TRAP]                 = SlaveEnableUMCASTIpTrap;
    SWDRV_func_tab[SWDRV_DISABLE_UMCAST_IP_TRAP]                = SlaveDisableUMCASTIpTrap;
    SWDRV_func_tab[SWDRV_ENABLE_UMCAST_MAC_TRAP]                = SlaveEnableUMCASTMacTrap;
    SWDRV_func_tab[SWDRV_DISABLE_UMCAST_MAC_TRAP]               = SlaveDisableUMCASTMacTrap;
    SWDRV_func_tab[SWDRV_HOT_SWAP_INSERT]                       = CallbackMasterHotSwapInsert;
    SWDRV_func_tab[SWDRV_HOT_SWAP_REMOVE]                       = CallbackMasterHotSwapRemove;
    SWDRV_func_tab[SWDRV_PORT_TYPE_CHANGED]                     = CallbackMasterPortTypeChanged;
    SWDRV_func_tab[SWDRV_PORT_CFG_SPEED_DUPLEX]                 = CallbackMasterPortSpeedDuplex;
    SWDRV_func_tab[SWDRV_PORT_FLOW_CONTROL]                     = CallbackMasterPortFlowControl;
    SWDRV_func_tab[SWDRV_PROVISION_COMPLETE]                    = SlaveProvisionComplete;

#if (SYS_CPNT_OSPF == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_OSPF_TRAP]                      = Slave_EnableOSPFTrap;
    SWDRV_func_tab[SWDRV_DISABLE_OSPF_TRAP]                     = Slave_DisableOSPFTrap;
#endif
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    SWDRV_func_tab[SWDRV_ADD_VLAN_TO_MST]                       = SlaveAddVlanToMst;
    SWDRV_func_tab[SWDRV_DELETE_VLAN_FROM_MST]                  = SlaveDeleteVlanFromMst;
#endif
    SWDRV_func_tab[SWDRV_SET_PORT_STATE_WITH_MSTIDX]            = SlaveSetPortStateWithMstidx;

    SWDRV_func_tab[SWDRV_ADD_MY_MAC_IP_TO_CPU]                  = SlaveAddMyMACIP2Cpu;
    SWDRV_func_tab[SWDRV_REMOVE_MY_MAC_IP_TO_CPU]               = SlaveRemoveMyMACIP2Cpu;
    SWDRV_func_tab[SWDRV_SET_PRIORITY_MAPPING_PER_SYSTEM]       = SlaveSetPriorityMappingPerSystem;

#if (SYS_CPNT_DOT1X == TRUE)
    SWDRV_func_tab[SWDRV_SET_DOT1X_AUTH_TRAP]                   = SlaveSetDot1xAuthTrap;
    SWDRV_func_tab[SWDRV_SET_DOT1X_AUTH_CONTROL_MODE]           = SlaveSetDot1xAuthControlMode;
    SWDRV_func_tab[SWDRV_SET_EAPOL_FRAME_PASS_THROUGH]          = SlaveSetEapolFramePassThrough;
#endif

    SWDRV_func_tab[SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD] = SlaveSetMulticastStormControlThreshold;

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
    SWDRV_func_tab[SWDRV_SET_FORCE_1000T_PORT_CFG_MODE]         = SlaveSetPort1000BaseTForceMode;
#endif
    SWDRV_func_tab[SWDRV_GET_COPPEER_ENERGY_DETECT]             = SlaveGetCopperEnergyDetect;
    SWDRV_func_tab[SWDRV_PORT_LINK_STATUS]                      = CallbackMasterPortLinkStatus;

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    SWDRV_func_tab[SWDRV_PORT_SFP_PRESENT_STATUS]               = CallbackMasterPortSfpPresentStatus;
    SWDRV_func_tab[SWDRV_PORT_SFP_INFO]                         = CallbackMasterPortSfpInfo;
    SWDRV_func_tab[SWDRV_PORT_SFP_DDM_INFO]                     = CallbackMasterPortSfpDdmInfo;
    SWDRV_func_tab[SWDRV_PORT_SFP_DDM_INFO_MEASURED]            = CallbackMasterPortSfpDdmInfoMeasured;
#endif

    SWDRV_func_tab[SWDRV_SET_PORT_TO_VLAN_MEMBER_SET]           = SlaveSetPortToVlanMemberSet;
    SWDRV_func_tab[SWDRV_SET_PORT_TO_VLAN_UNTAGGED_SET]         = SlaveSetPortToVlanUntaggedSet;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
    SWDRV_func_tab[SWDRV_GET_CABLE_DIAG]                        = SlaveGetCableDiag;
#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
    SWDRV_func_tab[SWDRV_GET_CABLE_DIAG_RESULT]                 = SlaveGetCableDiagResult;
#endif
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_MLD_PACKET_TRAP]                = SlaveEnableMldPacketTrap;
    SWDRV_func_tab[SWDRV_DISABLE_MLD_PACKET_TRAP]               = SlaveDisableMldPacketTrap;
#endif
#if (SWDRV_DISABLE_MLD_PACKET_TRAP == TRUE)
    SWDRV_func_tab[SWDRV_RATE_BASED_STORM_CONTROL]              = SlaveSetRateBasedStormControl;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    SWDRV_func_tab[SWDRV_SET_OAM_LOOPBACK]                      = SlaveSetOamLoopback;
#endif

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
    SWDRV_func_tab[SWDRV_SET_INTERNAL_LOOPBACK]                 = SlaveSetInternalLoopback;
#endif

    SWDRV_func_tab[SWDRV_GET_PORT_MAX_FRAME_SIZE]               = SlaveGetPortMaxFrameSize;

#if (SYS_CPNT_VXLAN == TRUE)
    SWDRV_func_tab[SWDRV_SET_VXLAN_STATUS]                      = SlaveSetVxlanStatus;
    SWDRV_func_tab[SWDRV_SET_VXLAN_STATUSPORT]                  = SlaveSetVxlanStatusPort;
    SWDRV_func_tab[SWDRV_SET_VXLAN_UDPPORT]                     = SlaveSetVxlanUdpPort;
    SWDRV_func_tab[SWDRV_SET_VXLAN_VPN]                         = SlaveSetVxlanVpn;
    SWDRV_func_tab[SWDRV_ADD_VTEP_INTO_MCASTGROUP]              = SlaveAddVtepIntoMcastGroup;
    SWDRV_func_tab[SWDRV_CREATE_VTEP]                           = SlaveCreateVTEP;
    SWDRV_func_tab[SWDRV_DESTROY_VTEP]                          = SlaveDestroyVTEP;
    SWDRV_func_tab[SWDRV_SET_VXLAN_PORT_LEARNING]               = SlaveSetVxlanPortLearning;
#endif

#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_LIST_INFO]                     = SlaveSetLocalPortListInfo;
#endif
    SWDRV_func_tab[SWDRV_SET_PORTMTU]                            = SlaveSetLocalPortMtu;
#if (SYS_CPNT_ATC_BSTORM == TRUE)
    SWDRV_func_tab[SWDRV_SET_ATC_BROADCAST_STORM_CONTROL_THRESHOLD] = SlaveSetATCBroadcastStormControlThreshold;
    SWDRV_func_tab[SWDRV_ENABLE_ATC_BROADCAST_STORM_CONTROL]        = SlaveEnableATCBroadcastStormControl;
    SWDRV_func_tab[SWDRV_DISABLE_ATC_BROADCAST_STORM_CONTROL]       = SlaveDisableATCBroadcastStormControl;
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    SWDRV_func_tab[SWDRV_SET_ATC_MULTICAST_STORM_CONTROL_THRESHOLD] = SlaveSetATCMulticastStormControlThreshold;
    SWDRV_func_tab[SWDRV_ENABLE_ATC_MULTICAST_STORM_CONTROL]        = SlaveEnableATCMulticastStormControl;
    SWDRV_func_tab[SWDRV_DISABLE_ATC_MULTICAST_STORM_CONTROL]       = SlaveDisableATCMulticastStormControl;
#endif
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
    SWDRV_func_tab[SWDRV_SET_MDIX_MODE]                               = SlaveSetMDIXMode;
#endif
#if (SYS_CPNT_MAC_VLAN == TRUE)
    SWDRV_func_tab[SWDRV_SET_MAC_VLAN] = SlaveSetMacVlanEntry;
    SWDRV_func_tab[SWDRV_DELETE_MAC_VLAN] = SlaveDeleteMacVlanEntry;
#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_POWER_SAVE] = SWDRV_SlaveSetPortPowerSave;
#endif

#if (SYS_CPNT_RSPAN == TRUE)
    SWDRV_func_tab[SWDRV_SET_RSPAN_VLAN_TAG] = SlaveSetRspanVlanTag;
    SWDRV_func_tab[SWDRV_MODIFY_MAX_FRAME_SIZE] = SlaveModifyMaxFrameSize;
#endif

    SWDRV_func_tab[SWDRV_SET_UNKNOWN_UNICAST_STORM_CONTROL_THRESHOLD] = SlaveSetUnknownUnicastStormControlThreshold;
    SWDRV_func_tab[SWDRV_ENABLE_UNKNOWN_UNICAST_STORM_CONTROL]        = SlaveEnableUnknownUnicastStormControl;
    SWDRV_func_tab[SWDRV_DISABLE_UNKNOWN_UNICAST_STORM_CONTROL]       = SlaveDisableUnknownUnicastStormControl;

    SWDRV_func_tab[SWDRV_GET_PORT_STORM_GRANULARITY]            = SlaveGetPortStormGranularity;

    SWDRV_func_tab[SWDRV_TRAP_UNKNOWN_IPMC_TO_CPU] = SlaveTrapUnknownIpMcastToCPU;
#if (SYS_CPNT_MLDSNP == TRUE)
    SWDRV_func_tab[SWDRV_TRAP_UNKNOWN_IPV6MC_TO_CPU] = SlaveTrapUnknownIpv6McastToCPU;
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
    SWDRV_func_tab[SWDRV_TRAP_IPV6PIM_TO_CPU] = SlaveTrapIpv6PIMToCPU;
#endif

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
    SWDRV_func_tab[SWDRV_ADD_VLAN_MIRROR] = SlaveAddVlanMirror;
    SWDRV_func_tab[SWDRV_DELETE_VLAN_MIRROR] = SlaveDeleteVlanMirror;
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
    SWDRV_func_tab[SWDRV_SET_MAC_MIRROR_ENTRY] = SlaveSetMacMirrorEntry;
    SWDRV_func_tab[SWDRV_DELETE_MAC_MIRROR_ENTRY] = SlaveDeleteMacMirrorEntry;
    SWDRV_func_tab[SWDRV_SET_DEST_PORT_FOR_MAC_MIRROR] = SlaveSetDestPortForMacMirror;
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
    SWDRV_func_tab[SWDRV_SET_DEST_PORT_FOR_ACL_MIRROR] = SlaveSetDestPortForAclMirror;
#endif

#if (SYS_CPNT_SFLOW == TRUE)
    SWDRV_func_tab[SWDRV_ENABLE_PORT_SFLOW]       = SlaveEnablePortSflow;
    SWDRV_func_tab[SWDRV_SET_PORT_SFLOW_RATE]       = SlaveSetPortSflowRate;
#endif

    SWDRV_func_tab[SWDRV_SET_TRUNK_BALANCE_MODE] = SlaveSetTrunkBalanceMode;

    SWDRV_func_tab[SWDRV_TRAP_DHCP_SERVER_PACKET] = SlaveTrapDhcpServerPacket;
    SWDRV_func_tab[SWDRV_TRAP_DHCP_CLIENT_PACKET] = SlaveTrapDhcpClientPacket;

#if (SYS_CPNT_DOS == TRUE)
    SWDRV_func_tab[SWDRV_SET_DOS_PROTECTION_FILTER] = SlaveSetDosProtectionFilter;
#endif

    SWDRV_func_tab[SWDRV_SET_ORG_SPECIFIC_TRAP] = SlaveSetOrgSpecificTrap;
    SWDRV_func_tab[SWDRV_SET_PKT_TRAP_STATUS] = SlaveSetPktTrapStatus;

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
    SWDRV_func_tab[SWDRV_SET_PSE_CHECK_STATUS] = SlaveSetPSECheckStatus;
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
    SWDRV_func_tab[SWDRV_DROPIPV6MULTICASTDATA] = SWDRV_SlaveDropIpv6MulticastData;
#endif
#if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE)
    SWDRV_func_tab[SWDRV_SET_RA_AND_RR_PACKET_TRAP] = SlaveSetRaAndRrPacketTrap;
#endif
    SWDRV_func_tab[SWDRV_SET_PORT_MAC_ADDR] = SWDRV_SlaveSetPortMacAddr;
#if (SYS_CPNT_PFC == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_PFC_STATUS] = SWDRV_SlaveSetPortPfcStatus;
    SWDRV_func_tab[SWDRV_UPDATE_PFC_PRI_MAP] = SWDRV_SlaveUpdatePfcPriMap;
#endif
#if (SYS_CPNT_ETS == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_COS_GROUP_MAPPING] = SWDRV_SlaveSetPortCosGroupMapping;
    SWDRV_func_tab[SWDRV_SET_PORT_COS_GROUP_SCHEDULING_METHOD] = SWDRV_SlaveSetPortCosGroupSchedulingMethod;
#endif
#if (SYS_CPNT_CN == TRUE)
    SWDRV_func_tab[SWDRV_SET_QCN_CNM_PRIORITY] = SWDRV_SlaveSetQcnCnmPriority;
    SWDRV_func_tab[SWDRV_SET_PORT_QCN_CPQ] = SWDRV_SlaveSetPortQcnCpq;
    SWDRV_func_tab[SWDRV_SET_PORT_QCN_EGR_CNTAG_REMOVAL] = SWDRV_SlaveSetPortQcnEgrCnTagRemoval;
    SWDRV_func_tab[SWDRV_GET_PORT_QCN_CPID] = SWDRV_SlaveGetPortQcnCpid;
#endif
#if (SYS_CPNT_MAC_IN_MAC == TRUE)
    SWDRV_func_tab[SWDRV_SET_MIM_SERVICE] = SlaveSetMimService;
    SWDRV_func_tab[SWDRV_SET_MIM_SERVICE_PORT] = SlaveSetMimServicePort;
#if (SYS_CPNT_IAAS == TRUE)
    SWDRV_func_tab[SWDRV_SET_MIM_SERVICE_PORT_LEARNING_STATUS_FOR_STATION_MOVE] = SlaveSetMimServicePortLearningStatusForStationMove;
#endif
#endif

    SWDRV_func_tab[SWDRV_SET_CPU_RATE_LIMIT] = SlaveSetCpuRateLimit;
    SWDRV_func_tab[SWDRV_GET_PORT_ABILITY] = SlaveGetPortAbility;
    SWDRV_func_tab[SWDRV_SET_PORT_EGRESS_BLOCK] = SlaveSetPortEgressBlock;
    SWDRV_func_tab[SWDRV_ENABLE_PORT_OPENFLOW_MODE]    = SlaveEnablePortOpenFlowMode;
    SWDRV_func_tab[SWDRV_SET_VLAN_FLOODING_FOR_UKN_UC] = SlaveSetVlanFloodingForUknUC;
    SWDRV_func_tab[SWDRV_SET_VLAN_FLOODING_FOR_UKN_MC] = SlaveSetVlanFloodingForUknMC;
    SWDRV_func_tab[SWDRV_SET_VLAN_FLOODING_FOR_BC]     = SlaveSetVlanFloodingForBC;
    SWDRV_func_tab[SWDRV_DELETE_ALL_PORT_FROM_VLAN]    = SlaveDeleteAllPortFromVlan;
    SWDRV_func_tab[SWDRV_STATIC_MAC_MOVE_PKT_TO_CPU]    = SlaveStaticMacMovePktToCpu;

#if (SYS_CPNT_HASH_SELECTION == TRUE)
    SWDRV_func_tab[SWDRV_BIND_HASH_SEL_FOR_SERVICE] = SlaveBindHashSelForService;
#endif
#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
    SWDRV_func_tab[SWDRV_SET_SWITCHING_MODE] = SlaveSetSwitchingMode;
#endif
#if (SYS_CPNT_SWCTRL_FEC == TRUE)
    SWDRV_func_tab[SWDRV_SET_PORT_FEC] = SlaveSetPortFec;
    SWDRV_func_tab[SWDRV_GET_PORT_FEC_STATUS] = SlaveGetPortFecStatus;
#endif
#if(SYS_CPNT_WRED == TRUE)
    SWDRV_func_tab[SWDRV_SET_RANDOM_DETECT] = SWDRV_SlaveRandomDetect;
#endif
#endif /* SYS_CPNT_STACKING */
}



#if 0
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_CreateTask
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create Switch Driver Task. This function
 *           will be called by root.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_CreateTask(void)
{
    UI32_T swdrv_thread_id;
    if (SYSFUN_SpawnThread(SYS_BLD_SWDRV_TASK_PRIORITY,
                           SYSFUN_SCHED_DEFAULT,
                           SYS_BLD_SWDRV_TASK,
                           SYS_BLD_TASK_COMMON_STACK_SIZE,
                           SYSFUN_TASK_NO_FP,
                           SWDRV_TASK_Main,
                           0,
                           &swdrv_thread_id))
    {
#if (SYS_CPNT_SYSLOG == TRUE)
        SYSLOG_OM_RecordOwnerInfo_T   owner_info;
        owner_info.level        = SYSLOG_LEVEL_CRIT;
        owner_info.module_no    = SYSLOG_MODULE_DRIVER_SWITCH;
        owner_info.function_no  = SWDRV_Create_Task_FunNo;
        owner_info.error_no     = SWDRV_Create_Task_ErrNo;
        SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CREATE_TASK_FAIL_MESSAGE_INDEX, "SWDRV", 0, 0);
#endif
        return;
    }

    SWDRV_OM_SetThreadId(swdrv_thread_id);
} /* End of SWDRV_CreateTask() */
#endif

/* FUNCTION NAME: SWDRV_GetShMemInfo
 *----------------------------------------------------------------------------------
 * PURPOSE: Get share memory info
 *----------------------------------------------------------------------------------
 * INPUT:   None
 * OUTPUT:  None
 * RETUEN:  None
 *----------------------------------------------------------------------------------
 * NOTES:
 */
void SWDRV_GetShMemInfo(SYSRSC_MGR_SEGID_T *segid_p, UI32_T *seglen_p)
{
    *segid_p = SYSRSC_MGR_SWDRV_SHMEM_SEGID;
    *seglen_p = sizeof(SWDRV_TYPE_ShmemData_T);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnterTransitionMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will initialize the Switch Driver module and
 *           free all resource to enter transition mode while stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_EnterTransitionMode(void)
{
    SWDRV_OM_WaitTaskTransitionDone();

    SWDRV_OM_EnterTransitionMode();

    SWDRV_OM_Reset();

#if 1/* gordon: mark for test*/
    while(STKTPLG_POM_GetConfigTopologyInfoDoneStatus()==FALSE)
    {
        SYSFUN_Yield();
    }
    /* In case of Hot Insertion, do not reset cross bar*/
    DEV_SWDRV_PMGR_ResetOnDemand(FALSE);
/*EPR: N/A
Problem:When enter master mode,msl wll get error port list
Rootcause: it get port from DEV_SWDRV_Logical2PhyDeviceID,and the dev_swdrv_port_mapping_tbl_stable is not init,so the data is rand
Solution:init database in transition mode
Files:swdrv.c,dev_swdrv.c,dev_swdrv_pmgr.c,dev_swdrv.h,dev_swdrv_pmgr.h*/
    DEV_SWDRV_PMGR_UpdatePortMapping(TRUE);
    /* init the DB first for SWDRV_DisableAllPortAdmin()
     */
    SWDRV_DisableAllPortAdmin();
#endif

    return;
} /* End of SWDRV_EnterTransitionMode() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetTransitionMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the SWDRV into the transition mode.
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
void SWDRV_SetTransitionMode(void)
{
    UI32_T swdrv_thread_id;

    SWDRV_OM_SetTransitionMode();

    SWDRV_OM_SetTaskTransitionDone(FALSE);
    SWDRV_OM_GetThreadId(&swdrv_thread_id);
    SYSFUN_SendEvent(swdrv_thread_id, SWDRV_EVENT_ENTER_TRANSITION_MODE);
}

void SWDRV_HotSwapInsert(UI8_T unit_id, UI32_T starting_port_ifindex, UI32_T number_of_port)
{
    /* When hot removal, rule_ctrl will removed all added rules, so we need to add it here
     * This rule is added originally in SWDRV_ProvisionComplete()
     */
#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
    RULE_CTRL_IP6_DenyLinkLocalL3RoutablePkt(TRUE);
#endif
}

void SWDRV_HotSwapremove(UI8_T unit_id, UI32_T starting_port_ifindex, UI32_T number_of_port)
{
    SWDRV_OM_HotSwapRemove(unit_id);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnterMasterMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will configurate the Switch Driver module to
 *           enter master mode after stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This function must be invoked first before
 *           STA_Enter_Master_Mode() is called.
 * -------------------------------------------------------------------------*/
void SWDRV_EnterMasterMode(void)
{
    UI32_T port_number;
    UI32_T port_type;
    UI32_T port, my_unit_id;

    STKTPLG_POM_GetMyUnitID(&my_unit_id);

    if (FALSE == STKTPLG_POM_IsOptionModule())
    {
        /* Mainboard
         */
        SWDRV_OM_SetSystemInfoBasePortId(1);
        STKTPLG_POM_GetMaxPortNumberOnBoard(my_unit_id, &port_number);

        SWDRV_OM_SetSystemInfoPortNum(port_number);
    }
    else
    {
        /* Module, actually, no chance to run this condition
         */
        STKTPLG_POM_GetMaxPortNumberOnBoard(my_unit_id, &port_number);

        SWDRV_OM_SetSystemInfoBasePortId(port_number + 1);

        STKTPLG_POM_GetLocalMaxPortCapability(&port_number);
        SWDRV_OM_SetSystemInfoPortNum(port_number);
    }

    for(port=1; port<=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; port++)
    {
        if(STKTPLG_POM_GetPortType(my_unit_id, port, &port_type))
        {
            SWDRV_OM_SetPortInfoPortType(port, port_type);
            SWDRV_OM_SetPortInfoExisting(port, TRUE);
        }
        else
        {
            SWDRV_OM_SetPortInfoPortType(port, STKTPLG_PORT_TYPE_NOT_EXIST);
            SWDRV_OM_SetPortInfoExisting(port, FALSE);
        }
    }

    SWDRV_InitDataBase();

#if (SYS_CPNT_STACKING == TRUE)
{
    UI32_T previous_unitId;
    UI32_T index;
    UI32_T stack_id;

    DEV_SWDRV_PMGR_UpdatePortMapping(FALSE);

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    SWDRV_OM_SetSystemInfoStackUnit(0, stack_id);

    previous_unitId = 0;
    index = 1;

    while (STKTPLG_POM_GetNextUnit(&previous_unitId))
    {
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (stack_id != previous_unitId)
            SWDRV_OM_SetSystemInfoStackUnit(index++, previous_unitId);
    }

    /* 2005/10/25 tc
     * change printf to SYSFUN_Debug_Printf
     * These information are for debug purpose
     */
    {
        SWDRV_Switch_Info_T swdrv_system_info;

        SWDRV_OM_GetSystemInfo(&swdrv_system_info);

        SYSFUN_Debug_Printf("swdrv Master - \r\n ...stack id - %d\r\n ...base port ID - %d\r\n ...port_number - %d\r\n ...units - %ld\r\n",
                swdrv_system_info.stack_id,
                swdrv_system_info.base_port_id,
                swdrv_system_info.port_number,
                (unsigned long)swdrv_system_info.num_of_units);

        for (index=0; index < SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; index++)
            SYSFUN_Debug_Printf(" ...unit_tbl[%ld] - %ld\r\n", (long)index, (long)swdrv_system_info.stack_unit_tbl[index]);

        SYSFUN_Debug_Printf(" ...stacking port - %ld\r\n", (long)swdrv_system_info.stacking_port);
    }

}
#endif /*SYS_CPNT_STACKING*/

    SWDRV_OM_EnterMasterMode();

    return;
} /* End of SWDRV_EnterMasterMode() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnterSlaveMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the Switch Driver services and
 *           enter slave mode after stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_EnterSlaveMode(void)
{
    UI32_T port_number;
    UI32_T port_type;
    UI32_T port, my_unit_id;

    STKTPLG_POM_GetMyUnitID(&my_unit_id);

    if (FALSE == STKTPLG_POM_IsOptionModule())
    {
        /* Mainboard
         */
        SWDRV_OM_SetSystemInfoBasePortId(1);
        STKTPLG_POM_GetMaxPortNumberOnBoard(my_unit_id, &port_number);
        SWDRV_OM_SetSystemInfoPortNum(port_number);
    }
    else
    {
        /* Module, actually, no chance to run this condition
         */
        STKTPLG_POM_GetMaxPortNumberOnBoard(my_unit_id, &port_number);

        SWDRV_OM_SetSystemInfoBasePortId(port_number + 1);

        STKTPLG_POM_GetLocalMaxPortCapability(&port_number);

        SWDRV_OM_SetSystemInfoPortNum(port_number);
    }



    for(port=1; port<=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; port++)
    {
        if(STKTPLG_POM_GetPortType(my_unit_id, port, &port_type))
        {
            SWDRV_OM_SetPortInfoPortType(port, port_type);
            SWDRV_OM_SetPortInfoExisting(port, TRUE);
        }
        else
        {
            SWDRV_OM_SetPortInfoPortType(port, STKTPLG_PORT_TYPE_NOT_EXIST);
            SWDRV_OM_SetPortInfoExisting(port, FALSE);
        }
    }

    SWDRV_OM_EnterSlaveMode();

#if (SYS_CPNT_STACKING == TRUE)
    SWDRV_InitDataBase();

    SWDRV_OM_ResetSystemInfoStackUnitTable();
#endif

    {
        SWDRV_Switch_Info_T swdrv_system_info;

        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        printf("\r\n ...stack id - %d\r\n ...base port ID - %d\r\n ...port_number - %d\r\n ...units - %ld\r\n",
                swdrv_system_info.stack_id,
                swdrv_system_info.base_port_id,
                swdrv_system_info.port_number,
                (long)swdrv_system_info.num_of_units);
    }
    return;
} /* End of SWDRV_EnterSlaveMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME  SWDRV_InitDataBase
 * -------------------------------------------------------------------------
 * FUNCTION: This function will init database for SWDRV module when Master
 *           or Slave Mode
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWDRV_InitDataBase(void)
{
    UI32_T stack_id;
    UI32_T port;
    UI32_T trk_idx;
    UI32_T swdrv_trunk_mode;
    UI32_T num_of_units;
    UI32_T media_cap;
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_Port_Info_T swdrv_port_info;

    /* BODY
     */
    STKTPLG_POM_GetMyUnitID(&stack_id);

    SWDRV_OM_SetSystemInfoStackId(stack_id);

    /* Set and get original status of all ports
     */
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    for(port =  swdrv_system_info.base_port_id;
        port <= swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        port++)
    {
#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (!STKTPLG_POM_GetPortMediaCapability(stack_id, port, &media_cap))
        {
            media_cap = 0;
        }

        if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
        {
            SWDRV_OM_SetComboForceMode(port, SYS_DFLT_COMBO_PORT_FORCED_MODE);
        }
        else if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
        {
            SWDRV_OM_SetComboForceMode(port, VAL_portComboForcedMode_sfpForced);
        }
        else
        {
            SWDRV_OM_SetComboForceMode(port, VAL_portComboForcedMode_copperForced);
        }

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        SWDRV_OM_SetComboForceSpeed(port, VAL_portType_other);
#endif
#endif
        memset(&swdrv_port_info, 0, sizeof(SWDRV_Port_Info_T));
        SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
        if ( swdrv_port_info.port_type == STKTPLG_PORT_TYPE_STACKING)
        {
            #if (SYS_CPNT_STACKING == TRUE)
            SWDRV_OM_SetSystemInfoStackingPort(port);

            #endif
            SWDRV_OM_SetPortInfoExisting(port, FALSE);
            SWDRV_OM_SetPortInfoLinkStatus(port, FALSE);
            continue;
        }
        SWDRV_OM_SetPortInfoLinkStatus(port, FALSE);
        SWDRV_OM_SetPortInfoSpeedDuplexOper(port, 0);
        SWDRV_OM_SetPortInfoFlowControlOper(port, VAL_portFlowCtrlStatus_none);
        SWDRV_OM_SetPortInfoIsAutoNeg(port, TRUE);

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
        SWDRV_OM_SetPortInfoSpeedDuplexCfg(port, VAL_portSpeedDpxCfg_fullDuplex100);
        SWDRV_OM_SetPortInfoForced1000tMode(port, VAL_portMasterSlaveModeCfg_auto);
#endif
        /*
         * ES4626F-SW-FLF-LNA-00118, Wed Oct 12 19:12:27 CST 2011
         * update port type during entering master mode to prevent
         * from port type change notification being generated after
         * provision completed. So that the users configured
         * flowcontrol status in force mode can be restored correctly.
         */
        /* SWDRV_Monitor_Module(port); */
    }

    SWDRV_OM_GetTrunkMode(&swdrv_trunk_mode);
    for(trk_idx = 1; trk_idx <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; trk_idx++)
    {

        DEV_SWDRV_PMGR_SetTrunkLoadBalanceMode(swdrv_trunk_mode); /* set trunk mode */

        SWDRV_OM_SetTrunkInfoBcmTrunkId(trk_idx);
        DEV_SWDRV_PMGR_CreateTrunk(trk_idx);

        SWDRV_OM_SetTrunkInfoUsed(trk_idx, FALSE);
    }

    STKTPLG_POM_GetNumberOfUnit(&num_of_units);
    SWDRV_OM_SetSystemInfoNumOfUnit(num_of_units);
    return;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_ProvisionComplete
 * -------------------------------------------------------------------------
 * FUNCTION: This function will tell the Switch Driver module to start
 *           action
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_ProvisionComplete(void)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
    UI32_T              previous_unitId=0;
    UI32_T              index = 1;
    UI32_T              stack_id, num_of_units;
/*EPR:ES3628BT-FLF-000742
Problem:when slave removed,master still has slave mac-address in chip
Root Cause:when del mac by port,it will fail for DEV_SWDRV_Logical2PhyDevicePortID return error.
                          Stktplg update the dev_swdrv_local_chip_mapping before csc use it .And remove the unit
                          info.
Solution:update the stable portmapping .
               keep a stable port mapping,when get mapping fail in  the working portmapping table,try to get from the
                stable port mapping table
 Files:swdrv.c,dev_swdrv_pmgr.h,dev_swdrv.c,dev_swdrv_pmgr.c*/
    DEV_SWDRV_PMGR_UpdatePortMapping(FALSE);

    /* In some chip (e.g. Firebolt), the IPv6 packets with link-local destination address
     * won't be blocked when do L3 routing. A workaround is adding a rule to filter it.
     */
#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
    RULE_CTRL_IP6_DenyLinkLocalL3RoutablePkt(TRUE);
#endif

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    while (STKTPLG_POM_GetNextUnit(&previous_unitId))
    {
        if (stack_id != previous_unitId)
            SWDRV_OM_SetSystemInfoStackUnit(index++, previous_unitId);
    }

    STKTPLG_POM_GetNumberOfUnit(&num_of_units);
    SWDRV_OM_SetSystemInfoNumOfUnit(num_of_units);
#if 0
#if (SYS_CPNT_UNIT_HOT_SWAP == TRUE)
    DEV_SWDRV_PMGR_SavePreHotSwapPortMapping();
#endif
#endif
    /* Set all Slave
     */
#if (SYS_CPNT_STACKING == TRUE)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    if (unit_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PROVISION_COMPLETE) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }

        isc_buffer_p->ServiceID = SWDRV_PROVISION_COMPLETE;

        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {
            SYSFUN_Debug_Printf("\r\n SWDRV: ISC channel is failed to driver unit");
        }
    }
#endif
    /* Set Master
     */
    SWDRV_OM_SetProvisionComplete(TRUE);

    return; /* can't control remote unit */
} /* SWDRV_ProvisionComplete() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetSwdrvProvisionCompleteStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will let all the Switch Driver module (about swdrvl4, swdrvl3) to start
 *           action
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetSwdrvProvisionCompleteStatus(void)
{

    BOOL_T status = FALSE;
    SWDRV_OM_GetProvisionComplete(&status);
    return status;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_HotSwapInsert_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a hot swap mudule is
 *           inserted the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port)
 *           For loosely coulping, a module hot swapped will not cause
 *           topology change.  So this function can be used at loosely
 *           coupling architecture.
 *           But for tightly coupling, we won't use this function.
 * -------------------------------------------------------------------------*/
void SWDRV_Register_HotSwapInsert_CallBack(void (*fun)(UI32_T unit,
                                                       UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(HotSwapInsert_callbacklist);
} /* End of SWDRV_Register_HotSwapInsert_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_HotSwapRemove_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a hot swap mudule is
 *           removed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port)
 *           For loosely coulping, a module hot swapped will not cause
 *           topology change.  So this function can be used at loosely
 *           coupling architecture.
 *           But for tightly coupling, we won't use this function.
 * -------------------------------------------------------------------------*/
void SWDRV_Register_HotSwapRemove_CallBack(void (*fun)(UI32_T unit,
                                                       UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(HotSwapRemove_callbacklist);
} /* End of SWDRV_Register_HotSwapRemove_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_PortLinkUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link down to up the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port)
 * -------------------------------------------------------------------------*/
void SWDRV_Register_PortLinkUp_CallBack(void (*fun)(UI32_T unit,
                                                    UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortLinkUp_callbacklist);
} /* End of SWDRV_Register_PortLinkUp_CallBack() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_PortLinkDown_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link up to down the
 *           register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port)
 * -------------------------------------------------------------------------*/
void SWDRV_Register_PortLinkDown_CallBack(void (*fun)(UI32_T unit,
                                                      UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortLinkDown_callbacklist);
} /* End of SWDRV_Register_PortLinkDown_CallBack() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_PortTypeChanged_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port type changed
 *           register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port, UI32_T port_type)
 * -------------------------------------------------------------------------*/
void SWDRV_Register_PortTypeChanged_CallBack(void (*fun)(UI32_T unit,
                                                         UI32_T port,
                                                         UI32_T port_type))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortTypeChanged_callbacklist);
} /* End of SWDRV_Register_PortTypeChanged_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_PortSpeedDuplex_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the speed or duplex of a
 *           port is changed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port, UI32_T speed_duplex)
 *           Whenever speed or duplex changes, SWDRV needs to notify SWCTRL
 *           and SWCTRL needs to notify
 *           1. LED_MGMT
 *           2. STA
 *           3. IML(RFC2233)
 * -------------------------------------------------------------------------*/
void SWDRV_Register_PortSpeedDuplex_CallBack(void (*fun)(UI32_T unit,
                                                         UI32_T port,
                                                         UI32_T speed_duplex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortSpeedDuplex_callbacklist);
} /* End of SWDRV_Register_PortSpeedDuplex_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Register_PortFlowCtrl_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the flow control of a
 *           port is changed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port, UI32_T flow_control)
 * -------------------------------------------------------------------------*/
void SWDRV_Register_PortFlowCtrl_CallBack(void (*fun)(UI32_T unit,
                                                      UI32_T port,
                                                      UI32_T flow_control))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortFlowCtrl_callbacklist);
} /* End of SWDRV_Register_PortFlowCtrl_CallBack() */

/****************************************************************************/
/* Port Configuration                                                       */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortAdmin
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable a specified port
 * INPUT   : unit -- in which unit
 *           port -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortAdmin(UI32_T unit,
                             UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;
        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;


            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_ADMIN)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable a port of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_ADMIN;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif  /* SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnablePortAdmin(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /* SYS_CPNT_STACKING */
    }

    return TRUE;
} /* End of SWDRV_EnablePortAdmin() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortAdmin
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable a specified port
 * INPUT   : unit -- in which unit
 *           port -- which port to disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortAdmin(UI32_T unit,
                              UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_ADMIN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable a port of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_ADMIN;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            /* disable a port of remote unit
             */
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING*/
            /* if local unit or standalone
             */
            if (SWDRV_LocalDisablePortAdmin(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DisablePortAdmin() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableAllPortAdmin
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable all ports
 * INPUT   : unit -- in which unit
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : only for swctrl enter trasition mode
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableAllPortAdmin(void)
{
    if (SWDRV_LocalDisableAllPortAdmin() == FALSE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    return TRUE;

} /* End of SWDRV_DisableAllPortAdmin() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortCfgSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set speed/duplex configuration of a port
 * INPUT   : unit         -- in which unit
 *           port         -- which port to set
 *           speed_duplex -- speed/duplex to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Forced mode only
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortCfgSpeedDuplex(UI32_T unit,
                                   UI32_T port,
                                   UI32_T speed_duplex)
{
    UI32_T s_d;
    SWDRV_Port_Info_T   swdrv_port_info;

    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;
        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_CFG_SPEED_DUPLEX) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable a port of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_CFG_SPEED_DUPLEX;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->port_cfg_speed_duplex = speed_duplex;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortCfgSpeedDuplex(unit, port, speed_duplex) == FALSE)
            {
                /*UIMSG_MGR_SetErrorCode()*/

                return FALSE;
            }
#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
            SWDRV_OM_SetPortInfoSpeedDuplexCfg(port, speed_duplex);
#endif

#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }

    return TRUE;
} /* End of SWDRV_SetPortCfgSpeedDuplex() */

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPort1000BaseTForceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set master/slave mode configuration of a forced speed port
 * INPUT   : unit         -- in which unit
 *           port         -- which port to set
 *           force_mode   -- master/slave mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Forced mode only
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPort1000BaseTForceMode(UI32_T unit, UI32_T port, UI32_T force_mode)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            BOOL_T              is_option=FALSE;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_FORCE_1000T_PORT_CFG_MODE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set forced port mode of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_FORCE_1000T_PORT_CFG_MODE;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->port_cfg_force_1000t_mode = force_mode;
            unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPort1000BaseTForceMode(unit, port, force_mode) == FALSE)
            {

                return FALSE;
            }
            SWDRV_OM_SetPortInfoForced1000tMode(port, force_mode);

#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }

    return TRUE;
} /* End of SWDRV_SetPort1000BaseTForceMode() */
#endif

/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetCopperEnergyDetect
 * -------------------------------------------------------------------------------------------
 * PURPOSE : This function get the copper energy detect status.
 * INPUT   : unit_id                -- in which unit
 *           port                   -- which port to set
 *           copper_energy_detect   -- on/off mode for a given force 1000T port
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If a given (unit, port) is not available, or it can not support
 *                                 the specified speed/duplex mode
 * NOTE    : 1. This function is applied for 1000T "Forced" master/slave mode only.
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_GetCopperEnergyDetect(UI32_T unit, UI32_T port, UI32_T *copper_energy_detect)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_COPPEER_ENERGY_DETECT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* get copper energy detect of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_GET_COPPEER_ENERGY_DETECT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (!ISC_RemoteCall((UI8_T)unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE; /* can't control remote unit */
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *copper_energy_detect = isc_reply.data.u32;
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalGetCopperEnergyDetect(unit, port, copper_energy_detect) == FALSE)
            {
                /*UIMSG_MGR_SetErrorCode()*/

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortAutoNeg
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable auto-negotiation of a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortAutoNeg(UI32_T unit,
                               UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_AUTONEG) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable port autonegotiation of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_AUTONEG;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif  /*SYS_CPNT_STACKING*/
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnablePortAutoNeg(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_EnablePortAutoNeg() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortAutoNeg
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable auto-negotiation of a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortAutoNeg(UI32_T unit,
                                UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_AUTONEG) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port autonegotiation of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_AUTONEG;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalDisablePortAutoNeg(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DisablePortAutoNeg() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortCfgFlowCtrl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the flow control function of a port
 * INPUT   : unit -- in which unit
 *           port -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Flow control mode will be auto determined by duplex.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortCfgFlowCtrl(UI32_T unit,
                                   UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_CFG_FLOWCTRL) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_CFG_FLOWCTRL;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif
    /* if local unit or standalone
     */
            if (SWDRV_LocalEnablePortCfgFlowCtrl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_EnablePortCfgFlowCtrl() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortCfgFlowCtrl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the flow control function of a port
 * INPUT   : unit -- in which unit
 *           port -- which port to disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortCfgFlowCtrl(UI32_T unit,
                                    UI32_T port)
{
    UI8_T retval;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_CFG_FLOWCTRL) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_CFG_FLOWCTRL;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif

            /* if local unit or standalone
             */

            if ( (retval = SWDRV_LocalDisablePortCfgFlowCtrl (unit, port)) == FALSE)
            {

                return FALSE;
            }
#if 0
            /* Sunny Tsai, For SWCTRL task sem dead Lock issue, We cant call back to SWDRV
             */
            /* return value:
             * 1. the 1st bit: disable port flow control is successful or not.
             * 2. the 2nd bit of return value is indicated the flow control oper status is changed
             * or not.
             */
            if (retval & SWDRV_PORT_FLOW_CONTROL_OPER_STATUS_CHANGED)
            {
                SWDRV_Notify_PortFlowCtrl(unit, port, VAL_portFlowCtrlStatus_none);
            }
#endif

#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DisablePortCfgFlowCtrl() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortCfgFlowCtrl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the flow control function of a port
 * INPUT   : unit -- in which unit
 *           port -- which port to disable
 *           mode -- VAL_portFlowCtrlCfg_enabled: Turn on both TX and RX pause function
 *                   VAL_portFlowCtrlCfg_disabled: Turn off both TX and RX pause function
 *                   VAL_portFlowCtrlCfg_tx: Turn on TX and turn off RX pause function.
 *                   VAL_portFlowCtrlCfg_rx: Turn on RX and turn off TX pause function.
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortCfgFlowCtrl(UI32_T unit, UI32_T port, UI32_T mode)
{
    UI8_T retval;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_CFG_FLOWCTRL) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_CFG_FLOWCTRL;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->combo_forcedmode = mode;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( (retval = SWDRV_LocalSetPortCfgFlowCtrl (unit, port, mode)) == FALSE)
            {

                return FALSE;
            }
            /* return value:
             * 1. the 1st bit: disable port flow control is successful or not.
             * 2. the 2nd bit of return value is indicated the flow control oper status is changed
             * or not.
             */
            if (retval & SWDRV_PORT_FLOW_CONTROL_OPER_STATUS_CHANGED)
            {
                SWDRV_Notify_PortFlowCtrl(unit, port, VAL_portFlowCtrlStatus_none);
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }


    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortAutoNegCapability
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set auto-negotiation capability of a port
 * INPUT   : unit       -- in which unit
 *           port       -- which port to set
 *           capability -- port auto-negotiation capability
 *           (refer to enum SWDRV_Port_Capability_E)
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Flow control capability bit always depends on flow control mode.
 *           ie. If flow control is enabled, when enabing auto negotiation,
 *               flow control capability bit needs to be set on as well.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortAutoNegCapability(UI32_T unit,
                                      UI32_T port,
                                      UI32_T capability)
{
    UI32_T checkval;
    UI32_T swdrv_capability = 0;

#if 0
    if (capability & SYS_VAL_portCapabilities_portCap10half)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap10half;
    if (capability & SYS_VAL_portCapabilities_portCap10full)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap10full;
    if (capability & SYS_VAL_portCapabilities_portCap100half)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap100half;
    if (capability & SYS_VAL_portCapabilities_portCap100full)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap100full;
    if (capability & SYS_VAL_portCapabilities_portCap1000half)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap1000half;
    if (capability & SYS_VAL_portCapabilities_portCap1000full)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap1000full;
    if (capability & SYS_VAL_portCapabilities_portCap10gFull)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap10gFull;
    if (capability & SYS_VAL_portCapabilities_portCap40gFull)
        swdrv_capability |= SYS_VAL_portCapabilities_portCap40gFull;
    if (capability & SYS_VAL_portCapabilities_portCapSym)
        swdrv_capability |= SYS_VAL_portCapabilities_portCapSym;
    if (capability & SYS_VAL_portCapabilities_portCapFlowCtrl)
        swdrv_capability |= SYS_VAL_portCapabilities_portCapFlowCtrl;

    /* for combo port use */
    checkval = SYS_VAL_portCapabilities_portCap10half   | SYS_VAL_portCapabilities_portCap10full   |
               SYS_VAL_portCapabilities_portCap100half  | SYS_VAL_portCapabilities_portCap100full  |
               SYS_VAL_portCapabilities_portCap1000half | SYS_VAL_portCapabilities_portCap1000full |
               SYS_VAL_portCapabilities_portCap10gFull  | SYS_VAL_portCapabilities_portCap40gFull  |
               SYS_VAL_portCapabilities_portCapSym  | SYS_VAL_portCapabilities_portCapFlowCtrl;
    if(swdrv_capability & ~((UI32_T)checkval))
        return FALSE;
#else
    swdrv_capability = capability;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_AUTONEG_CAPABILITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port autonegcapability of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_AUTONEG_CAPABILITY;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->port_cfg_capability= swdrv_capability;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortAutoNegCapability (unit, port, swdrv_capability) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetPortAutoNegCapability() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetStackInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the stacking feature for the stacking
 *           port
 * INPUT   : stacking_port               -- local user port
 *           total_stacking_device_count -- the chip number in stacking
 *           stack_id                    -- base is 0
 *           simplex                     -- TRUE is simplex
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : After local discovery, STK_TPLG need to call this API to set
 *           stack port.
 * -------------------------------------------------------------------------*/
#if (SYS_CPNT_STACKING == TRUE)
BOOL_T SWDRV_SetStackInfo(UI32_T stacking_port,
                          UI32_T total_stacking_device_count,
                          UI32_T stack_id,
                          BOOL_T simplex)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

                /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {

        SWDRV_Switch_Info_T swdrv_system_info;
        SWDRV_Port_Info_T   swdrv_port_info;

        /* only local unit
         */
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        if((stacking_port < swdrv_system_info.base_port_id) ||
           (stacking_port > swdrv_system_info.base_port_id+swdrv_system_info.port_number-1))
        {

            return FALSE;
        }

        SWDRV_OM_GetPortInfo(stacking_port, &swdrv_port_info);
        if(swdrv_port_info.port_type == VAL_portType_hundredBaseTX)
        {

            return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_SetStackInfo() */
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortSTAState
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set spanning tree state of specified port in
 *           certain VLAN
 * INPUT   : vid   -- on which VLAN
 *           unit  -- in which unit
 *           port  -- which port to set
 *           state -- the spanning tree state
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : For single STA, vid is DONT CARE
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortSTAState(UI32_T vid,
                             UI32_T unit,
                             UI32_T port,
                             UI32_T state)
{
    UI32_T sta_state;

    switch(state)
    {
        case VAL_dot1dStpPortState_disabled:
            sta_state = VAL_dot1dStpPortState_disabled;
            break;
        case VAL_dot1dStpPortState_blocking:
            sta_state = VAL_dot1dStpPortState_blocking;
            break;
        case VAL_dot1dStpPortState_listening:
            sta_state = VAL_dot1dStpPortState_listening;
            break;
        case VAL_dot1dStpPortState_learning:
            sta_state = VAL_dot1dStpPortState_learning;
            break;
        case VAL_dot1dStpPortState_forwarding:
            sta_state = VAL_dot1dStpPortState_forwarding;
            break;
        default:
            return FALSE;
    }


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

                /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_STA_STATE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            /* set port spanning tree of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_STA_STATE;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->port_cfg_vid   = vid;
            isc_buffer_p->port_cfg_state = sta_state;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortSTAState(unit, vid, port, state) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetPortSTAState() */

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableMultipleSTA
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable Multiple spanning tree
 * INPUT   : unit -- in which unit
 *           port -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableMultipleSTA(UI32_T unit)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;
        UI16_T              unit_bmp=0;
        UI32_T              stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != unit )
        {
            if (FALSE == STKTPLG_POM_UnitExist(unit))
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_MULTI_STA) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable multi STA of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_MULTI_STA;
            isc_buffer_p->unit      = unit;
            /* config main-board
             */
            unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

        /* check the module of the unit is exist or not even the unit is master or slave
         */
        if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_MULTI_STA)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable multi STA of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_MULTI_STA;
            isc_buffer_p->unit      = drv_unit;
            unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }

        if ( stack_id == unit )
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnableMultiSTA () == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;

} /* End of SWDRV_EnableMultipleSTA() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableMultipleSTA
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable Multiple spanning tree
 * INPUT   : unit -- in which unit
 *           port -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableMultipleSTA(UI32_T unit)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;
        UI16_T              unit_bmp=0;
        UI32_T              stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != unit )
        {
            if (FALSE == STKTPLG_POM_UnitExist(unit))
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_MULTI_STA) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable multi STA of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_MULTI_STA;
            isc_buffer_p->unit      = unit;

            /* config main-board */
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
                {

                    return FALSE; /* can't control remote unit */
                }
        }

        /* check the module of the unit is exist or not even the unit is master or slave
         */
        if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_MULTI_STA) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable multi STA of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_MULTI_STA;
            isc_buffer_p->unit      = drv_unit;
            unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }

        if ( stack_id == unit )
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalDisableMultiSTA () == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;

} /* End of SWDRV_DisableMultipleSTA() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddVlanToMst
 * -------------------------------------------------------------------------
 * FUNCTION: This function adds a VLAN to a given Spanning Tree instance.
 * INPUT   : vid                -- the VLAN will be added to a given Spanning Tree
 *           mstidx             -- mstidx (multiple spanning tree index) to identify a unique spanning tree
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. This function SHALL ONLY be supported/invoked for those ASICs which have
 *              "Multiple Spanning Instance" concept in their design. "mstidx" will be used
 *              to identify a unique "Spanning Instance" in the system.
 *           2. For those ASICs which have "Multiple Spanning Instance" concept, this following
 *              set of service routines shall be invoked for Multiple Spanning Tree configuration:
 *                  SWDRV_SetPortStateWithMstidx();
 *                  SWDRV_AddVlanToMst();
 *                  SWDRV_DeleteVlanFromMst();
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddVlanToMst(UI32_T vid, UI32_T mstidx)
{
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_VLAN_TO_MST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            /* create vlan id of remote all driver unit
             */
            isc_buffer_p->ServiceID       = SWDRV_ADD_VLAN_TO_MST;
            isc_buffer_p->vlan_vid        = vid;
            isc_buffer_p->port_cfg_mstid  = mstidx;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
#endif
        if(!SWDRV_LocalAddVlanToMst(vid, mstidx))
        {

            /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_AddVlanToMst() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeleteVlanFromMst
 * -------------------------------------------------------------------------
 * FUNCTION: This function deletes a VLAN from a given Spanning Tree instance.
 * INPUT   : vid                -- the VLAN will be added to a given Spanning Tree
 *           mstidx             -- mstidx (multiple spanning tree index) to identify a unique spanning tree
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. This function SHALL ONLY be supported/invoked for those ASICs which have
 *              "Multiple Spanning Instance" concept in their design. "mstidx" will be used
 *              to identify a unique "Spanning Instance" in the system.
 *           2. For those ASICs which have "Multiple Spanning Instance" concept, this following
 *              set of service routines shall be invoked for Multiple Spanning Tree configuration:
 *                  SWDRV_SetPortStateWithMstidx();
 *                  SWDRV_AddVlanToMst();
 *                  SWDRV_DeleteVlanFromMst();
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeleteVlanFromMst(UI32_T vid, UI32_T mstidx)
{

#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_VLAN_FROM_MST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
            */
            isc_buffer_p->ServiceID       = SWDRV_DELETE_VLAN_FROM_MST;
            isc_buffer_p->vlan_vid        = vid;
            isc_buffer_p->port_cfg_mstid  = mstidx;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
#endif
        if(!SWDRV_LocalDeleteVlanFromMst(vid, mstidx))
        {

            /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_DeleteVlanFromMst() */
#endif /* (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

/*-------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortXstpState
-------------------------------------------------------------------------------------------
 * PURPOSE : This function sets the Port Spanning Tree State of the specified port.
 * INPUT   : mstid              -- Multi-Spanning Tree ID
 *           vlan_count         -- total vlan count
 *           vlan_list          -- the vlan list (UI16_T array)
 *           unit_id            -- which unit
 *           port               -- which port to set
 *           state              -- the port spanning tree state
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If a given port is not available
 * NOTE    : 1. In multiple spanning tree (MSTP) mode,
 *              a) In multiple spanning tree environment, each port will have a specific
 *                 state on a given spanning tree.
 *              b) Most of ASIC uses the per VLAN port state to implement the Port Spanning Tree State.
 *              c) Since a spanning tree is running over a certain VLANs, we need to configure the
 *                 all "per VLAN port states" to the same port state.
 *              d) The vlan_count and vlan_list shows the vlan groups that a given spanning tree
 *                 is running.
 *           2. In single spanning tree (SSTP) mode, the vlan_count and vlan_list shall be ignored.
 *              The calling route shall set vlan_count = 0, and vlan_list = NULL.
 *           3. The enumerated value for port spanning tree state is defined in file, "leaf_1493.h".
 *                  #define VAL_dot1dStpPortState_disabled
 *                  #define VAL_dot1dStpPortState_blocking
 *                  #define VAL_dot1dStpPortState_listening
 *                  #define VAL_dot1dStpPortState_learning
 *                  #define VAL_dot1dStpPortState_forwarding
 *
-------------------------------------------------------------------------------------------
*//* ArthurWu, 12/10/2002 02:29U*/
BOOL_T SWDRV_SetPortXstpState(  UI32_T mstid,
                                UI32_T vlan_count,
                                UI16_T *vlan_list,
                                UI32_T unit_id,
                                UI32_T port,
                                UI32_T state)
{

    switch(state)
    {
        case VAL_dot1dStpPortState_disabled:
        case VAL_dot1dStpPortState_blocking:
        case VAL_dot1dStpPortState_listening:
        case VAL_dot1dStpPortState_learning:
        case VAL_dot1dStpPortState_forwarding:
        break;
        default:
            return FALSE;
    }


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit_id, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit_id) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              drv_unit;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit_id)) || (FALSE == STKTPLG_POM_PortExist(unit_id, port)) )
            {

                return FALSE;
            }

            if (port > max_port_number)
            {
                if (TRUE == STKTPLG_POM_OptionModuleIsExist(unit_id, &drv_unit))
                {
                    unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit_id);
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_XSTP_STATE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port spanning tree of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_PORT_XSTP_STATE;
            isc_buffer_p->unit                  = unit_id;
            isc_buffer_p->port                  = port;
            isc_buffer_p->port_cfg_mstid        = mstid;
            isc_buffer_p->port_cfg_unit_id      = unit_id;
            isc_buffer_p->port_cfg_vlan_count   = vlan_count;
            isc_buffer_p->port_cfg_state        = state;
            memcpy(isc_buffer_p->port_cfg_vlan_list, vlan_list, sizeof(UI16_T)*vlan_count );

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortXstpState(mstid, vlan_count, vlan_list, unit_id, port, state) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortStateWithMstidx
 * -------------------------------------------------------------------------
  * PURPOSE : This function sets the Port Spanning Tree State of the specified port with
 *           "Multiple Spanning Tree Index" associated.
 * INPUT   : mstidx             -- mstidx (multiple spanning tree index) to identify a unique spanning tree
 *           unit_id            -- which unit
 *           port               -- which port to set
 *           state              -- the port spanning tree state
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. This function SHALL ONLY be supported/invoked for those ASICs which have
 *              "Multiple Spanning Instance" concept in their design. "mstidx" will be used
 *              to identify a unique "Spanning Instance" in the system.
 *           2. For those ASICs which have "Multiple Spanning Instance" concept, this following
 *              set of service routines shall be invoked for Multiple Spanning Tree configuration:
 *                  SWDRV_SetPortStateWithMstidx();
 *                  SWDRV_AddVlanToMst();
 *                  SWDRV_DeleteVlanFromMst();
 *           2. In multiple spanning tree (MSTP) mode, each port will have a specific
 *              state on a given spanning tree.
 *           3. In single spanning tree (SSTP) mode, the "mstidx" SHALL be ignored.
 *           4. The enumerated value for port spanning tree state is defined in file, "leaf_1493.h".
 *                  #define VAL_dot1dStpPortState_disabled
 *                  #define VAL_dot1dStpPortState_blocking
 *                  #define VAL_dot1dStpPortState_listening
 *                  #define VAL_dot1dStpPortState_learning
 *                  #define VAL_dot1dStpPortState_forwarding
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortStateWithMstidx(UI32_T mstidx, UI32_T unit_id, UI32_T port, UI32_T state)
{
    switch(state)
    {
        case VAL_dot1dStpPortState_disabled:
        case VAL_dot1dStpPortState_blocking:
        case VAL_dot1dStpPortState_listening:
        case VAL_dot1dStpPortState_learning:
        case VAL_dot1dStpPortState_forwarding:
        break;
        default:
            return FALSE;
    }


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit_id, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (((stack_id != unit_id)
             || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
            &&  (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              drv_unit;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit_id)) || (FALSE == STKTPLG_POM_PortExist(unit_id, port)) )
            {

                return FALSE;
            }

            if (port > max_port_number)
            {
                if (TRUE == STKTPLG_POM_OptionModuleIsExist(unit_id, &drv_unit))
                {
                    unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit_id);
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_STATE_WITH_MSTIDX) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port spanning tree of remote unit
             */
            isc_buffer_p->ServiceID           = SWDRV_SET_PORT_STATE_WITH_MSTIDX;
            isc_buffer_p->unit                = unit_id;
            isc_buffer_p->port                = port;
            isc_buffer_p->port_cfg_mstid      = mstidx;
            isc_buffer_p->port_cfg_unit_id    = unit_id;
            isc_buffer_p->port_cfg_state      = state;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortStateWithMstidx(mstidx, unit_id, port, state) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}/* End of SWDRV_SetPortStateWithMstidx() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the port type
 * INPUT   : unit   -- which unit
 *           port   -- which port
 * OUTPUT  : port_type -- port type to return
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : only for Led_drv
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortType(UI32_T unit, UI32_T port, UI32_T *port_type)
{
    SWDRV_Port_Info_T swdrv_port_info;
    BOOL_T      provision_complete;
    UI32_T      stack_id;

    memset(&swdrv_port_info, 0, sizeof(swdrv_port_info));
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        SWDRV_OM_GetProvisionComplete(&provision_complete);
        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if (provision_complete == TRUE && stack_id == unit)
        {
            if(SWDRV_OM_GetPortInfo(port, &swdrv_port_info) == FALSE)
            {
                return FALSE;
            }
            *port_type = swdrv_port_info.port_type;
            return TRUE;
        }

        if(STKTPLG_POM_GetPortType(unit, port, port_type) == FALSE)
        {
            return FALSE;
        }
        return TRUE;
    }

}/* End of SWDRV_GetPortType () */
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_GetPortLoopbackTestResult
 * ------------------------------------------------------------------------
 * PURPOSE  : SWCTRL use this API to get loopback test result.
 * INPUT    : None.
 * OUTPUT   : test_result --- The loopback test result in the format of port bit map.
 *                            If loopback test fail, the bit is "1", otherwise "0".
 *                            The MSB of byte 0 is port 1,
 *                            the LSB of byte 0 is port 8,
 *                            the MSB of byte 1 is port 9,
 *                            the LSB of byte 1 is port 16,
 *                            ...
 *                            and so on.
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_GetPortLoopbackTestResult(UI8_T test_result[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK])
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T      request_unit_bitmap = 0;
        UI32_T      unit, drv_unit;
#endif
         memset(test_result, 0, sizeof(test_result));

#if (SYS_CPNT_STACKING == TRUE)
        request_unit_bitmap = SWDRV_GetValidUnitBmp();
        /* step 1 : send to remote unit */
        if (request_unit_bitmap)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_LOOPBACK_TEST_RESULT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            /* Copy data from buffer to packet and send */
            isc_buffer_p->ServiceID   = SWDRV_GET_PORT_LOOPBACK_TEST_RESULT;
            SWDRV_OM_GetSystemInfoStackId(&isc_buffer_p->unit)
            SWDRV_OM_SetPortLoopbackList(test_result);
            if (ISC_SendMcastReliable(request_unit_bitmap,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        /* step 2 : send to local unit */
        if (FALSE == SWDRV_LocalGetPortLoopbackTestResult(test_result))
        {
            /* UIMSG_MGR_SetErrorCode() */
            printf("SWDRV_LocalGetPortLoopbackTestResult FAIL\n");

            return FALSE;
        }

        SWDRV_WaitForRemotePortLoopBackGot(request_unit_bitmap);
#else
        if (FALSE == SWDRV_LocalGetPortLoopbackTestResult(test_result))
        {
            /* UIMSG_MGR_SetErrorCode() */
            printf("SWDRV_LocalGetPortLoopbackTestResult FAIL\n");

            return FALSE;
        }

#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortTypeList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get whole system port types.
 * INPUT   : None
 * OUTPUT  : port_type_list -- port types of whole system
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : 1. The number of port_type_list is
 *              SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT.
 *           2. used it before provision-complete only.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortTypeList(UI32_T *port_type_list)
{
    UI32_T port;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T      temp_unit, port_type;
#endif
        BOOL_T      provision_complete;
#if (SYS_CPNT_STACKING == FALSE)
        SWDRV_Switch_Info_T swdrv_system_info;
        SWDRV_Port_Info_T   swdrv_port_info;
#endif

        for(port=1; port<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; port++)
        {
            port_type_list[port-1] = STKTPLG_PORT_TYPE_NOT_EXIST;
        }

        SWDRV_OM_GetProvisionComplete(&provision_complete);
        if (provision_complete == TRUE)
        {

            return FALSE;
        }

#if (SYS_CPNT_STACKING == TRUE)

        for (temp_unit=1; temp_unit<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; temp_unit++)
        {
            for(port=1; port<=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; port++)
            {
                if (STKTPLG_POM_GetPortType(temp_unit, port, &port_type) == TRUE)
                {
                    port_type_list[SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT*(temp_unit-1) + (port-1)] = port_type;
                }
            }
        }
#else
        /* if local unit or standalone
         */
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        for(port= swdrv_system_info.base_port_id;
            port<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            port++)
        {
            memset(&swdrv_port_info, 0, sizeof(swdrv_port_info));
            SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
            port_type_list[(port-1)] = swdrv_port_info.port_type;
        }

#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}/* End of SWDRV_GetPortTypeList () */

/****************************************************************************/
/* VLAN                                                                     */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortPVID
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set default VLAN ID of a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 *           pvid -- permanent VID to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortPVID(UI32_T unit,
                         UI32_T port,
                         UI32_T pvid)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            if (port > max_port_number)
            {
                if (TRUE == STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
                {
                    unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_PVID) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port pvid of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_PVID;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->vlan_pvid = pvid;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING*/
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortPVID(unit, port, pvid) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetPortPVID() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_CreateVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create a specified VLAN
 * INPUT   : vid -- which VLAN to create
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not availabl
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_CreateVlan(UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_CREATE_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
            */
            isc_buffer_p->ServiceID = SWDRV_CREATE_VLAN;
            isc_buffer_p->vlan_vid  = vid;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalCreateVlan(vid))
        {

            /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_CreateVlan() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DestroyVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a specified VLAN
 * INPUT   : vid -- which VLAN to delete
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not availabl
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DestroyVlan(UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DESTROY_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* destroy vlan id of remote all unit
            */
            isc_buffer_p->ServiceID = SWDRV_DESTROY_VLAN;
            isc_buffer_p->vlan_vid  = vid;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDestroyVlan(vid))
        {

            /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_DestroyVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetGlobalDefaultVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function changes the global default VLAN
 * INPUT   : vid                -- the vid of the new default VLAN
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If the specified VLAN is not available.
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetGlobalDefaultVlan(UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_GLOBAL_DEFAULT_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID = SWDRV_SET_GLOBAL_DEFAULT_VLAN;
            isc_buffer_p->vlan_vid  = vid;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalSetGlobalDefaultVlan(vid))
        {

            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_SetGlobalDefaultVlan() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddPortToVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add a port to the member set of a specified
 *           VLAN
 * INPUT   : unit -- which unit to add
 *           port -- which port to add
 *           vid  -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddPortToVlanMemberSet(UI32_T unit,
                                    UI32_T port,
                                    UI32_T vid)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_PORT_TO_VLAN_MEMBER_SET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* add port to vlan member of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADD_PORT_TO_VLAN_MEMBER_SET;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->vlan_vid  = vid;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
        /* if local unit or standalone
         */
        if (SWDRV_LocalAddPortToVlanMemberSet(unit, port,vid) == FALSE)
        {

            return FALSE;
        }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AddPortToVlanMemberSet() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeletePortFromVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a port from the member set of a
 *           specified VLAN
 * INPUT   : unit -- which unit to delete
 *           port -- which port to delete
 *           vid  -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeletePortFromVlanMemberSet(UI32_T unit,
                                         UI32_T port,
                                         UI32_T vid)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_PORT_FROM_VLAN_MEMBER_SET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* delelte port to vlan member of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DELETE_PORT_FROM_VLAN_MEMBER_SET;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->vlan_vid  = vid;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDeletePortFromVlanMemberSet(unit, port, vid) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DeletePortFromVlanMemberSet() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddPortToVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set a port to output untagged frames over
 *           the specified VLAN
 * INPUT   : unit -- which unit to add
 *           port -- which port to add
 *           vid  -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddPortToVlanUntaggedSet(UI32_T unit,
                                      UI32_T port,
                                      UI32_T vid)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_PORT_TO_VLAN_UNTAGGED_SET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* add untagged port set of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADD_PORT_TO_VLAN_UNTAGGED_SET;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->vlan_vid  = vid;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_localAddPortToVlanUntaggedSet(unit, port, vid) == FALSE)
            {
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AddPortToVlanUntaggedSet() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeletePortFromVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a port from the untagged set of a
 *           specified VLAN
 * INPUT   : unit -- which unit to add
 *           port -- which port to add
 *           vid  -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Delete a port from untagged set means to recover this port to be
 *           a tagged member set of specified vlan.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeletePortFromVlanUntaggedSet(UI32_T unit,
                                           UI32_T port,
                                           UI32_T vid)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_PORT_FROM_VLAN_UNTAGGED_SET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* delete untagged port set of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DELETE_PORT_FROM_VLAN_UNTAGGED_SET;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->vlan_vid  = vid;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDeletePortFromVlanUntaggedSet(unit, port, vid) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DeletePortFromVlanUntaggedSet() */


BOOL_T SWDRV_SetSystemMTU(UI32_T status,UI32_T mtu)
{
#if 0 /* JinhuaWei, 03 August, 2008 2:25:25 */
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif
#endif /* #if 0 */
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        if(!SWDRV_LocalSetSystemMTU(status,mtu))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL_T SWDRV_SetPortMTU(UI32_T unit,UI32_T port,UI32_T MTU)
{


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
#if 1
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit             ) ||
            (port > max_port_number))
   #if (SYS_CPNT_MGMT_PORT == TRUE)
                 && (port != SYS_ADPT_MGMT_PORT)
   #endif
              )
        {

            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PRIORITY_MAPPING) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                /* a port of remote unit
                 */
            isc_buffer_p->ServiceID = SWDRV_SET_PORTMTU ;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->mtu = MTU;


             if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

        #endif
        else
        {
#endif /*SYS_CPNT_STACKING*/
            /* if local unit or standalone
             */


            if (!SWDRV_LocalSetPortMTU(unit, port, MTU))
            {
                /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/

    }


    return TRUE;


}


/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_GetPortMaxFrameSize
 * -------------------------------------------------------------------------
 * PURPOSE : to get max frame size of port
 * INPUT   : unit
 *           port
 * OUTPUT  : untagged_max_frame_sz_p - max frame size for untagged frames
 *           tagged_max_frame_sz_p   - max frame size for tagged frames
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_GetPortMaxFrameSize(UI32_T unit, UI32_T port, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

#if (SYS_CPNT_STACKING == TRUE)
    UI32_T  max_port_number;
    UI32_T  stack_id;

    if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
    {
        return FALSE;
    }

    /* if remote unit
     */
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    if ( ((stack_id != unit) ||
         (port > max_port_number))
       )
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        SWDRV_IscReplyBuf_T isc_reply;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
        {

            return FALSE;
        }

        if (port > max_port_number)
        {
            if (!STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
            {

                return FALSE;
            }
        }
        else
        {
            drv_unit = unit;
        }

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_MAX_FRAME_SIZE) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {

            return FALSE;
        }

        isc_buffer_p->ServiceID = SWDRV_GET_PORT_MAX_FRAME_SIZE;
        isc_buffer_p->unit = unit;
        isc_buffer_p->port = port;

        if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                            SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                            sizeof(isc_reply), (UI8_T *)&isc_reply,
                            SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
        {
            return FALSE;
        }

        if (!isc_reply.return_value.bool)
            return FALSE;

        *untagged_max_frame_sz_p = isc_reply.data.u32x2.u32_1;
        *tagged_max_frame_sz_p = isc_reply.data.u32x2.u32_2;
    }
    else
#endif /* (SYS_CPNT_STACKING == TRUE) */
    {
        if (!SWDRV_LocalGetPortMaxFrameSize(unit, port, untagged_max_frame_sz_p, tagged_max_frame_sz_p))
        {
            return FALSE;
        }
    }

    return TRUE;
}

#if (SYS_CPNT_VXLAN == TRUE)
BOOL_T SWDRV_CreateVxlanAccessPort(
    UI32_T              vfi_id,
    UI32_T              l3_inf_id,
    UI32_T              unit,
    UI32_T              port,
    UI8_T               mac[SYS_ADPT_MAC_ADDR_LEN],
    UI32_T              match_type,
    UI32_T              *vxlan_port_p)
{
    return DEV_SWDRV_PMGR_CreateVxlanAccessPort(vfi_id, l3_inf_id, unit, port, mac, match_type, vxlan_port_p);
}

BOOL_T SWDRV_CreateVxlanNetworkPort(
    UI32_T                      vfi_id,
    UI32_T                      udp_port,
    BOOL_T                      is_mc,
    L_INET_AddrIp_T             *l_vtep_p,
    L_INET_AddrIp_T             *r_vtep_p,
    BOOL_T                      is_ecmp,
    void                        *nh_hw_info,
    UI32_T                      *vxlan_port_p)
{
    return DEV_SWDRV_PMGR_CreateVxlanNetworkPort(vfi_id, udp_port, is_mc, l_vtep_p, r_vtep_p, is_ecmp, nh_hw_info, vxlan_port_p);
}

BOOL_T SWDRV_DestroyVxlanPort(
    UI32_T  vfi_id,
    UI32_T  vxlan_port_id,
    BOOL_T  is_ecmp)
{
    return DEV_SWDRV_PMGR_DestroyVxlanPort(vfi_id, vxlan_port_id, is_ecmp);
}

BOOL_T SWDRV_CreateVxlanNexthop(
    UI32_T              l3_inf_id,
    UI32_T              unit,
    UI32_T              port,
    UI8_T               mac[SYS_ADPT_MAC_ADDR_LEN],
    BOOL_T              is_mc,
    void                **nh_hw_info_pp)
{
    return DEV_SWDRV_PMGR_CreateVxlanNexthop(l3_inf_id, unit, port, mac, is_mc, nh_hw_info_pp);
}

BOOL_T SWDRV_DestroyVxlanNexthop(void *nh_hw_info)
{
    return DEV_SWDRV_PMGR_DestroyVxlanNexthop(nh_hw_info);
}

BOOL_T SWDRV_AddVxlanEcmpNexthop(
    UI32_T                      vfi_id,
    UI32_T                      vxlan_port_id,
    void                        *nh_hw_info)
{
    return DEV_SWDRV_PMGR_AddVxlanEcmpNexthop(vfi_id, vxlan_port_id, nh_hw_info);
}

BOOL_T SWDRV_RemoveVxlanEcmpNexthop(
    UI32_T                      vfi_id,
    UI32_T                      vxlan_port_id,
    void                        *nh_hw_info)
{
    return DEV_SWDRV_PMGR_RemoveVxlanEcmpNexthop(vfi_id, vxlan_port_id, nh_hw_info);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetVxlanVpn
 * -------------------------------------------------------------------------
 * FUNCTION: To add/del VPN for VXLAN
 * INPUT   : vpn_info_p - key for add is vnid
 *                        key for del is vfi/bc_group
 *           is_add     - TRUE to add
 * OUTPUT  : vpn_info_p - vfi/bc_group for add
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetVxlanVpn(
    SWDRV_VxlanVpnInfo_T    *vpn_info_p,
    BOOL_T                  is_add)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
        UI16_T  unit_bmp = 0;

#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        /* if remote unit
         */
        if (unit_bmp != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VXLAN_VPN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_VXLAN_VPN;
            isc_buffer_p->info.vxlan_vpn.vpn_info = *vpn_info_p;
            isc_buffer_p->info.vxlan_vpn.is_add   = is_add;

            if (unit_bmp != 0)
            {
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {
                    return FALSE; /* can't control remote unit */
                }
            }
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */

        if (!SWDRV_LocalSetVxlanVpn(vpn_info_p, is_add))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddVtepIntoMcastGroup
 * -------------------------------------------------------------------------
 * FUNCTION: To add/del a vxlan port to mcast group.
 * INPUT   : bcast_group - bcast group to set
 *           vxlan_port  - vxlan port to set
 *           unit        - unit to set
 *           port        - port to set (trunk id if unit is 0)
 *           is_add      - TRUE to add
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddVtepIntoMcastGroup(
    UI32_T  bcast_group,
    UI32_T  vxlan_port,
    BOOL_T  is_add)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
        {
            if (FALSE == SWDRV_LocalAddVtepIntoMcastGroup(
                    bcast_group, vxlan_port, is_add))
            {
                DBG_PRINT("SWDRV_LocalAddVtepIntoMcastGroup fail");
                return FALSE;
            }
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetVxlanStatus
 * -------------------------------------------------------------------------
 * FUNCTION: To enable/disable vxlan globally.
 * INPUT   : is_enable          - TRUE to enable
 *           is_random_src_port - TRUE to configure random src port also
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetVxlanStatus(
    BOOL_T  is_enable,
    BOOL_T  is_random_src_port)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VXLAN_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
            */
            isc_buffer_p->ServiceID = SWDRV_SET_VXLAN_STATUS;
            isc_buffer_p->info.vxlan_status.is_enable = is_enable;
            isc_buffer_p->info.vxlan_status.is_random_src_port = is_random_src_port;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if standalone
         */
        if(!SWDRV_LocalSetVxlanStatus(is_enable, is_random_src_port))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetVxlanStatusPort
 * -------------------------------------------------------------------------
 * FUNCTION: To enable/disable vxlan status for a port.
 * INPUT   : unit        - unit to set
 *           port        - port to set
 *           is_acc_port - TRUE if it's access port
 *           is_enable   - TRUE if enable
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : not support trunk !!!
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetVxlanStatusPort(
    UI32_T  unit,
    UI32_T  port,
    BOOL_T  is_acc_port,
    BOOL_T  is_enable)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            DBG_PRINT("STKTPLG_POM_GetMaxPortNumberOnBoard fail");
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
           /* if remote unit
            */
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VXLAN_STATUSPORT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_VXLAN_STATUSPORT;
            isc_buffer_p->unit                  = unit;
            isc_buffer_p->port                  = port;
            isc_buffer_p->info.vxlan_status_port.is_acc_port = is_acc_port;
            isc_buffer_p->info.vxlan_status_port.is_enable   = is_enable;
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif
        {
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalSetVxlanStatusPort(
                    unit, port, is_acc_port, is_enable))
            {
                DBG_PRINT("SWDRV_LocalSetVxlanStatusPort fail");
                return FALSE;
            }
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetVxlanUdpPort
 * -------------------------------------------------------------------------
 * FUNCTION: To set udp dst port for vxlan globally.
 * INPUT   : udp_port - dst port to conifgure
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetVxlanUdpPort(UI32_T udp_port)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VXLAN_UDPPORT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
            */
            isc_buffer_p->ServiceID = SWDRV_SET_VXLAN_UDPPORT;
            isc_buffer_p->info.udp_port = udp_port;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if standalone
         */
        if(!SWDRV_LocalSetVxlanUdpPort(udp_port))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetVxlanPortLearning
 * -------------------------------------------------------------------------
 * FUNCTION: To enable/disable MAC learning for VXLAN port.
 * INPUT   : vxlan_port_id -- Which VXLAN logical port.
 *           is_learning -- TRUE to enable MAC learning.
 *                          FALSE to disable MAC learning.
 * OUTPUT  : none.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetVxlanPortLearning(UI32_T vxlan_port_id, BOOL_T is_learning)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VXLAN_PORT_LEARNING) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
            */
            isc_buffer_p->ServiceID = SWDRV_SET_VXLAN_PORT_LEARNING;
            isc_buffer_p->info.vxlan_port_leaning.vxlan_port_id = vxlan_port_id;
            isc_buffer_p->info.vxlan_port_leaning.is_learning = is_learning;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if standalone
         */
        if(!SWDRV_LocalSetVxlanPortLearning(vxlan_port_id, is_learning))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
}


#endif /* #if (SYS_CPNT_VXLAN == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableIngressFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable ingress filter of a port
 * INPUT   : unit -- which unit to enable
 *           port -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableIngressFilter(UI32_T unit,
                                 UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_INGRESS_FILTER) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable ingress filter of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_INGRESS_FILTER;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableIngressFilter(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_EnableIngressFilter() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableIngressFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable ingress filter of a port
 * INPUT   : unit -- which unit to disable
 *           port -- which port to disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableIngressFilter(UI32_T unit,
                                  UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_INGRESS_FILTER) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable ingress filter of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_INGRESS_FILTER;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }

        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableIngressFilter(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AdmitVLANTaggedFramesOnly
 * -------------------------------------------------------------------------
 * FUNCTION: This function will only allow tagged frames entering a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AdmitVLANTaggedFramesOnly(UI32_T unit,
                                       UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADMIT_VLAN_TAGGED_FRAMES_ONLY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* only admit VLAN Tagged Frame of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADMIT_VLAN_TAGGED_FRAMES_ONLY;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalAdmitVLANTaggedFramesOnly(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AdmitVLANTaggedFramesOnly() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AdmitVLANUntaggedFramesOnly
 * -------------------------------------------------------------------------
 * FUNCTION: This function will only allow untagged frames entering a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AdmitVLANUntaggedFramesOnly(UI32_T unit,
                                         UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADMIT_VLAN_UNTAGGED_FRAMES_ONLY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* only admit VLAN Tagged Frame of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADMIT_VLAN_UNTAGGED_FRAMES_ONLY;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalAdmitVLANUntaggedFramesOnly(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AdmitVLANUntaggedFramesOnly() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AdmitAllFrames

 * -------------------------------------------------------------------------
 * FUNCTION: This function will allow all kinds of frames entering a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AdmitAllFrames(UI32_T unit,
                            UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADMIT_ALL_FRAMES) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* admit all frames of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADMIT_ALL_FRAMES;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalAdmitAllFrames(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AdmitAllFrames() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableTrapUnspecifiedTagFrame

 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable trap unspecified tag frame
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : If chip receives a tagged frame which is not registered in the
 *           system, chip will trap this packet to CPU.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableTrapUnspecifiedTagFrame(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_TRAP_UNSPECIFIED_TAG_FRAME) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable trap unspecified tag frame of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_TRAP_UNSPECIFIED_TAG_FRAME;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableTrapUnspecifiedTagFrame())
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_EnableTrapUnspecifiedTagFrame() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableTrapUnspecifiedTagFrame

 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable trap unspecified tag frame
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableTrapUnspecifiedTagFrame(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_TRAP_UNSPECIFIED_TAG_FRAME) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable trap unspecified tag frame of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_TRAP_UNSPECIFIED_TAG_FRAME;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableTrapUnspecifiedTagFrame())
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_DisableTrapUnspecifiedTagFrame() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddHostToVlan

 * -------------------------------------------------------------------------
 * FUNCTION: This function will add CPU to a specified VLAN
 * INPUT   : vid -- which VLAN to add
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : This is for host to join vlan.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddHostToVlan(UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_HOST_TO_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* add host to vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_ADD_HOST_TO_VLAN;
            isc_buffer_p->vlan_vid  = vid;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalAddHostToVlan(vid))
        {

            return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_AddHostToVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeleteHostFromVlan

 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete CPU from a specified VLAN
 * INPUT   : vid -- which VLAN to delete
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeleteHostFromVlan(UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_HOST_FROM_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* delete host from vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DELETE_HOST_FROM_VLAN;
            isc_buffer_p->vlan_vid  = vid;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDeleteHostFromVlan(vid))
        {

            return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_DeleteHostFromVlan() */

/****************************************************************************/
/* Port Mirroring                                                           */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortMirroring
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set source port to mirror target port
 * INPUT   : from_port  -- which port to mirror
 *           rx_to_port -- which port mirrors the received packets
 *           tx_to_port -- which port mirrors the transmitted packets
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : If rx_to_port set 0, the rx of from_port will not mirror.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortMirroring(SYS_TYPE_Uport_T from_port,
                              SYS_TYPE_Uport_T rx_to_port,
                              SYS_TYPE_Uport_T tx_to_port)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_MIRRORING) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_SET_PORT_MIRRORING;
    isc_buffer_p->port_mirror_src = from_port;
    isc_buffer_p->port_mirror_tx = tx_to_port;
    isc_buffer_p->port_mirror_rx = rx_to_port;

    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {
        return FALSE; /* can't control remote unit */
    }
#endif

    /* if local unit or standalone
     */
    if (!SWDRV_LocalSetPortMirroring(from_port, rx_to_port, tx_to_port))
    {
        return FALSE;
    }

    return TRUE;
} /* End of SWDRV_SetPortMirroring() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeletePortMirroring
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a set of port mirroring
 * INPUT   : from_port  -- as index to delete
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeletePortMirroring(SYS_TYPE_Uport_T from_port , SYS_TYPE_Uport_T to_port)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_PORT_MIRRORING) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_DELETE_PORT_MIRRORING;
    isc_buffer_p->port_mirror_src = from_port;
    isc_buffer_p->port_mirror_rx = to_port;

    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {
        return FALSE; /* can't control remote unit */
    }
#endif

    /* if local unit or standalone
     */
    if (!SWDRV_LocalDeletePortMirroring(from_port,to_port))
    {
        return FALSE;
    }

    return TRUE;
} /* End of SWDRV_DeletePortMirroring() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortMirroring
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the mirroring function
 * INPUT   : from_port -- as index to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortMirroring(SYS_TYPE_Uport_T from_port)
{
#if 0
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit,max_port_number;
    UI16_T              unit_bmp=0;
    UI32_T              stack_id;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)

    if (FALSE == STKTPLG_POM_UnitExist(from_port.unit))
    {

        return FALSE;  /* Unit ID does not existed */
    }

    if (FALSE == STKTPLG_POM_GetMaxPortNumberOnBoard(from_port.unit, &max_port_number))
    {

        return FALSE;
    }

    /*   Remove this part for ES4549-08-00257 by Caesar 2004/10/01
    if (from_port.port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD)
    {

        return FALSE;
    }*/
    /*   If remote unit or optional module
     */
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    if ((from_port.port > max_port_number) || (stack_id != from_port.unit) )
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_MIRRORING) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {

            return FALSE;
        }

        isc_buffer_p->ServiceID         = SWDRV_ENABLE_PORT_MIRRORING;
        isc_buffer_p->port_mirror_src   = from_port;

        if (from_port.port > max_port_number)
        {
            if (STKTPLG_POM_OptionModuleIsExist(from_port.unit, &drv_unit) == TRUE)
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
            }
            else
            {

                return FALSE;
            }
        }
        else
        {
             unit_bmp = SWDRV_UNIT_TO_UNITBMP(from_port.unit);
        }

        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
    }
    else
    {
 #endif
        /* if local or standalone
         */

        if ( SWDRV_LocalEnablePortMirroring(from_port) == FALSE)
        {

            return FALSE;
        }
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/
#endif

    return TRUE;
} /* End of SWDRV_EnablePortMirroring() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortMirroring
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the mirroring function
 * INPUT   : from_port -- as index to disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortMirroring(SYS_TYPE_Uport_T from_port)
{
#if 0
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit,max_port_number;
    UI16_T              unit_bmp=0;
    UI32_T              stack_id;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)

    if (FALSE == STKTPLG_POM_UnitExist(from_port.unit))
    {   /* Unit ID does not existed */

        return FALSE;
    }

    if (FALSE == STKTPLG_POM_GetMaxPortNumberOnBoard(from_port.unit, &max_port_number))
    {

        return FALSE;
    }

    /*  Remove this part for ES4549-08-00258 by Caesar 2004/10/01
    if (from_port.port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD)
    {

        return FALSE;
    }*/

    /*   If remote unit or optional module
     */
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    if ((from_port.port > max_port_number) || ( stack_id != from_port.unit) )
    {
         mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_MIRRORING) /* user_id */ );
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {

            return FALSE;
        }

        /* disable port mirroring of all unit
         */
        isc_buffer_p->ServiceID         = SWDRV_DISABLE_PORT_MIRRORING;
        isc_buffer_p->port_mirror_src   = from_port;

        if (from_port.port > max_port_number)
        {
            if (STKTPLG_POM_OptionModuleIsExist(from_port.unit, &drv_unit) == TRUE)
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
            }
            else
            {

                return FALSE;
            }
        }
        else
        {
             unit_bmp = SWDRV_UNIT_TO_UNITBMP(from_port.unit);
        }

        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }

    }
    else
    {
 #endif
        /* if local or standalone
         */
        if (SWDRV_LocalDisablePortMirroring(from_port) == FALSE)
        {
             /* UIMSG_MGR_SetErrorCode() */

            return FALSE;
        }
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/
#endif

    return TRUE;
} /* End of SWDRV_DisablePortMirroring() */

/****************************************************************************/
/* VLAN Mirroring                                                           */
/****************************************************************************/
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddVlanMirror
 *------------------------------------------------------------------------
 * FUNCTION: This function will add the vlan mirror and destination port
 * INPUT   : unit -- which unit to set
 *           port -- which destination port to set
 *           vid  -- which vlan-id add to source mirrored table
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------*/
BOOL_T SWDRV_AddVlanMirror(UI32_T unit, UI32_T port, UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_VLAN_MIRROR) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_ADD_VLAN_MIRROR;
    isc_buffer_p->vlan_mirror_unit = unit;
    isc_buffer_p->vlan_mirror_vid  = vid;
    isc_buffer_p->vlan_mirror_port = port;

    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {
        return FALSE; /* can't control remote unit */
    }
#endif
    /* if local unit or standalone
     */
    if(!SWDRV_LocalAddVlanMirror(unit, port, vid))
    {
        return FALSE;
    }
    return TRUE;
}/* End of SWDRV_AddVlanMirror() */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeleteVlanMirror
 *------------------------------------------------------------------------
 * FUNCTION: This function will delete the vlan mirror and destination port
 * INPUT   : unit -- which unit to set
 *           port -- which destination port to set
 *           vid  -- which vlan-id add to source mirrored table
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : A destination port shall be removed when source vlan mirror has empty
 *------------------------------------------------------------------------*/
BOOL_T SWDRV_DeleteVlanMirror(UI32_T unit, UI32_T port, UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_VLAN_MIRROR) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_DELETE_VLAN_MIRROR;
    isc_buffer_p->vlan_mirror_unit = unit;
    isc_buffer_p->vlan_mirror_vid  = vid;
    isc_buffer_p->vlan_mirror_port = port;

    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {

        return FALSE; /* can't control remote unit */
    }
#endif
    /* if local unit or standalone
     */
    if(!SWDRV_LocalDeleteVlanMirror(unit, port, vid))
    {
        return FALSE;
    }
    return TRUE;


}/* End of SWDRV_DeleteVlanMirror() */
#endif /* End of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
/* MAC-based mirror is only implemented by rule now,
 * if chip can implement it without rule,
 * move this to SYS_CPNT for all project.
 */
#define SYS_CPNT_MAC_BASED_MIRROR_BY_RULE       TRUE

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMacMirrorEntry
 * -------------------------------------------------------------------------
 * PURPOSE : This function sets MAC based MIRROR
 * INPUT   : mac_address        -- MAC address
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMacMirrorEntry(UI8_T *mac_address)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

#if (SYS_CPNT_MAC_BASED_MIRROR_BY_RULE == TRUE)
    RULE_CTRL_SetMacMirrorEntry(mac_address);
#else
    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MAC_MIRROR_ENTRY) /* user_id */ );
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return FALSE;
        }

        /* enable remote unit port vlan mirror
         */
        isc_buffer_p->ServiceID = SWDRV_SET_MAC_MIRROR_ENTRY;
        memcpy(isc_buffer_p->mac_mirror_mac, mac_address, sizeof(isc_buffer_p->mac_mirror_mac));
        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
#endif
    }
    /* if local unit or standalone
     */
    if(!SWDRV_LocalSetMacMirrorEntry(mac_address))
    {
        return FALSE;
    }
#endif

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeleteMacMirrorEntry
 * -------------------------------------------------------------------------
 * PURPOSE : This function deletes MAC based MIRROR
 * INPUT   : mac_address        -- MAC address
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeleteMacMirrorEntry(UI8_T *mac_address)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

#if (SYS_CPNT_MAC_BASED_MIRROR_BY_RULE == TRUE)
    RULE_CTRL_DeleteMacMirrorEntry(mac_address);
#else
    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_MAC_MIRROR_ENTRY) /* user_id */ );
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return FALSE;
        }

        /* enable remote unit port vlan mirror
         */
        isc_buffer_p->ServiceID = SWDRV_DELETE_MAC_MIRROR_ENTRY;
        memcpy(isc_buffer_p->mac_mirror_mac, mac_address, sizeof(isc_buffer_p->mac_mirror_mac));
        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
    }
#endif
    /* if local unit or standalone
     */
    if(!SWDRV_LocalDeleteMacMirrorEntry(mac_address))
    {
        return FALSE;
    }
#endif

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDestPortForMacMirror
 * -------------------------------------------------------------------------
 * PURPOSE : This function sets destination port for MAC based MIRROR
 * INPUT   : unit -- in which unit
 *           port -- which port to monitor
 *           mode -- TRUE: set, FALSE: remove
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDestPortForMacMirror(UI32_T unit, UI32_T port, BOOL_T mode)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DEST_PORT_FOR_MAC_MIRROR) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_SET_DEST_PORT_FOR_MAC_MIRROR;
    isc_buffer_p->set_mirror_dest_port_unit = unit;
    isc_buffer_p->set_mirror_dest_port_port = port;
    isc_buffer_p->set_mirror_dest_port_mode = mode;
    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {

        return FALSE; /* can't control remote unit */
    }
#endif
    /* if local unit or standalone
     */
    if(!SWDRV_LocalSetDestPortForMacMirror(unit, port, mode))
    {
        return FALSE;
    }
    return TRUE;
}
#endif /* #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

#if (SYS_CPNT_ACL_MIRROR == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDestPortForAclMirror
 * -------------------------------------------------------------------------
 * PURPOSE : This function sets destination port for ACL based MIRROR
 * INPUT   : unit -- in which unit
 *           port -- which port to monitor
 *           mode -- TRUE: set, FALSE: remove
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDestPortForAclMirror(UI32_T unit, UI32_T port, BOOL_T mode)
{
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if remote unit
     */
#if (SYS_CPNT_STACKING == TRUE && SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DEST_PORT_FOR_MAC_MIRROR) /* user_id */ );
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return FALSE;
    }

    /* enable remote unit port vlan mirror
     */
    isc_buffer_p->ServiceID = SWDRV_SET_DEST_PORT_FOR_ACL_MIRROR;
    isc_buffer_p->set_mirror_dest_port_unit = unit;
    isc_buffer_p->set_mirror_dest_port_port = port;
    isc_buffer_p->set_mirror_dest_port_mode = mode;
    if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
    {

        return FALSE; /* can't control remote unit */
    }
#endif
    /* if local unit or standalone
     */
    if(!SWDRV_LocalSetDestPortForAclMirror(unit, port, mode))
    {
        return FALSE;
    }
    return TRUE;
}
#endif /* (SYS_CPNT_ACL_MIRROR == TRUE) */

/****************************************************************************/
/* Trunking                                                                 */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_CreateTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create a trunking port
 * INPUT   : trunk_id -- which trunk id to create
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_CreateTrunk(UI32_T trunk_id)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
        return FALSE;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if(unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_CREATE_TRUNK) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_CREATE_TRUNK;
            isc_buffer_p->trunking_id   = trunk_id;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
           {

               return FALSE; /* can't control remote unit */
           }
        }
#endif
        if(!SWDRV_LocalCreateTrunk(trunk_id))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_CreateTrunk() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DestroyTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: This function will destroy a trunking port
 * INPUT   : trunk_id -- which trunking port to destroy
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DestroyTrunk(UI32_T trunk_id)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
        return FALSE;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DESTROY_TRUNK) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* delete trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_DESTROY_TRUNK;
            isc_buffer_p->trunking_id   = trunk_id;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDestroyTrunk(trunk_id))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_DestroyTrunk() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetTrunkPorts
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add members to a trunking port
 * INPUT   : trunk_id       -- which trunking port to add member
 *           port_count     -- how many members
 *           port_list      -- the member list
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : We will set the lowest port as the broadcast_port.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetTrunkPorts(UI32_T trunk_id,
                           UI32_T port_count,
                           SYS_TYPE_Uport_T *port_member)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
        return FALSE;

    if(port_count > SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK)
        return FALSE;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRUNK_PORTS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* Distributed Trunk
             * 1. Trunk member modification should notice each unit (include local).
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_TRUNK_PORTS;
            isc_buffer_p->trunking_id           = trunk_id;
            isc_buffer_p->trunking_port_count   = port_count;
            memcpy(isc_buffer_p->trunking_port_member, port_member, sizeof(SYS_TYPE_Uport_T)*SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalSetTrunkPorts(trunk_id, port_count, port_member))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_SetTrunkPorts() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetTrunkInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the trunk memeber information
 * INPUT   : ifindex               -- which interface index
 * OUTPUT  : trunk_port_ext_info   -- trunk information
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : only for Led_drv
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetTrunkInfo(UI32_T ifindex, SWDRV_Trunk_Info_T *trunk_port_info)
{
    UI32_T trunk_id;

    if((ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER) || (ifindex >  SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER + SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
        return FALSE ;


    trunk_id = ifindex  - SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER + 1 ;
    SWDRV_OM_GetTrunkInfo(trunk_id, trunk_port_info);

    return TRUE;
}/* End of SWDRV_GetPortType () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetTrunkBalanceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the mode of trunking
 * INPUT   : mode -- Egressport selection criterion
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : the egressport is determinded by following criteria :
 *           SWDRV_TRUNK_MAC_SA      Determinded by source mac address
 *           SWDRV_TRUNK_MAC_DA      Determinded by destination mac address
 *           SWDRV_TRUNK_MAC_SA_DA   Determinded by source and destination mac address
 *           SWDRV_TRUNK_IP_SA       Determinded by source IP address
 *           SWDRV_TRUNK_IP_DA       Determinded by destination IP address
 *           SWDRV_TRUNK_IP_SA_DA    Determinded by source and destination IP address
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetTrunkBalanceMode(UI32_T mode)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if(unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRUNK_BALANCE_MODE) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_SET_TRUNK_BALANCE_MODE;
            isc_buffer_p->info.general_32_bits   = mode;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
           {

               return FALSE; /* can't control remote unit */
           }
        }
#endif
        if(!SWDRV_LocalSetTrunkBalanceMode(mode))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
}

/****************************************************************************/
/* IGMP Functions                                                           */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableIgmpTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable IGMP packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableIgmpTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_IGMP_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable igmp trap of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_IGMP_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/
        if(!SWDRV_LocalEnableIgmpTrap())
        {

            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_EnableIgmpTrap() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableIgmpTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable IGMP packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableIgmpTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_IGMP_TRAP)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable igmp trap of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_IGMP_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/
        if(!SWDRV_LocalDisableIgmpTrap())
        {

            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_DisableIgmpTrap() */

/****************************************************************************/
/* DHCP Functions                                                           */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapDhcpServerPacket
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable DHCP server packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapDhcpServerPacket(BOOL_T to_cpu, BOOL_T flood)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_TRAP_DHCP_SERVER_PACKET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable dhcp server trap of all unit
             */

            isc_buffer_p->ServiceID  = SWDRV_TRAP_DHCP_SERVER_PACKET;
            isc_buffer_p->info.packet_trap_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_info.flood = flood;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/

        if(!SWDRV_LocalTrapDhcpServerPacket(to_cpu, flood))
        {
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_EnableDhcpServerPacketTrap() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapDhcpClientPacket
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable DHCP client packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapDhcpClientPacket(BOOL_T to_cpu, BOOL_T flood)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_TRAP_DHCP_CLIENT_PACKET) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable dhcp client trap of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_TRAP_DHCP_SERVER_PACKET;
            isc_buffer_p->info.packet_trap_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_info.flood = flood;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/
        if(!SWDRV_LocalTrapDhcpClientPacket(to_cpu, flood))
        {

            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_EnableDhcpClientPacketTrap() */

#if ((SYS_CPNT_DHCPV6SNP == TRUE)||(SYS_CPNT_DHCPV6 == TRUE))
/****************************************************************************/
/* DHCP6 Functions                                                           */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapDhcp6ServerPacket
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable DHCP6 server packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapDhcp6ServerPacket(BOOL_T to_cpu, BOOL_T flood)
{
    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2Cpu(TRUE, RULE_TYPE_PacketType_DHCP6_SERVER, &rule_info);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapDhcp6ClientPacket
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable DHCP6 client packet to trap to CPU
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapDhcp6ClientPacket(BOOL_T to_cpu, BOOL_T flood)
{
    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2Cpu(TRUE, RULE_TYPE_PacketType_DHCP6_CLIENT, &rule_info);
}
#endif /* SYS_CPNT_DHCPV6SNP */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetOrgSpecificTrap
 * -------------------------------------------------------------------------
 * PURPOSE : Set how to trap organization specific packets.
 * INPUT   : to_cpu - whether packet is trapped to CPU
 *           flood  - whether packet is flooded
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetOrgSpecificTrap(BOOL_T to_cpu, BOOL_T flood)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp = 0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_ORG_SPECIFIC_TRAP) /* user_id */);

            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);
            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* enable org specific trap of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_SET_ORG_SPECIFIC_TRAP;
            isc_buffer_p->info.packet_trap_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_info.flood = flood;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID, mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/

        if (!SWDRV_LocalSetOrgSpecificTrap(to_cpu, flood))
        {
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_SetOrgSpecificTrap */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddMulticastAddrToTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will force a multicast address always go specified
 *           trunk member port while doing load balance.
 * INPUT   : mac          -- the multicast address
 *           vid          -- which VLAN
 *           trunk_id     -- join to which trunk
 *           trunk_member -- which port to add
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : (unit, port) is trunk port member
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddMulticastAddrToTrunkMember(UI8_T *mac,
                                           UI32_T vid,
                                           UI32_T trunk_id,
                                           SYS_TYPE_Uport_T trunk_member)
{
    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
        return FALSE;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != trunk_member.unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;
            UI32_T              max_port_number;

            if (FALSE == STKTPLG_POM_UnitExist(trunk_member.unit))
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_MULTICAST_ADDR_TO_TRUNK_MEMBER) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable a port of remote unit
             */
            isc_buffer_p->ServiceID         = SWDRV_ADD_MULTICAST_ADDR_TO_TRUNK_MEMBER;
            isc_buffer_p->trunking_id       = trunk_id;
            isc_buffer_p->trunking_member   = trunk_member;
            memcpy(isc_buffer_p->trunking_mac, mac, sizeof(isc_buffer_p->trunking_mac));

            if (STKTPLG_POM_GetMaxPortNumberOnBoard(trunk_member.unit, &max_port_number) == FALSE)
            {

                return FALSE;
            }

            if (trunk_member.port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(trunk_member.unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(trunk_member.unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif  /*SYS_CPNT_STACKING*/
            /* if local unit or standalone
             */
            if ( SWDRV_LocalAddMulticastAddrToTrunkMember(mac,vid,trunk_id,trunk_member) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_AddMulticastAddrToTrunkMember() */

/*******************************************************************************
 *  SWDRV_SetUnknownIPMcastFwdPortList
 *
 * Purpose: Set the unknown multicast packet forwarding-to port list.
 * Inputs:
 *   unit           - which unit to set
 *   port_list      - on which the multicast packets allow to forward-to
 * Outputs:
 * Return:
 *   TRUE/FALSE
 * Note: For those ASIC can not support this function, this service shall be
 *       ignored.
 *       In StrataSwitch, the API will impact all kinds of packets (L2/L3).
 *******************************************************************************
 */
BOOL_T SWDRV_SetUnknownIPMcastFwdPortList(UI32_T unit, UI8_T port_list[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST])
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;
            UI32_T            max_port_number;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_UNKNOWN_IP_MCAST_FWD_PORTLIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_UNKNOWN_IP_MCAST_FWD_PORTLIST;
            isc_buffer_p->unit      = unit;
            memcpy(isc_buffer_p->unknown_mcast_fwd_port_list, port_list, SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

            if (FALSE == STKTPLG_POM_UnitExist(unit))
            {

                return FALSE;
            }

            /* step 1: check any option port exist */

            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
            {

                return FALSE;
            }

            if (port_list[max_port_number/8] != 0)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp |= SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }

            /* step 2: set remote unit */
            unit_bmp |= SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetUnknownIPMcastFwdPortList (port_list) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetUnknownIPMcastFwdPortList() */


/****************************************************************************/
/* Broadcast/Multicast Storm Control                                        */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetBroadcastStormControlThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the threshold of broadcast
 *           storm control of a port
 * INPUT   : unit      -- which unit to set
 *           port      -- which port to set
 *           threshold -- control threshold
 *           mode      -- storm mode, one of
 *                        DEV_SWDRV_STORM_CTRL_MODE_PACKET_RATE
 *                        DEV_SWDRV_STORM_CTRL_MODE_BYTE_RATE
 *                        DEV_SWDRV_STORM_CTRL_MODE_PERCENTAGE
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : For Broadcom ASICs, currently only support packet rate mode
 *           threshold : 0 - 17bit packets/sec
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetBroadcastStormControlThreshold(UI32_T unit,
                                               UI32_T port,
                                               UI32_T threshold,
                                               UI32_T mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {

#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_BROADCAST_STORM_CONTROL_THRESHOLD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID                 = SWDRV_SET_BROADCAST_STORM_CONTROL_THRESHOLD;
                isc_buffer_p->unit                      = unit;
                isc_buffer_p->port                      = port;
                isc_buffer_p->storm_control_threshold   = threshold;
                isc_buffer_p->storm_control_mode        = mode;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetBroadcastStormControlThreshold(unit, port, threshold, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_SetBroadcastStormControlThreshold() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMulticastStormControlThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the threshold of multicast
 *           storm control of a port
 * INPUT   : unit      -- which unit to set
 *           port      -- which port to set
 *           threshold -- control threshold
 *           mode      -- storm mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : threshold : 0 - 17bit packets/sec
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMulticastStormControlThreshold(UI32_T unit,
                                               UI32_T port,
                                               UI32_T threshold,
                                               UI32_T mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)
            UI32_T              drv_unit;
    #endif
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID                 = SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD;
                isc_buffer_p->unit                      = unit;
                isc_buffer_p->port                      = port;
                isc_buffer_p->storm_control_threshold   = threshold;
                isc_buffer_p->storm_control_mode        = mode;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetMulticastStormControlThreshold(unit, port, threshold, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_SetMulticastStormControlThreshold() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetUnknownUnicastStormControlThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the threshold of multicast
 *           storm control of a port
 * INPUT   : unit      -- which unit to set
 *           port      -- which port to set
 *           threshold -- control threshold
 *           mode      -- storm mode, one of
 *                        DEV_SWDRV_STORM_CTRL_MODE_PACKET_RATE
 *                        DEV_SWDRV_STORM_CTRL_MODE_BYTE_RATE
 *                        DEV_SWDRV_STORM_CTRL_MODE_PERCENTAGE
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : threshold : 0 - 17bit packets/sec
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetUnknownUnicastStormControlThreshold(UI32_T unit,
                                               UI32_T port,
                                               UI32_T threshold,
                                               UI32_T mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)
            UI32_T              drv_unit;
    #endif
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID                 = SWDRV_SET_UNKNOWN_UNICAST_STORM_CONTROL_THRESHOLD;
                isc_buffer_p->unit                      = unit;
                isc_buffer_p->port                      = port;
                isc_buffer_p->storm_control_threshold   = threshold;
                isc_buffer_p->storm_control_mode        = mode;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetUnknownUnicastStormControlThreshold(unit, port, threshold, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_SetUnknownUnicastStormControlThreshold() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableBroadcastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable broadcast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableBroadcastStormControl(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;


        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_BROADCAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_ENABLE_BROADCAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if(SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableBroadcastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_EnableBroadcastStormControl() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableBroadcastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable broadcast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableBroadcastStormControl(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif/*#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_BROADCAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_DISABLE_BROADCAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableBroadcastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_DisableBroadcastStormControl() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableMulticastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable multicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableMulticastStormControl(UI32_T unit,
                                         UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
          )
#endif /*End of #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
            UI32_T              drv_unit;
    #endif

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_ENABLE_MULTICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableMulticastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_EnableMulticastStormControl() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableMulticastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable multicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableMulticastStormControl(UI32_T unit,
                                          UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
          )
#endif /*End of #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
            UI32_T              drv_unit;
    #endif
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_DISABLE_MULTICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))*/
        }
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableMulticastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_DisableMulticastStormControl() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableUnknownUnicastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable unknown unicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableUnknownUnicastStormControl(UI32_T unit,
                                              UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
          )
#endif /*End of #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
            UI32_T              drv_unit;
    #endif

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_ENABLE_UNKNOWN_UNICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableUnknownUnicastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableUnknownUnicastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable unknown unicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableUnknownUnicastStormControl(UI32_T unit,
                                               UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
          )
#endif /*End of #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
    #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
            UI32_T              drv_unit;
    #endif
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_DISABLE_UNKNOWN_UNICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))*/
        }
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableUnknownUnicastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortStormGranularity
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get granularity of a port
 * INPUT   : unit       -- which unit to set
 *           port       -- which port to set
 *           mode       -- storm mode, one of
 *                         VAL_bcastStormSampleType_pkt_rate
 *                         VAL_bcastStormSampleType_octet_rate
 *                         VAL_bcastStormSampleType_percent
 * OUTPUT  : granularity -- granularity of a port
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortStormGranularity(UI32_T unit, UI32_T port, UI32_T mode, UI32_T *granularity)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_DOT1Q_TUNNEL_TPID) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }
            isc_buffer_p->ServiceID = SWDRV_GET_PORT_STORM_GRANULARITY; //SWDRV_GET_PORT_DOT1Q_TUNNEL_TPID;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->info.general_32_bits= mode;
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *granularity = isc_reply.data.u32;
        }
        else
#endif /*SYS_CPNT_STACKING*/
        {
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortStormGranularity(unit, port, mode, granularity))
            {
                 /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
        }
    }
    return TRUE;
}
/****************************************************************************/
/* ATC Broadcast/Multicast Storm Control                                    */
/****************************************************************************/
#if (SYS_CPNT_ATC_BSTORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetATCBroadcastStormControlThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the threshold of auto traffic control broadcast
 *           storm control of a port
 * INPUT   : unit      -- which unit to set
 *           port      -- which port to set
 *           threshold -- control threshold
 *           mode      -- storm mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : threshold : 0 - 17bit packets/sec
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetATCBroadcastStormControlThreshold(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T threshold,
                                                  UI32_T mode)
{
/* TODO: wakka: dont change parameter validity here, should remove it.
 */
#ifndef MARVELL_CPSS
    if (threshold > 0x3ffff) /* the limitation of Broadcom chip */
        return FALSE;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {

#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }
    #if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_ATC_BROADCAST_STORM_CONTROL_THRESHOLD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID                 = SWDRV_SET_ATC_BROADCAST_STORM_CONTROL_THRESHOLD;
                isc_buffer_p->unit                      = unit;
                isc_buffer_p->port                      = port;
                isc_buffer_p->storm_control_threshold   = threshold;
                isc_buffer_p->storm_control_mode        = mode;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */

            if ( SWDRV_LocalSetATCBroadcastStormControlThreshold(unit, port, threshold, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_SetATCBroadcastStormControlThreshold() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableATCBroadcastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable auto traffic control broadcast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableATCBroadcastStormControl(UI32_T unit,
                                            UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_ATC_BROADCAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {
                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_ENABLE_ATC_BROADCAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if(SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableATCBroadcastStormControl(unit, port) == FALSE)
            {
                return FALSE;
            }
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_EnableATCBroadcastStormControl() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableATCBroadcastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable auto traffic control broadcast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableATCBroadcastStormControl(UI32_T unit,
                                             UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {

#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif/*#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_ATC_BROADCAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_DISABLE_ATC_BROADCAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableATCBroadcastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_DisbleATCBroadcastStormControl() */
#endif



#if (SYS_CPNT_ATC_MSTORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetATCMulticastStormControlThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the threshold of auto traffic control multicast
 *           storm control of a port
 * INPUT   : unit      -- which unit to set
 *           port      -- which port to set
 *           threshold -- control threshold
 *           mode      -- storm mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : threshold : 0 - 17bit packets/sec
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetATCMulticastStormControlThreshold(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T threshold,
                                                  UI32_T mode)
{
/* TODO: wakka: dont change parameter validity here, should remove it.
 */
#ifdef BROADCOM
if (threshold > 0x3ffff) /* the limitation of Broadcom chip */
        return FALSE;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {

#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }
    #if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_ATC_MULTICAST_STORM_CONTROL_THRESHOLD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID                 = SWDRV_SET_ATC_MULTICAST_STORM_CONTROL_THRESHOLD;
                isc_buffer_p->unit                      = unit;
                isc_buffer_p->port                      = port;
                isc_buffer_p->storm_control_threshold   = threshold;
                isc_buffer_p->storm_control_mode        = mode;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetATCMulticastStormControlThreshold(unit, port, threshold, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_SetATCMulticastStormControlThreshold() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableATCMulticastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable auto traffic control multicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableATCMulticastStormControl(UI32_T unit,
                                            UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif /* #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_ATC_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {
                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_ENABLE_ATC_MULTICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if(SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalEnableATCMulticastStormControl(unit, port) == FALSE)
            {
                return FALSE;
            }
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_EnableATCMulticastStormControl() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableATCMulticastStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable auto traffic control multicast storm control function of
 *           a port
 * INPUT   : unit -- which unit to set
 *           port -- which port to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableATCMulticastStormControl(UI32_T unit,
                                             UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {

#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||
         (port > max_port_number))
    #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
    #endif
        )
#endif /*End of #if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
        {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
    #if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
    #else
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
    #endif/*#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == TRUE)*/
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_ATC_MULTICAST_STORM_CONTROL) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                /* set broadcast storm control threshold of remote unit
                 */
                isc_buffer_p->ServiceID = SWDRV_DISABLE_ATC_MULTICAST_STORM_CONTROL;
                isc_buffer_p->unit      = unit;
                isc_buffer_p->port      = port;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
#endif /*#if (SYS_CPNT_STACKING == TRUE)*/
        }
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        else
        {
#endif
            /* if local unit or standalone
             */
            if ( SWDRV_LocalDisableATCMulticastStormControl(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == TRUE)
        }
#endif
    }

    return TRUE;
} /* End of SWDRV_DisableATCMulticastStormControl() */
#endif





/****************************************************************************/
/* Quality of Service                                                       */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortUserDefaultPriority
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set user default priority
 * INPUT   : unit     -- which unit to set
 *           port     -- which port to set
 *           priority -- user default priority to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortUserDefaultPriority(UI32_T unit,
                                        UI32_T port,
                                        UI32_T priority)
{
    if((priority < 0) || (priority > 7))
        return FALSE;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_USER_DEFAULT_PRIORITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port user default priority of remote unit
             */
            isc_buffer_p->ServiceID     = SWDRV_SET_PORT_USER_DEFAULT_PRIORITY;
            isc_buffer_p->unit          = unit;
            isc_buffer_p->port          = port;
            isc_buffer_p->qos_priority  = priority;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortUserDefaultPriority(unit, port,priority) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetPortUserDefaultPriority() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPriorityMapping
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set priority mapping of 10/100 ports
 * INPUT   : mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPriorityMapping(UI32_T unit,
                                UI32_T port,
                                UI8_T mapping[8])
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PRIORITY_MAPPING) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port user default priority of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PRIORITY_MAPPING;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            memcpy(isc_buffer_p->qos_mapping, mapping, sizeof(isc_buffer_p->qos_mapping));

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPriorityMapping(unit, port,mapping) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetPriorityMapping() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPriorityMappingPerSystem
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set priority mapping for per system
 * INPUT   : dot1p_to_cos_mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPriorityMappingPerSystem(UI8_T *dot1p_to_cos_mapping)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
 #if (SYS_CPNT_STACKING == TRUE)
        {
            UI16_T              unit_bmp=0;

            unit_bmp = SWDRV_GetValidDrvUnitBmp();
            if (unit_bmp!=0)
            {
                L_MM_Mref_Handle_T* mref_handle_p;
                SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                UI32_T              pdu_len;

                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PRIORITY_MAPPING_PER_SYSTEM) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }

                isc_buffer_p->ServiceID          = SWDRV_SET_PRIORITY_MAPPING_PER_SYSTEM;
                memcpy(isc_buffer_p->qos_mapping,dot1p_to_cos_mapping,(MAX_dot1dTrafficClassPriority+1-MIN_dot1dTrafficClassPriority));
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
        }
 #endif
        if(!SWDRV_LocalSetPriorityMappingPerSystem(dot1p_to_cos_mapping))
        {

            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_SetPriorityMappingPerSystem() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetStackingPortPriorityMapping
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the priority mapping of stacking port
 * INPUT   : mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
#if (SYS_CPNT_STACKING == TRUE)
BOOL_T SWDRV_SetStackingPortPriorityMapping(UI32_T unit,
                                            UI32_T port,
                                            UI8_T mapping[8])
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_STACKING_PORT_PRIORITY_MAPPING) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set port user default priority of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_STACKING_PORT_PRIORITY_MAPPING;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            memcpy(isc_buffer_p->qos_mapping,mapping,sizeof(isc_buffer_p->qos_mapping));

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetStackingPortPriorityMapping(unit, port,mapping)== FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
} /* End of SWDRV_SetStackingPortPriorityMapping() */
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
/*****************************
 * Traffic Segematation APIs *
 *****************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableTrafficSegematation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the traffic segematation
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableTrafficSegmatation()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_TRAFFIC_SEGMATATION) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable traffic segmatation of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_TRAFFIC_SEGMATATION;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableTrafficSegmatation())
        {

             return FALSE;
        }

        return TRUE;
    }
} /* End of BOOL_T SWDRV_EnableTrafficSegmatation () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableTrafficSegmatation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the traffic segmatation
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableTrafficSegmatation()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
         /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_TRAFFIC_SEGMATATION) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable traffic segmatation of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_TRAFFIC_SEGMATATION;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableTrafficSegmatation())
        {

            return FALSE;
        }

        return TRUE;
    }
} /* End of BOOL_T SWDRV_DisablePrivateVlan () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetTrafficSegmatation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan
 * INPUT   : uplink_port_list  -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetTrafficSegmatation( SYS_TYPE_Uport_T    *uplink_uport_list,
                                    UI32_T              uplink_uport_list_cnt,
                                    SYS_TYPE_Uport_T    *downlink_uport_list,
                                    UI32_T              downlink_uport_list_cnt
                                   )
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_SET_TRAFFIC_SEGMATATION;
            memcpy(isc_buffer_p->traffic_segematation_uplink_uport_list, uplink_uport_list, sizeof(SYS_TYPE_Uport_T)*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);
            memcpy(isc_buffer_p->traffic_segematation_downlink_uport_list, downlink_uport_list, sizeof(SYS_TYPE_Uport_T)*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);
            isc_buffer_p->traffic_segematation_uplink_uport_count = uplink_uport_list_cnt;
            isc_buffer_p->traffic_segematation_downlink_uport_count = downlink_uport_list_cnt;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalSetTrafficSegmatation(uplink_uport_list, uplink_uport_list_cnt, downlink_uport_list, downlink_uport_list_cnt))
        {

            return FALSE;
        }

        return TRUE;
    }
} /* End of BOOL_T SWDRV_SetTrafficSegmatation () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_ResetTrafficSegmatation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will reset the context of traffic segmatation
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_ResetTrafficSegmatation()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_RESET_TRAFFIC_SEGMATATION) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* reset private vlan of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_RESET_TRAFFIC_SEGMATATION;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalResetTrafficSegmatation())
        {

             return FALSE;
        }

        return TRUE;
    }
}/* End of SWDRV_ResetTrafficSegmatation () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetTrafficSegmatationByPortlist
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan
 * INPUT   : uplink_port_list  -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetTrafficSegmatationByPortlist(UI8_T *uplink_port_list,
                                             UI8_T *downlink_port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST;
            memcpy(isc_buffer_p->traffic_segematation_by_port_list_uplink_port_list, uplink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(isc_buffer_p->traffic_segematation_by_port_list_downlink_port_list, downlink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalSetTrafficSegmatationByPortlist(uplink_port_list, downlink_port_list))
        {

             return FALSE;
        }

        return TRUE;
    }
} /* End of SWDRV_SetTrafficSegmatationByPortlist() */
#endif /* End of SYS_CPNT_PORT_TRAFFIC_SEGMENTATION is TRUE */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPrivateVlanPortlistBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan by session group
 * INPUT   : session_id         -- session id to pvlan group
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPrivateVlanPortlistBySessionId(UI32_T session_id,
                                               UI8_T  *uplink_port_list,
                                               UI8_T  *downlink_port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PRIVATE_VLAN_PORTLIST_SID;
            isc_buffer_p->private_vlan_port_list_by_session_group_session_id = session_id;
            memcpy(isc_buffer_p->private_vlan_port_list_by_session_group_uplink_port_list, uplink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(isc_buffer_p->private_vlan_port_list_by_session_group_downlink_port_list, downlink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalSetPrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list))
        {

             return FALSE;
        }

        return TRUE;
    }
}/* End of SWDRV_SetPrivateVlanPortlistBySessionId() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeletePrivateVlanPortlistBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete the private vlan by session group
 * INPUT   : session_id         -- session id to pvlan group
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeletePrivateVlanPortlistBySessionId(UI32_T session_id,
                                               UI8_T  *uplink_port_list,
                                               UI8_T  *downlink_port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DELETE_PRIVATE_VLAN_PORTLIST_SID;
            isc_buffer_p->private_vlan_port_list_by_session_group_session_id = session_id;
            memcpy(isc_buffer_p->private_vlan_port_list_by_session_group_uplink_port_list, uplink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(isc_buffer_p->private_vlan_port_list_by_session_group_downlink_port_list, downlink_port_list, sizeof(UI8_T) * SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalDeletePrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list))
        {

             return FALSE;
        }

        return TRUE;
    }
}/* End of SWDRV_DeletePrivateVlanPortlistBySessionId() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable blocking traffic of uplink ports
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalEnablePrivateVlanUplinkToUplinkBlockingMode())
        {

             return FALSE;
        }

        return TRUE;
    }
}/* End of SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable blocking traffic of uplink ports
 *           so every traffic can be forwarding different uplink ports
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PRIVATE_VLAN_UPLINKTOUPLINK_BLOCKING_MODE;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalDisablePrivateVlanUplinkToUplinkBlockingMode())
        {

             return FALSE;
        }

        return TRUE;
    }
}/* End of SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPrivateVlanTrunkMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set status of private vlan of trunk id
 * INPUT   : session_id
 *           trunk_id
 *           is_uplink
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPrivateVlanTrunkMode(UI32_T session_id, UI32_T trunk_id, BOOL_T is_uplink)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_TRAFFIC_SEGMATATION_BY_PORT_LIST) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set private vlan of all unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PRIVATE_VLAN_TRUNK_MODE;
            isc_buffer_p->info.u32_u32_b.u32_a1 = session_id;
            isc_buffer_p->info.u32_u32_b.u32_a2 = trunk_id;
            isc_buffer_p->info.u32_u32_b.bool_a1 = is_uplink;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if (!SWDRV_LocalSetPrivateVlanTrunkMode(session_id, trunk_id, is_uplink))
        {

             return FALSE;
        }

        return TRUE;
    }
}
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
/*******************
 * Rate Limit APIs *
 *******************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the port ingress rate limit
 * INPUT   : unit , port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortIngressRateLimit(UI32_T unit, UI32_T port)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_INGRESS_RATE_LIMIT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_INGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if(!SWDRV_LocalEnablePortIngressRateLimit(unit, port))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}/* End of SWDRV_EnablePortIngressRateLimit () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the port ingress rate limit
 * INPUT   : unit , port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

       SWDRV_OM_GetSystemInfoStackId(&stack_id);
       if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_INGRESS_RATE_LIMIT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_INGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->ratelimit_trunkid = trunk_id;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if(!SWDRV_LocalDisablePortIngressRateLimit(unit, port, trunk_id))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}/* End of SWDRV_DisablePortIngressRateLimit () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port ingress rate limit
 * INPUT   : unit -- unit id
 *           port -- which port to set
 *           rate -- port ingress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/

BOOL_T SWDRV_SetPortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id, UI32_T rate)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_INGRESS_RATE_LIMIT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_INGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->ratelimit_trunkid = trunk_id;
            isc_buffer_p->ratelimit = rate;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortIngressRateLimit(unit, port, trunk_id, rate) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}/* End of SWDRV_SetPortIngressRateLimit () */
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
/*******************
 * Rate Limit APIs *
 *******************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the port egress rate limit
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortEgressRateLimit(UI32_T unit, UI32_T port)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_EGRESS_RATE_LIMIT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_EGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnablePortEgressRateLimit(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the port egress rate limit
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortEgressRateLimit(UI32_T unit, UI32_T port)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
       if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
             if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_EGRESS_RATE_LIMIT) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_EGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
 #endif
            /* if local unit or standalone
             */
            if  (SWDRV_LocalDisablePortEgressRateLimit(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port gress rate limit
 * INPUT   : unit -- unit id
 *           port -- which port to set
 *           rate -- port ingress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortEgressRateLimit(UI32_T unit, UI32_T port, UI32_T rate)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

         SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( (( stack_id != unit ) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
             if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_EGRESS_RATE_LIMIT) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set remote unit port egress rate limit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_EGRESS_RATE_LIMIT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->ratelimit = rate;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
 #endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortEgressRateLimit(unit, port,rate) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
/********************
 * Jumbo Frame APIs *
 ********************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableJumboFrame
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the jumbo frame
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableJumboFrame()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_JUMBO_FRAME) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable jambo frame of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_JUMBO_FRAME;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableJumboFrame())
        {

            return FALSE;
        }

        return TRUE;
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableJumboFrame
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the jumbo frame
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableJumboFrame()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
         /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_JUMBO_FRAME) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable jambo frame of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_JUMBO_FRAME;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableJumboFrame())
        {

             return FALSE;
        }

        return TRUE;
    }
}
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set active medium type for combo port
 * INPUT   : unit           -- unit id
 *           port           -- which port to set
 *           forcedmode     -- forcedfiber / forcedcopper / autodetecfiber / autodeteccopper
 *           fiber_speed    -- which speed (VAL_portType_hundredBaseFX/VAL_portType_thousandBaseSfp)
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
BOOL_T SWDRV_SetPortComboForcedMode(UI32_T unit, UI32_T port, UI32_T forcedmode, UI32_T fiber_speed)
#else
BOOL_T SWDRV_SetPortComboForcedMode(UI32_T unit, UI32_T port, UI32_T forcedmode)
#endif
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              drv_unit, max_port_number;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
         if ( (( stack_id != unit ) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_FORCED_MODE)  /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set remote combo port forced mode
             */
            isc_buffer_p->ServiceID         = SWDRV_SET_PORT_FORCED_MODE;
            isc_buffer_p->unit              = unit;
            isc_buffer_p->port              = port;
            isc_buffer_p->combo_forcedmode  = forcedmode;
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
            isc_buffer_p->combo_forced_mode_speed = fiber_speed;
#endif


            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
 #endif
            /* if local unit or standalone
             */
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
            if (SWDRV_LocalSetPortComboForcedMode(unit, port, forcedmode, fiber_speed) == FALSE)
#else
            if (SWDRV_LocalSetPortComboForcedMode(unit, port, forcedmode) == FALSE)
#endif
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_HotSwapInsert
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a hot swap module is inserted
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_HotSwapInsert(UI32_T unit, UI32_T port)
{
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
#endif

#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_HOT_SWAP_INSERT) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }
        /* notify hot swap insert to master
         */
        isc_buffer_p->ServiceID     = SWDRV_HOT_SWAP_INSERT;
        isc_buffer_p->unit          = unit;
        isc_buffer_p->port          = port;
        isc_buffer_p->option_module = 0;
        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif

    SYS_CALLBACK_MGR_SWDRV_HotSwapInsert(SYS_MODULE_SWDRV, unit, port);
#if 0
    /* if standalone of master unit
     */
        for(fun_list=HotSwapInsert_callbacklist; fun_list; fun_list=fun_list->next)
            fun_list->func(unit, port);
#endif

#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/

} /* End of SWDRV_Notify_HotSwapInsert() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_HotSwapRemove
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a hot swap module is removed
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_HotSwapRemove(UI32_T unit, UI32_T port)
{
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
#endif

#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_HOT_SWAP_REMOVE) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }
        /* notify hot swap remove to master
         */
        isc_buffer_p->ServiceID     = SWDRV_HOT_SWAP_REMOVE;
        isc_buffer_p->unit          = unit;
        isc_buffer_p->port          = port;
        isc_buffer_p->option_module = 0;

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif

    SYS_CALLBACK_MGR_SWDRV_HotSwapRemove(SYS_MODULE_SWDRV, unit, port);
#if 0
    /* if standalone of master unit
     */
        for(fun_list=HotSwapRemove_callbacklist; fun_list; fun_list=fun_list->next)
            fun_list->func(unit, port);
#endif
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/

} /* End of SWDRV_Notify_HotSwapRemove() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortLinkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Master notify port link status to upper layer
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This function is only called in Master.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortLinkStatus2UpperLayer()
{

    UI32_T unit_index ;
    UI32_T pooling_index = 0;
    UI32_T unit;
    UI32_T stack_id;
    UI8_T  array_index;
    UI8_T  bit_index;
    UI32_T start_port;
    UI32_T end_port;
    UI8_T  changed_bitmap;
    UI32_T swdrv_receive_events = 0;
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_LinkStatus_T link_status;

    SYSFUN_ReceiveEvent (SWDRV_EVENT_UPDATE_PORT_LINK_STATUS,
                         SYSFUN_EVENT_WAIT_ANY,
                         SYSFUN_TIMEOUT_NOWAIT,/* timeout */
                         &swdrv_receive_events);

    if (!(swdrv_receive_events & SWDRV_EVENT_UPDATE_PORT_LINK_STATUS))
    {
        return;
    }

    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    SWDRV_OM_GetSystemInfoStackId(&stack_id);

    /* There are "swdrv_system_info.num_of_units" units in stacking.
     */
    for (unit_index=0; unit_index<swdrv_system_info.num_of_units;unit_index++)
    {
        unit = swdrv_system_info.stack_unit_tbl[unit_index];

#if (SYS_CPNT_HW_LINKSCAN == TRUE)
        /* To speed up link up notification,
         * following procedure for Master unit had been moved to SWDRV_LocalUpdatePortLinkStatus
         */
        if (unit == stack_id)
        {
            continue;
        }
#endif

        /* check eack element of array bitmap of this unit.
         */
        for (pooling_index = 0; pooling_index <SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST; pooling_index++)
        {
            memset(&link_status, 0, sizeof(SWDRV_LinkStatus_T));
            SWDRV_OM_GetPortLinkStatusBitmaps(unit, &link_status);
            changed_bitmap = link_status.link_st_bitmap[pooling_index]
                                   ^link_status.previous_link_st_bitmap[pooling_index];
            if (changed_bitmap)
            {
                /* if previous array element(previous_link_st_bitmap[pooling_index]) and
                 * new array element(link_st_bitmap[pooling_index]) are different.
                 * Check each bit in array element.
                 */
                start_port = pooling_index * 8 + 1;
                end_port = start_port + 7;
                for (; start_port <= end_port ;start_port++)
                {
                    array_index = SWDRV_LPORT_INDEX(start_port);
                    bit_index = SWDRV_LPORT_BIT_IN_UI8_T(start_port);

                    if (changed_bitmap& bit_index)
                    {
                        if (link_status.link_st_bitmap[array_index]& bit_index)
                        {
                            /* update previous port link status bit
                             */
                            link_status.previous_link_st_bitmap[array_index] |= bit_index;
                            SWDRV_OM_SetPortLinkStatusBitmaps(unit, &link_status, SWDRV_OM_F_ANNOUNCED);
                            SWDRV_Notify_PortLinkUp(unit, start_port);
                        }
                        else
                        {
                            link_status.previous_link_st_bitmap[array_index] &= (~bit_index);
                            SWDRV_OM_SetPortLinkStatusBitmaps(unit, &link_status, SWDRV_OM_F_ANNOUNCED);
                            SWDRV_Notify_PortLinkDown(unit, start_port);
                        }
                    }/*End if (changed_bitmap& bit_index)*/
                }/*End for (; start_port <= end_port ;start_port++)*/
            }/*End if (changed_bitmap)*/
        }/*End for (pooling_index = 0; pooling_index <SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST; pooling_index++)*/
    }/*End for (unit_index=0; unit_index<swdrv_system_info.num_of_units;unit_index++)*/

    return;

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortLinkStatus2Master
 * -------------------------------------------------------------------------
 * FUNCTION: Slave notify Master port link status vis ISC.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This API is only called in Slave.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortLinkStatus2Master()
{
#if 1
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI32_T              array_index;
    UI16_T              unit_bmp=0;
    UI8_T               master_unit_id;
    BOOL_T              is_port_link_status_changed=FALSE;
    SWDRV_LinkStatus_T link_status;
    SWDRV_Switch_Info_T swdrv_system_info;

    memset(&swdrv_system_info, 0, sizeof(SWDRV_Switch_Info_T));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    memset(&link_status, 0, sizeof(SWDRV_LinkStatus_T));
    SWDRV_OM_GetPortLinkStatusBitmaps(swdrv_system_info.stack_id, &link_status);

    for (array_index=0;array_index<(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);array_index++)
    {
        if (link_status.link_st_bitmap[array_index]
           ^link_status.previous_link_st_bitmap[array_index])
        {
            is_port_link_status_changed = TRUE;
            break;
        }
    }

    if (!is_port_link_status_changed)
    {
        return;
    }

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_LINK_STATUS) /* user_id */);
    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

    if (isc_buffer_p==NULL)
    {
        return;
    }
    /* notify port link status to master
         */
    isc_buffer_p->ServiceID         = SWDRV_PORT_LINK_STATUS;
    /* Mainboard and Module have the same stack_id
     */
    isc_buffer_p->unit              = swdrv_system_info.stack_id;
    /* In BLANC, base_port_id of Mainboard is 1; Module is 25 or 49
     */
    isc_buffer_p->port              = swdrv_system_info.base_port_id;
    /* We use this variable to indicate port number of Mainboard(Module).
     * In BLANC, port number of Mainboard is 24 or 48; Module is 8
     */
    isc_buffer_p->option_num_port   = swdrv_system_info.port_number;

    memcpy(isc_buffer_p->info.new_link_st_bitmap , link_status.link_st_bitmap, sizeof(UI8_T)*(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST));

    /* Update previous link status bitmap (before ISC).
     * If we update bitmap after ISC, the good point is
     * "If ISC fail, bitmap won't be updated. Task will send again next time."
     * But it has sid effect. If port link status is changed again before task re-send.
     * Task will think the port link status is no change. The change event will be lost.
     * For example,               status1   status2
     * link_st_bitmap           :     1   ->   0
     * previous_link_st_bitmap  :     0(isc fail, previous_link_st_bitmap won't be updated.)
     * port status is changed to link up (status1), but task send isc fail.
     * the previous bitmap won't be updated to 1(still 0).
     * If port status is changed to link down(status2), link_st_bitmap and previous_link_st_bitmap are the same.
     * Task won't notify link status to Master. The link up(status1) event is lost.
     */


    STKTPLG_POM_GetMasterUnitId(&master_unit_id);
    unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
    if(ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                             mref_handle_p,
                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        return;
  /*add by fen.wang 2008-7-3
PRBOBLEM:master will always get ISC msg about link state from slave althoug slave no change
ROOT CAUSE: after slave notify master the link state,it not set it to the previouse state
SOLUTION:keep the state to the previous state for the next new change
Files:swdrv.c
APPLYD BY:hard sun      */
     memcpy(link_status.previous_link_st_bitmap,link_status.link_st_bitmap,SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
     SWDRV_OM_SetPortLinkStatusBitmaps(swdrv_system_info.stack_id, &link_status, SWDRV_OM_F_ANNOUNCED);
    return;
#endif /*SYS_CPNT_STACKING*/
#endif
    }

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is up
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This API is only called in Master.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortLinkUp(UI32_T unit, UI32_T port)
{
    SYS_CALLBACK_MGR_SWDRV_PortLinkUp(SYS_MODULE_SWDRV, unit, port);
#if 0
    SYS_TYPE_CallBack_T  *fun_list;

    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_MASTER_MODE)
    {
        for(fun_list=PortLinkUp_callbacklist; fun_list; fun_list=fun_list->next)
        {
            fun_list->func(unit, port);
        }
    }
#endif
} /* End of SWDRV_Notify_PortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is down
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This API is only called in Master.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortLinkDown(UI32_T unit, UI32_T port)
{
    SYS_CALLBACK_MGR_SWDRV_PortLinkDown(SYS_MODULE_SWDRV, unit, port);

#if 0
    SYS_TYPE_CallBack_T  *fun_list;

    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_MASTER_MODE)
    {
        for(fun_list=PortLinkDown_callbacklist; fun_list; fun_list=fun_list->next)
        {
            fun_list->func(unit, port);
        }
    }
#endif
} /* End of SWDRV_Notify_PortLinkDown() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_CraftPortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is up
 * INPUT   : unit -- in which unit
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This API is only called in Master.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_CraftPortLinkUp(UI32_T unit)
{
    SYS_CALLBACK_MGR_SWDRV_CraftPortLinkUp(SYS_MODULE_SWDRV, unit);
} /* End of SWDRV_Notify_CraftPortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_CraftPortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is down
 * INPUT   : unit -- in which unit
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This API is only called in Master.
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_CraftPortLinkDown(UI32_T unit)
{
    SYS_CALLBACK_MGR_SWDRV_CraftPortLinkDown(SYS_MODULE_SWDRV, unit);
} /* End of SWDRV_Notify_PortLinkDown() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortTypeChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port type is changed
 * INPUT   : unit       -- in which unit
 *           port       -- which port
 *           port_type  -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : Reference leaf_es3526a.mib
 *          -- #define VAL_portType_other   1L
 *          -- #define VAL_portType_hundredBaseTX   2L
 *          -- #define VAL_portType_hundredBaseFX   3L
 *          -- #define VAL_portType_thousandBaseSX  4L
 *          -- #define VAL_portType_thousandBaseLX  5L
 *          -- #define VAL_portType_thousandBaseT   6L
 *          -- #define VAL_portType_thousandBaseGBIC    7L
 *          -- #define VAL_portType_thousandBaseMiniGBIC    8L
 * -------------------------------------------------------------------------*/
static void SWDRV_Notify_PortTypeChanged(UI32_T unit, UI32_T port, UI32_T port_type)
{
    SWDRV_Notify_ModuleTypeChanged(unit, port, 0, port_type);
}

static void SWDRV_Notify_ModuleTypeChanged(UI32_T unit, UI32_T port, UI32_T module_id, UI32_T port_type)
{
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
#endif

#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_TYPE_CHANGED) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }
        /* notify port type changed to master
         */
        isc_buffer_p->ServiceID         = SWDRV_PORT_TYPE_CHANGED;
        isc_buffer_p->unit              = unit;
        isc_buffer_p->port              = port;
        isc_buffer_p->option_module     = 0;
        isc_buffer_p->event_port_type   = port_type;
        isc_buffer_p->event_module_id   = module_id;

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif

        SYS_CALLBACK_MGR_SWDRV_PortTypeChanged(SYS_MODULE_SWDRV, unit, port, module_id, port_type);
#if 0
        /* if standalone of master unit
         */
        for(fun_list=PortTypeChanged_callbacklist; fun_list; fun_list=fun_list->next)
            fun_list->func(unit, port, port_type);
#endif

#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/
} /* End of SWDRV_Notify_ModuleTypeChanged () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the speed/duplex status of a port
 *           is changed
 * INPUT   : unit -- in which unit
 *           port -- which port
 *           speed_duplex -- new status of speed/duplex
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortSpeedDuplex(UI32_T unit,
                                         UI32_T port,
                                         UI32_T speed_duplex)
{
    SWDRV_Port_Info_T swdrv_port_info;

    memset(&swdrv_port_info, 0, sizeof(SWDRV_Port_Info_T));
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
#endif

#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_CFG_SPEED_DUPLEX) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }
        /* notify port speed duplex to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_CFG_SPEED_DUPLEX;
        isc_buffer_p->unit               = unit;
        isc_buffer_p->port               = port;
        isc_buffer_p->option_module      = 0;
        isc_buffer_p->event_speed_duplex = speed_duplex;

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif

        SYS_CALLBACK_MGR_SWDRV_PortSpeedDuplex(SYS_MODULE_SWDRV, unit, port, speed_duplex);
#if 0  /* linux use another procedure for callback */
        /* if standalone of master unit
         */
        for(fun_list=PortSpeedDuplex_callbacklist; fun_list; fun_list=fun_list->next)
            fun_list->func(unit, port, speed_duplex);
#endif

#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/

} /* End of SWDRV_Notify_PortSpeedDuplex() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortFlowCtrl
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the flow control status of a port
 *           is changed
 * INPUT   : unit -- in which unit
 *           port -- which port
 *           flow_ctrl -- new status of flow control
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWDRV_Notify_PortFlowCtrl(UI32_T unit,
                                      UI32_T port,
                                      UI32_T flow_ctrl)
{
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
#endif

#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_FLOW_CONTROL) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return;
        }
        /* notify port speed duplex to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_FLOW_CONTROL;
        isc_buffer_p->unit               = unit;
        isc_buffer_p->port               = port;
        isc_buffer_p->option_module      = 0;
        isc_buffer_p->event_flow_control = flow_ctrl;

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif

        SYS_CALLBACK_MGR_SWDRV_PortFlowCtrl(SYS_MODULE_SWDRV, unit, port, flow_ctrl);
#if 0
        /* if standalone of master unit
         */
        for(fun_list=PortFlowCtrl_callbacklist; fun_list; fun_list=fun_list->next)
            fun_list->func(unit, port, flow_ctrl);
#endif

#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/

} /* End of SWDRV_Notify_PortFlowCtrl() */

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortSfpPresent
 * -------------------------------------------------------------------------
 * FUNCTION: Notify upper layer when the sfp present status of a port
 *           is changed
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
void SWDRV_Notify_PortSfpPresent(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              array_index;
        UI16_T              unit_bmp=0;
        UI8_T               master_unit_id;
        BOOL_T              is_port_sfp_present_status_changed = FALSE;
        SWDRV_TYPE_SfpPresentStatus_T sfp_present_status;
        SWDRV_Switch_Info_T swdrv_system_info;

        memset(&swdrv_system_info, 0, sizeof(SWDRV_Switch_Info_T));
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        memset(&sfp_present_status, 0, sizeof(SWDRV_TYPE_SfpPresentStatus_T));
        SWDRV_OM_GetPortSfpPresentStatusBitmaps(swdrv_system_info.stack_id, &sfp_present_status);

        for(array_index=0;array_index<(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);array_index++)
        {
            if(sfp_present_status.sfp_present_st_bitmap[array_index]
               ^sfp_present_status.previous_sfp_present_st_bitmap[array_index])
            {
                is_port_sfp_present_status_changed = TRUE;
                break;
            }
        }

        if(!is_port_sfp_present_status_changed)
        {
            return;
        }

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                            L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SFP_PRESENT_STATUS) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if(isc_buffer_p == NULL)
        {
            return;
        }
        /* notify port sfp present status to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_SFP_PRESENT_STATUS;
        isc_buffer_p->unit               = swdrv_system_info.stack_id;
        isc_buffer_p->port               = swdrv_system_info.base_port_id;
        isc_buffer_p->option_num_port    = swdrv_system_info.port_number;
        memcpy(isc_buffer_p->info.new_sfp_present_st_bitmap, sfp_present_status.sfp_present_st_bitmap, sizeof(UI8_T)*(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST));

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        if(ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            return;
        memcpy(sfp_present_status.previous_sfp_present_st_bitmap,sfp_present_status.sfp_present_st_bitmap,SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
        SWDRV_OM_SetPortSfpPresentStatusBitmaps(swdrv_system_info.stack_id, &sfp_present_status, SWDRV_OM_F_ANNOUNCED);
        return;
    }
    else
    {
#endif
        SWDRV_Notify_LocalPortSfpPresent();
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif /*SYS_CPNT_STACKING*/
} /* End of SWDRV_Notify_PortSfpPresent() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortSfpInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Notify upper layer when the sfp eeprom  of a port is changed
 * INPUT   : unit
 *           sfp_index
 *           sfp_info_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
void SWDRV_Notify_PortSfpInfo(UI32_T unit, UI32_T sfp_index, SWDRV_TYPE_SfpInfo_T *sfp_info_p)
{
#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T*   mref_handle_p;
        SWDRV_Rx_IscBuf_T*    isc_buffer_p;
        UI32_T                pdu_len;
        UI16_T                unit_bmp = 0;
        UI8_T                 master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                            L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SFP_INFO) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if(isc_buffer_p == NULL)
        {
            return;
        }
        /* notify port speed duplex to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_SFP_INFO;
        isc_buffer_p->unit               = unit;
        isc_buffer_p->port               = sfp_index;
        isc_buffer_p->option_module      = 0;
        memcpy(&(isc_buffer_p->info.sfp_info), sfp_info_p, sizeof(SWDRV_TYPE_SfpInfo_T));

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                              mref_handle_p,
                              SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                              SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return;
    }
    else
    {
#endif
        if(SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_INFO))
            BACKDOOR_MGR_Printf("%s(%d): sfp_index:%lu\r\n", __FUNCTION__, __LINE__, (unsigned long)sfp_index);
        SYS_CALLBACK_MGR_SWDRV_PortSfpInfo(SYS_MODULE_SWDRV, unit, sfp_index, sfp_info_p);
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif/*SYS_CPNT_STACKING*/

}/* End of SWDRV_Notify_PortSfpInfo() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortSfpDdmInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Notify upper layer when the sfp DDM eeprom of a port is changed
 * INPUT   : unit
 *           sfp_index
 *           sfp_ddm_info_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
void SWDRV_Notify_PortSfpDdmInfo(UI32_T unit, UI32_T sfp_index, SWDRV_TYPE_SfpDdmInfo_T *sfp_ddm_info_p)
{
#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T*   mref_handle_p;
        SWDRV_Rx_IscBuf_T*    isc_buffer_p;
        UI32_T                pdu_len;
        UI16_T                unit_bmp = 0;
        UI8_T                 master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                            L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SFP_DDM_INFO) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if(isc_buffer_p == NULL)
        {
            return;
        }
        /* notify port speed duplex to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_SFP_DDM_INFO;
        isc_buffer_p->unit               = unit;
        isc_buffer_p->port               = sfp_index;
        isc_buffer_p->option_module      = 0;
        memcpy(&(isc_buffer_p->info.sfp_ddm_info), sfp_ddm_info_p, sizeof(SWDRV_TYPE_SfpDdmInfo_T));

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                              mref_handle_p,
                              SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                              SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return;
    }
    else
    {
#endif
        SYS_CALLBACK_MGR_SWDRV_PortSfpDdmInfo(SYS_MODULE_SWDRV, unit, sfp_index, sfp_ddm_info_p);
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif/*SYS_CPNT_STACKING*/
}/* End of SWDRV_Notify_PortSfpDdmInfo() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_PortSfpDdmInfoMeasured
 * -------------------------------------------------------------------------
 * FUNCTION: Notify upper layer when the sfp DDM measured eeprom info
 *           of a port is changed
 * INPUT   : unit
 *           sfp_index
 *           sfp_ddm_info_measured_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
void SWDRV_Notify_PortSfpDdmInfoMeasured(UI32_T unit, UI32_T sfp_index, SWDRV_TYPE_SfpDdmInfoMeasured_T *sfp_ddm_info_measured_p)
{
#if (SYS_CPNT_STACKING == TRUE)
    /* if slave unit
     */
    if(SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T*   mref_handle_p;
        SWDRV_Rx_IscBuf_T*    isc_buffer_p;
        UI32_T                pdu_len;
        UI16_T                unit_bmp=0;
        UI8_T                 master_unit_id;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SFP_DDM_INFO_MEASURED) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if(isc_buffer_p == NULL)
        {
            return;
        }
        /* notify port speed duplex to master
         */
        isc_buffer_p->ServiceID          = SWDRV_PORT_SFP_DDM_INFO_MEASURED;
        isc_buffer_p->unit               = unit;
        isc_buffer_p->port               = sfp_index;
        isc_buffer_p->option_module      = 0;
        memcpy(&(isc_buffer_p->info.sfp_ddm_info.measured), sfp_ddm_info_measured_p, sizeof(SWDRV_TYPE_SfpDdmInfoMeasured_T));

        STKTPLG_POM_GetMasterUnitId(&master_unit_id);
        unit_bmp = SWDRV_UNIT_TO_UNITBMP(master_unit_id);
        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);
        return ;
    }
    else
    {
#endif
        SYS_CALLBACK_MGR_SWDRV_PortSfpDdmInfoMeasured(SYS_MODULE_SWDRV, unit, sfp_index, sfp_ddm_info_measured_p);
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif/*SYS_CPNT_STACKING*/

}/* End of SWDRV_Notify_PortSfpDdmInfoMeasured() */
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_ShutdownSwitch
 *------------------------------------------------------------------------
 * FUNCTION: This function will shutdown the switch before warm start
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *------------------------------------------------------------------------*/
void SWDRV_ShutdownSwitch(void)
{
    DEV_SWDRV_PMGR_ShutdownSwitch();
} /* end of SWDRV_ShutdownSwitch */

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_RemoteSetQueuingScheduling(
        UI32_T service_id, UI32_T method, UI32_T q_id, UI32_T weight)
{
    UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

    if (unit_bmp != 0)
    {
        UI32_T             pdu_len;
        L_MM_Mref_Handle_T *mref_handle_p;
        SWDRV_Rx_IscBuf_T  *isc_buffer_p;

        mref_handle_p = L_MM_AllocateTxBuffer(
                sizeof(SWDRV_Rx_IscBuf_T),
                L_MM_USER_ID2(SYS_MODULE_SWDRV, service_id));

        isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

        if (isc_buffer_p == NULL)
        {
            return FALSE;
        }

        isc_buffer_p->ServiceID        = service_id;

        isc_buffer_p->egress_method    = method;
        isc_buffer_p->wrr_queue_id     = q_id;
        isc_buffer_p->wrr_queue_weight = weight;

        if (ISC_SendMcastReliable(
                    unit_bmp, ISC_SWDRV_SID, mref_handle_p,
                    SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                    SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortEgressSchedulingMethod
 *------------------------------------------------------------------------------
 * FUNCTION: This function will set port egress scheduling mothod
 * INPUT   : method   -- strict / wrr / drr / strict-drr / strict-wrr
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetEgressSchedulingMethod(UI32_T method)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)
    if (SWDRV_RemoteSetQueuingScheduling(
            SWDRV_SET_EGRESS_SCHEDULING_METHOD, method, 0, 0) == FALSE)
    {
        printf("[%s:%u] failed\n", __FUNCTION__, __LINE__);
        return FALSE;
    }
#endif

    return SWDRV_LocalSetEgressSchedulingMethod(method);
}
#else
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortEgressSchedulingMethod
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port egress scheduling mothod
 * INPUT   : unit     -- which unit to set
 *           port     -- which port to set
 *           method   -- strict / wrr / drr / strict-drr / strict-wrr
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortEgressSchedulingMethod(UI32_T unit, UI32_T port, UI32_T method)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;
        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
         (port > max_port_number))
        #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
        #endif
          )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            if (port > max_port_number)
            {
                UI32_T              drv_unit;
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_EGRESS_SCHEDULING_METHOD) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                isc_buffer_p->ServiceID     = SWDRV_SET_PORT_EGRESS_SCHEDULING_METHOD;
                isc_buffer_p->egress_method = method;
                isc_buffer_p->port          = port;
                isc_buffer_p->unit          = unit;
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
        }
        else
        {
#endif

            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetPortEgressSchedulingMethod(unit, port, method) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif
    }

    return TRUE;
}
#endif

#if 0
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortWrrQueueWeight
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable port the WRR queue weight
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortWrrQueueWeight()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_WRR_QUEUE_WEIGHT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable port wrr weight of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_PORT_WRR_QUEUE_WEIGHT;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnablePortWrrQueueWeight())
        {

            return FALSE;
        }

        return TRUE;
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortWrrQueueWeight
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the WRR queue weight function
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortWrrQueueWeight()
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
         /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_WRR_QUEUE_WEIGHT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable wrr weight of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_PORT_WRR_QUEUE_WEIGHT;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisablePortWrrQueueWeight())
        {

            return FALSE;
        }

        return TRUE;
    }
}
#endif

#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetWrrQueueWeight
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the WRR queue weight
 * INPUT   : q_id -- in which queue
 *           weight -- the weight value to be set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetWrrQueueWeight(UI32_T q_id, UI32_T weight)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)
    if (SWDRV_RemoteSetQueuingScheduling(
            SWDRV_SET_WRR_QUEUE_WEIGHT, 0, q_id, weight) == FALSE)
    {
        printf("[%s:%u] failed\n", __FUNCTION__, __LINE__);
        return FALSE;
    }
#endif

    return SWDRV_LocalSetWrrQueueWeight(q_id, weight);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetStrictPriorityQueue
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the strict priority queue
 * INPUT   : q_id -- in which queue
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetStrictPriorityQueue(UI32_T q_id)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)
    if (SWDRV_RemoteSetQueuingScheduling(
            SWDRV_SET_STRICT_PRIORITY_QUEUE, 0, q_id, 0) == FALSE)
    {
        printf("[%s:%u] failed\n", __FUNCTION__, __LINE__);
        return FALSE;
    }
#endif

    return SWDRV_LocalSetStrictPriorityQueue(q_id);
}
#else
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortWrrQueueWeight
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the WRR queue weight
 * INPUT   : unit -- in which unit
 *           port -- in which port
 *           q_id -- in which queue
 *           weight -- the weight value to be set
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : It's not only used for wrr weight, but also drr weight now (2008-06-05, Jinfeng.Chen)
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortWrrQueueWeight(UI32_T unit, UI32_T port, UI32_T q_id, UI32_T weight)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        if ( ((stack_id != unit) ||
         (port > max_port_number))
        #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
        #endif
          )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_WRR_QUEUE_WEIGHT)/* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                isc_buffer_p->ServiceID         = SWDRV_SET_PORT_WRR_QUEUE_WEIGHT;
                isc_buffer_p->wrr_queue_id      = q_id;
                isc_buffer_p->wrr_queue_weight  = weight;
                isc_buffer_p->unit              = unit;
                isc_buffer_p->port              = port;

                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {

                    return FALSE; /* can't control remote unit */
                }
            }
        }
        else
        {
#endif

            /* if local unit or standalone
             */
            if ( SWDRV_LocalSetPortWrrQueueWeight(unit, port,q_id,weight) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif
    }

    return TRUE;
}
#endif

#if (SYS_CPNT_PORT_SECURITY == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortSecurity
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable port security
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnablePortSecurity(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_SECURITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable port security of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_SECURITY;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnablePortSecurity(unit, port) ==FALSE)
            {
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisablePortSecurity
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable port security
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisablePortSecurity(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

       SWDRV_OM_GetSystemInfoStackId(&stack_id);
       if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_PORT_SECURITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port security of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_PORT_SECURITY;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }

        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalDisablePortSecurity(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_PortSecurityActionNone
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable port security active status.
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_PortSecurityActionNone(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SECURITY_ACTION_NONE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port security of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_SECURITY_ACTION_NONE;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalPortSecurityActionNone(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_PortSecurityActionTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable port security active trap status.
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_PortSecurityActionTrap(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SECURITY_ACTION_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port security of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_SECURITY_ACTION_TRAP;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalPortSecurityActionTrap(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_PortSecurityActionShutdown
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable port security active shutdown status.
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_PortSecurityActionShutdown(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SECURITY_ACTION_SHUTDOWN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable port security of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_SECURITY_ACTION_SHUTDOWN;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalPortSecurityActionShutdown(unit, port) == FALSE)
            {

                return FALSE;
            }
            return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_PortSecurityActionTrapAndShutdown
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable port security active trap and shutdown status.
 * INPUT   : unit -- in which unit
 *           port -- in which port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_PortSecurityActionTrapAndShutdown(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_SECURITY_ACTION_TRAP_AND_SHUTDOWN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* port security action trap and shutdown of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_SECURITY_ACTION_TRAP_AND_SHUTDOWN;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalPortSecurityActionTrapAndShutdown(unit, port) == FALSE)
            {

                return FALSE;
            }

#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableIPMC
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable IPMC
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableIPMC(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_IPMC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable IPMC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_IPMC;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalDisableIPMC())
        {

             return FALSE;
        }

        return TRUE;
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableIPMC
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable IPMC
 * INPUT   : unit -- which unit to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableIPMC(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_IPMC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable IPMC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_IPMC;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalEnableIPMC())
        {

            return FALSE;
        }

        return TRUE;
    }
}

#if (SYS_CPNT_MAU_MIB == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortRestartAutoNego
 * -------------------------------------------------------------------------
 * FUNCTION: To triger PHY to re-start auto-nego.
 * INPUT   : unit -- Which unit.
 *           port -- Which port.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortRestartAutoNego (UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_RESTART_AUTO_NEGO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_RESTART_AUTO_NEGO;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalSetPortRestartAutoNego(unit, port))
            {
                 /* UIMSG_MGR_SetErrorCode() */

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortAutoNegoRemoteFaultAdvertisement
 * -------------------------------------------------------------------------
 * FUNCTION: Set auto-nego remote fault advertisement bits.
 * INPUT   : unit         -- Which unit.
 *           port         -- Which port.
 *           remote_fault -- VAL_ifMauAutoNegRemoteFaultAdvertised_noError
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_offline
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_linkFailure
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_autoNegError
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T remote_fault)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID   = SWDRV_SET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT;
            isc_buffer_p->unit        = unit;
            isc_buffer_p->port        = port;
            isc_buffer_p->general_32_bits_parameter = remote_fault;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalSetPortAutoNegoRemoteFaultAdvertisement(unit, port, remote_fault))
            {
                 /* UIMSG_MGR_SetErrorCode() */

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortAutoNegoRemoteFaultAdvertisement
 * -------------------------------------------------------------------------
 * FUNCTION: Set auto-nego remote fault advertisement bits.
 * INPUT   : unit         -- Which unit.
 *           port         -- Which port.
 * OUTPUT  : remote_fault -- VAL_ifMauAutoNegRemoteFaultAdvertised_noError
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_offline
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_linkFailure
 *                           VAL_ifMauAutoNegRemoteFaultAdvertised_autoNegError
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T *remote_fault)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        /* if remote unit
         */
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT;
            isc_buffer_p->port                      = port;
            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *remote_fault = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortAutoNegoRemoteFaultAdvertisement(unit, port, remote_fault))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortLinkPartnerAutoNegoSignalingState
 * -------------------------------------------------------------------------
 * FUNCTION: Get the status if link partner in auto-nego signaling state.
 * INPUT   : unit  -- Which unit.
 *           port  -- Which port.
 * OUTPUT  : state -- VAL_ifMauAutoNegRemoteSignaling_detected
 *                    VAL_ifMauAutoNegRemoteSignaling_notdetected
 * RETURN  : TRUE/FALSE
 * NOTE    : If the link state is link-down, VAL_ifMauAutoNegRemoteSignaling_notdetected
 *           shall be outputed.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortLinkPartnerAutoNegoSignalingState (UI32_T unit, UI32_T port, UI32_T *state)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_SIGNALING_STATE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_SIGNALING_STATE;
            isc_buffer_p->unit                      = unit;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *state = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortLinkPartnerAutoNegoSignalingState(unit, port, state))
            {
                 /* UIMSG_MGR_SetErrorCode() */

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }


    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortAutoNegoProcessState
 * -------------------------------------------------------------------------
 * FUNCTION: Get the status of auto-nego process.
 * INPUT   : unit  -- Which unit.
 *           port  -- Which port.
 * OUTPUT  : state -- VAL_ifMauAutoNegConfig_other
 *                    VAL_ifMauAutoNegConfig_configuring
 *                    VAL_ifMauAutoNegConfig_complete
 *                    VAL_ifMauAutoNegConfig_disabled
 *                    VAL_ifMauAutoNegConfig_parallelDetectFail
 * RETURN  : TRUE/FALSE
 * NOTE    : In this API, check "auto-nego" enable/disable first, if disabled
 *           return, then check "parallel detect fail", if true, return.
 *           Finally check status is "configuring" or "complete".
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortAutoNegoProcessState (UI32_T unit, UI32_T port, UI32_T *state)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_AUTO_NEGO_PROCESS_STATE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_AUTO_NEGO_PROCESS_STATE;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *state = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortAutoNegoProcessState(unit, port, state))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortLinkPartnerAutoNegoCapa
 * -------------------------------------------------------------------------
 * FUNCTION: Get the auto-nego capability bits of link partner.
 * INPUT   : unit -- Which unit.
 *           port -- Which port.
 * OUTPUT  : capabilities -- bitmap:
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_bOther      )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b10baseT    )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b10baseTFD  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b100baseT4  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b100baseTX  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b100baseTXFD)
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b100baseT2  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b100baseT2FD)
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_bFdxPause   )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_bFdxAPause  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_bFdxSPause  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_bFdxBPause  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b1000baseX  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b1000baseXFD)
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b1000baseT  )
 *                           (1 << VAL_ifMauAutoNegCapReceivedBits_b1000baseTFD)
 * RETURN  : TRUE/FALSE
 * NOTE    : If the link state is link-down, only (1 << VAL_ifMauAutoNegCapReceivedBits_bOther)
 *           shall be outputed.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortLinkPartnerAutoNegoCapa (UI32_T unit, UI32_T port, UI32_T *capabilities)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )

        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_CAPA) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_CAPA;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *capabilities = isc_reply.data.u32;
        }
        else
        {;
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortLinkPartnerAutoNegoCapa(unit, port, capabilities))
            {
                 /* UIMSG_MGR_SetErrorCode() */

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortLinkPartnerAutoNegoRemoteFault
 * -------------------------------------------------------------------------
 * FUNCTION: Get the auto-nego remote fault of link partner.
 * INPUT   : unit -- Which unit.
 *           port -- Which port.
 * OUTPUT  : remote fault -- VAL_ifMauAutoNegRemoteFaultReceived_noError
 *                           VAL_ifMauAutoNegRemoteFaultReceived_offline
 *                           VAL_ifMauAutoNegRemoteFaultReceived_linkFailure
 *                           VAL_ifMauAutoNegRemoteFaultReceived_autoNegError
 *
 * RETURN  : TREU/FALSE
 * NOTE    : If the link state is link-down, VAL_ifMauAutoNegRemoteFaultReceived_noError
 *           shall be outputed.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortLinkPartnerAutoNegoRemoteFault (UI32_T unit, UI32_T port, UI32_T *remote_fault)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_REMOTE_FAULT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_REMOTE_FAULT;
            isc_buffer_p->unit                      = unit;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *remote_fault = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortLinkPartnerAutoNegoRemoteFault(unit, port, remote_fault))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

#if (SYS_HWCFG_SUPPORT_PD==TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPDPortStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Get the status of the PD port
 * INPUT   : unit  -- Which unit.
 *           port  -- Which port.
 *           status_p-- SWDRV_POWER_SOURCE_NONE
 *                      SWDRV_POWER_SOURCE_UP
 *                      SWDRV_POWER_SOURCE_UP
 *           mode_p  -- SWDRV_POWERED_DEVICE_MODE_NONE
 *                      SWDRV_POWERED_DEVICE_MODE_AF
 *                      SWDRV_POWERED_DEVICE_MODE_AT
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : The status of the ports with POE PD capability would show "UP"
 *           when the link partner is a PSE port.
 * -------------------------------------------------------------------------*/

BOOL_T SWDRV_GetPDPortStatus(UI32_T unit, UI32_T port, UI8_T *status_p, UI8_T *mode_p)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PD_PORT_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }
            isc_buffer_p->ServiceID                 = SWDRV_GET_PD_PORT_STATUS;
            isc_buffer_p->unit                      = unit;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *status_p = isc_reply.data.pd_info.status;
            *mode_p = isc_reply.data.pd_info.mode;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPDPortStatus(unit, port, status_p, mode_p))
            {
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }
    return TRUE;
}
#endif/*SYS_HWCFG_SUPPORT_PD*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortJabberState
 * -------------------------------------------------------------------------
 * FUNCTION: Get the status if the port in jabbering state.
 * INPUT   : unit  -- Which unit.
 *           port  -- Which port.
 * OUTPUT  : state -- VAL_ifMauJabberState_other
 *                    VAL_ifMauJabberState_unknown
 *                    VAL_ifMauJabberState_noJabber
 *                    VAL_ifMauJabberState_jabbering
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortJabberState (UI32_T unit, UI32_T port, UI32_T *state)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_JABBER_STATE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_JABBER_STATE;
            isc_buffer_p->unit                      = unit;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *state = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortJabberState(unit, port, state))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortFalseCarrierSenseCounter
 * -------------------------------------------------------------------------
 * FUNCTION: Get the counter of the false carrier sense.
 * INPUT   : unit -- Which unit.
 *           port -- Which port.
 * OUTPUT  : cntr -- Just cunter.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortFalseCarrierSenseCounter (UI32_T unit, UI32_T port, UI32_T *cntr)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }
        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI8_T               dst_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_AMTRDRV, SWDRV_GET_PORT_FALSE_CARRIER_SENSE_COUNTER) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID                 = SWDRV_GET_PORT_FALSE_CARRIER_SENSE_COUNTER;
            isc_buffer_p->unit                      = unit;
            isc_buffer_p->port                      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    dst_unit = drv_unit;
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                dst_unit = unit;
            }

            if (!ISC_RemoteCall((UI8_T)dst_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            *cntr = isc_reply.data.u32;
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalGetPortFalseCarrierSenseCounter(unit, port, cntr))
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}
#endif

#if (SYS_CPNT_OSPF == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableOSPFTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to enable OSPF trap.
 * INPUT   : cpu_mac - CPU MAC address.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableOSPFTrap(UI8_T *cpu_mac)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_OSPF_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_OSPF_TRAP;
            memcpy(isc_buffer_p->cpu_mac_addr, cpu_mac, sizeof(isc_buffer_p->cpu_mac_addr));
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableOSPFTrap(cpu_mac))
        {

            return FALSE;
        }

        return TRUE;
    }
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableOSPFTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to disable OSPF trap.
 * INPUT   : CPU MAC address.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableOSPFTrap(UI8_T *cpu_mac)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_OSPF_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create vlan id of remote all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_OSPF_TRAP;
            memcpy(isc_buffer_p->cpu_mac_addr, cpu_mac, sizeof(isc_buffer_p->cpu_mac_addr));
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableOSPFTrap(cpu_mac))
        {

            return FALSE;
        }

        return TRUE;
    }
}
#endif

#if (SYS_CPNT_DOT1X == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDot1xAuthTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap EtherType 888E packets to CPU
 * INPUT   : unit, port,
 *           mode      -- DEV_SWDRV_DOT1X_PACKET_DISCARD = 0,
 *                        DEV_SWDRV_DOT1X_PACKET_FORWARD,
 *                        DEV_SWDRV_DOT1X_PACKET_TRAPTOCPU
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDot1xAuthTrap(UI32_T unit, UI32_T port, UI32_T mode)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DOT1X_AUTH_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_DOT1X_AUTH_TRAP;
            isc_buffer_p->unit                  = unit;
            isc_buffer_p->port                  = port;
            isc_buffer_p->dot1x_auth_trap_mode  = mode;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetDot1xAuthTrap(unit, port, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }


    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDot1xAuthControlMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set dot1x auth control mode
 * INPUT   : unit, port,
 *               mode
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDot1xAuthControlMode(UI32_T unit, UI32_T port, UI32_T mode)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DOT1X_AUTH_CONTROL_MODE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_DOT1X_AUTH_CONTROL_MODE;
            isc_buffer_p->unit                  = unit;
            isc_buffer_p->port                  = port;
            isc_buffer_p->dot1x_auth_control_mode  = mode;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetDot1xAuthControlMode(unit, port, mode) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }


    return TRUE;
}
#endif /* SYS_CPNT_DOT1X == TRUE */

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetEapolFramePassThrough
 * -------------------------------------------------------------------------------------------
 * PURPOSE : To set EAPOL frames pass through (pass through means not trapped to CPU)
 * INPUT   : state (TRUE/FALSE)
 * OUTPUT  : None
 * RETURN  : TRUE
 * NOTE    : None
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetEapolFramePassThrough(BOOL_T state)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (TRUE == SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH_BY_RULE)
        {
            BOOL_T retval;
            retval = RULE_CTRL_1X_SetEapolPassThrough(state);

            if (FALSE == retval)
                return FALSE;
        }
#endif
        /* if stacking
        */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_EAPOL_FRAME_PASS_THROUGH) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable/disable eapol frame pass through
             */
            isc_buffer_p->ServiceID = SWDRV_SET_EAPOL_FRAME_PASS_THROUGH;
            isc_buffer_p->info.dot1x_auth.eapol_frame_pass_through = state;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalSetEapolFramePassThrough(state))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }

        return TRUE;
    }
}
#endif /* #if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE) */

#if (SYS_CPNT_EFM_OAM == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetOamLoopback
 * -------------------------------------------------------------------------
 * PURPOSE : This function will enable EFM OAM Loopback to CPU rules
 * INPUT   : unit  -- which unit.
 *           port  -- which port.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWDRV_SetOamLoopback(
    UI32_T unit, UI32_T port, BOOL_T is_enable, UI32_T type)
{
    #define LOOPBACK_PASSIVE    0 /* SWCTRL_LOOPBACK_MODE_TYPE_PASSIVE */
    #define LOOPBACK_ACTIVE     1 /* SWCTRL_LOOPBACK_MODE_TYPE_ACTIVE  */

    BOOL_T  ret = FALSE;

    /* do the rule part
     */
    if (LOOPBACK_PASSIVE == type)
    {
#if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY_BY_RULE == TRUE)
        ret  = RULE_CTRL_SetOamPduToCpu         (unit, port, is_enable);
        ret &= RULE_CTRL_SetOamLoopbackToRecPort(unit, port, is_enable);
        return ret;
#endif
    }
    else
    {
#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY_BY_RULE == TRUE)
        ret = RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(is_enable, unit, port);
        return ret;
#endif
    }

    /* do the register part
     */
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DOT1X_AUTH_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_OAM_LOOPBACK;
            isc_buffer_p->unit                  = unit;
            isc_buffer_p->port                  = port;
            isc_buffer_p->info.efm_oam.type     = type;
            isc_buffer_p->info.efm_oam.is_enable= is_enable;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
    #endif /*SYS_CPNT_STACKING*/
        {
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetOamLoopback(unit, port, is_enable, type) == FALSE)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#endif /* #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetInternaLoopback
 * -------------------------------------------------------------------------
 * PURPOSE : This function will enable EFM OAM Loopback to CPU rules
 * INPUT   : unit  -- which unit.
 *           port  -- which port.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWDRV_SetInternalLoopback(UI32_T unit, UI32_T port, BOOL_T is_enable)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            DBG_PRINT("STKTPLG_POM_GetMaxPortNumberOnBoard fail");
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_INTERNAL_LOOPBACK) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID             = SWDRV_SET_INTERNAL_LOOPBACK;
            isc_buffer_p->unit                  = unit;
            isc_buffer_p->port                  = port;
            isc_buffer_p->info.internal_loopback_status.is_enable = is_enable;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetInternaLoopback(unit, port, is_enable) == FALSE)
            {
                DBG_PRINT("SWDRV_LocalSetInternaLoopback fail");
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }

#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

#endif /* #if (SYS_CPNT_EFM_OAM == TRUE) */

/****************************************************************************/
/* Trap traffic to cpu                                                      */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapUnknownIpMcastToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap unknown ip multicast packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 *           flood  -- TRUE to flood to other ports; FLASE to discard the traffic.
 *           vid = 0 -- global setting, vid = else -- which VLAN ID to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapUnknownIpMcastToCPU(BOOL_T to_cpu, BOOL_T flood, UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if(unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_TRAP_UNKNOWN_IPMC_TO_CPU) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_TRAP_UNKNOWN_IPMC_TO_CPU;
            isc_buffer_p->info.packet_trap_byvlan_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_byvlan_info.flood = flood;
            isc_buffer_p->info.packet_trap_byvlan_info.vid = vid;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
           {

               return FALSE; /* can't control remote unit */
           }
        }
#endif

        if(!SWDRV_LocalTrapUnknownIpMcastToCPU(to_cpu, flood, vid))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_TrapUnknownIpMcastToCPU() */

#if (SYS_CPNT_MLDSNP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapUnknownIpv6McastToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap unknown ipv6 multicast packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 *           flood  -- TRUE to flood to other ports; FLASE to discard the traffic.
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapUnknownIpv6McastToCPU(BOOL_T to_cpu, BOOL_T flood, UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if(unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_TRAP_UNKNOWN_IPV6MC_TO_CPU) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_TRAP_UNKNOWN_IPV6MC_TO_CPU;
            isc_buffer_p->info.packet_trap_byvlan_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_byvlan_info.flood = flood;
            isc_buffer_p->info.packet_trap_byvlan_info.vid = vid;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
           {

               return FALSE; /* can't control remote unit */
           }
        }
#endif

        if(!SWDRV_LocalTrapUnknownIpv6McastToCPU(to_cpu, flood, vid))
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_TrapUnknownIpv6McastToCPU() */
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_TrapIpv6PIMToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap ipv6 PIM packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapIpv6PIMToCPU(BOOL_T to_cpu)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if(unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_TRAP_IPV6PIM_TO_CPU) /* user_id */ );
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* create trunk of all unit
             */
            isc_buffer_p->ServiceID     = SWDRV_TRAP_IPV6PIM_TO_CPU;
            isc_buffer_p->info.packet_trap_info.to_cpu = to_cpu;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
           {

               return FALSE; /* can't control remote unit */
           }
        }
#endif

        if(!SWDRV_LocalTrapIpv6PIMToCPU(to_cpu))
        {
             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
    }

    return TRUE;
} /* End of SWDRV_TrapIpv6PIMToCPU() */
#endif

static BOOL_T SWDRV_ShowPortSfpInfo(UI32_T unit, UI32_T port)
{
    UI32_T  sfp_index;
    BOOL_T  ret_val=TRUE;
    UI8_T   info_ar[SWDRV_TYPE_GBIC_EEPROM_MAX_LENGTH];
    UI8_T   sfp_type, qsfp_page = 0/* write dflt page 0 */;
    UI8_T   calc_cksum = 0, real_cksum = 0, *ptr=info_ar;
    BOOL_T  is_break_out;

    if(STKTPLG_OM_UserPortToSfpIndexAndType(unit, port, &sfp_index, &sfp_type, &is_break_out) == FALSE)
    {
        BACKDOOR_MGR_Printf("Failed to convert port%ld to sfp index\r\n", port);
        return FALSE;
    }
    if(is_break_out == TRUE)
    {
        sfp_type = SWDRV_TYPE_GBIC_ID_QSFP;
    }

    //read 0x50
    BACKDOOR_MGR_Printf("A0h\r\n");
    if((sfp_type == SWDRV_TYPE_GBIC_ID_QSFP || sfp_type == SWDRV_TYPE_GBIC_ID_QSFP_PLUS))
    {
        qsfp_page = 0;
        if(FALSE == SYSDRV_SetSfpInfo(sfp_index, 127, 1, &qsfp_page))
        {
            BACKDOOR_MGR_Printf("%s(%d): Failed to set QSFP(+) %lu page to 0.\r\n", __FUNCTION__, __LINE__, sfp_index);
            return FALSE;
        }
    }

    if((TRUE == SYSDRV_GetSfpInfo(sfp_index, 0, 128, info_ar)) &&
            (TRUE == SYSDRV_GetSfpInfo(sfp_index, 128, 128, &(info_ar[128]))))
    {
        BACKDOOR_MGR_DumpHex(NULL, 256, (void *)&info_ar);
        if(sfp_type == SWDRV_TYPE_GBIC_ID_XFP || sfp_type == SWDRV_TYPE_GBIC_ID_QSFP ||
                sfp_type == SWDRV_TYPE_GBIC_ID_QSFP_PLUS)
            ptr = &info_ar[128];
        if(TRUE == SWDRV_LIB_CalcSFPChecksum(SWDRV_TYPE_SFP_CHECKSUM_CC_BASE, ptr, &calc_cksum, &real_cksum))
            BACKDOOR_MGR_Printf("%s(%d): CC_BASE:0x%x calculated:0x%x.\r\n", __FUNCTION__, __LINE__, real_cksum, calc_cksum);
        if(TRUE == SWDRV_LIB_CalcSFPChecksum(SWDRV_TYPE_SFP_CHECKSUM_CC_EXT, ptr, &calc_cksum, &real_cksum))
            BACKDOOR_MGR_Printf("%s(%d): CC_EXT:0x%x calculated:0x%x.\r\n", __FUNCTION__, __LINE__, real_cksum, calc_cksum);
    }
    else
    {
        BACKDOOR_MGR_Printf("%s(%d): Failed to read SFP %lu info from I2C.\r\n", __FUNCTION__, __LINE__, sfp_index);
        return FALSE;
    }

    //read 0x51
    BACKDOOR_MGR_Printf("A2h\r\n");
    if(sfp_type == SWDRV_TYPE_GBIC_ID_SFP && (SWDRV_TYPE_GBIC_DIAG_MONITOR_TYPE_DDM_IMPLEMENTED & info_ar[92]))
    {
        if(TRUE == SYSDRV_GetSfpDdmInfo(sfp_index, 0, 128, &info_ar[0]) &&
                TRUE == SYSDRV_GetSfpDdmInfo(sfp_index, 128, 128, &info_ar[128]))
        {
            BACKDOOR_MGR_DumpHex(NULL, 256, (void *)&info_ar);
        }
        else
        {
            BACKDOOR_MGR_Printf("%s(%d): Failed to read SFP %lu DDM info from I2C.\r\n", __FUNCTION__, __LINE__, sfp_index);
            return FALSE;
        }
    }

    if(sfp_type == SWDRV_TYPE_GBIC_ID_QSFP || sfp_type == SWDRV_TYPE_GBIC_ID_QSFP_PLUS)
    {
        qsfp_page = 3;
        if(FALSE == SYSDRV_SetSfpInfo(sfp_index, 127, 1, &qsfp_page))
        {
            BACKDOOR_MGR_Printf("%s(%d): Failed to set QSFP(+) %lu page to 3.\r\n", __FUNCTION__, __LINE__, sfp_index);
            return FALSE;
        }
        if((TRUE == SYSDRV_GetSfpInfo(sfp_index, 0, 128, info_ar)) &&
                (TRUE == SYSDRV_GetSfpInfo(sfp_index, 128, 128, &(info_ar[128]))))
        {
            BACKDOOR_MGR_DumpHex(NULL, 256, (void *)&info_ar);
        }
        else
        {
            BACKDOOR_MGR_Printf("%s(%d): Failed to read QSFP(+) %lu DDM info from I2C.\r\n", __FUNCTION__, __LINE__, sfp_index);
            return FALSE;
        }
    }

    return ret_val;
} /* End of SWDRV_ShowPortSfpInfo */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DropCdpPacketByPort
 * -------------------------------------------------------------------------
 * PURPOSE : Drop CDP packet
 * INPUT   : enable  -- enabled/disabled this feature
 *           unit    -- unit
 *           port    -- port
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- Failed
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T
SWDRV_DropCdpPacketByPort(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
#if (TRUE == SYS_CPNT_APP_FILTER_CDP)
    return (RULE_TYPE_OK == RULE_CTRL_AF_DenyCdpPacket(enable, unit, port))
            ? TRUE : FALSE;
#else
    return TRUE;
#endif /* #if (TRUE == SYS_CPNT_APP_FILTER_CDP) */
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DropPvstPacketByPort
 * -------------------------------------------------------------------------
 * PURPOSE : Drop PVST packet
 * INPUT   : enable  -- enabled/disabled this feature
 *           unit    -- unit
 *           port    -- port
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- Failed
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T
SWDRV_DropPvstPacketByPort(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
#if (TRUE == SYS_CPNT_APP_FILTER_PVST)
    return (RULE_TYPE_OK == RULE_CTRL_AF_DenyPvstPacket(enable, unit, port))
            ? TRUE : FALSE;
#else
    return TRUE;
#endif /* #if (TRUE == SYS_CPNT_APP_FILTER_PVST) */
}

/*************************** Local SubRoutine *******************************/

/****************************************************************************/
/* Port Configuration                                                       */
/****************************************************************************/
static BOOL_T SWDRV_LocalEnablePortAdmin(UI32_T unit, UI32_T port)
{

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

#if (SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE)
    /* Port admin status is set by SWDRV_MONITOR thread if it is PoE PD Port
     * Only update OM here
     */
    if(STKTPLG_OM_IsPoEPDPort(unit, port)==TRUE)
    {
        return SWDRV_OM_UpdateLocalPortAdminStatus(unit, port, TRUE);
    }
#endif
    return DEV_SWDRV_PMGR_EnablePortAdmin(unit, port);
}

static BOOL_T SWDRV_LocalDisablePortAdmin(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE)
    /* Port admin status is set by SWDRV_MONITOR thread if it is PoE PD Port
     * Only update OM here
     */
    if(STKTPLG_OM_IsPoEPDPort(unit, port)==TRUE)
    {
        return SWDRV_OM_UpdateLocalPortAdminStatus(unit, port, FALSE);
    }
#endif

    return DEV_SWDRV_PMGR_DisablePortAdmin(unit, port);
}

static BOOL_T SWDRV_LocalDisableAllPortAdmin(void)
{
    if(!DEV_SWDRV_PMGR_DisableAllPortAdmin())
        return FALSE;

#if (SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE)
    {
        UI32_T my_unit_id, port;

        if(STKTPLG_OM_GetMyUnitID(&my_unit_id)==TRUE)
        {
            for(port=1; port<=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; port++)
                SWDRV_OM_UpdateLocalPortAdminStatus(my_unit_id, port, FALSE);
        }
        else
        {
            printf("%s(%d)Failed to get my unit id.\r\n", __FUNCTION__, __LINE__);
        }
    }
#endif

    return TRUE;
}

static BOOL_T SWDRV_LocalSetPortCfgSpeedDuplex(UI32_T unit, UI32_T port, UI32_T speed_duplex)
{
    BOOL_T retval;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port && speed_duplex == VAL_portSpeedDpxCfg_fullDuplex100)
        return TRUE;
#endif

    retval = DEV_SWDRV_PMGR_DisablePortAutoNeg(unit, port);
    if(FALSE == retval)
    {
        return FALSE;
    }

    retval = DEV_SWDRV_PMGR_SetPortCfgSpeedDuplex(unit, port, speed_duplex);
    if(FALSE == retval)
    {
        DEV_SWDRV_PMGR_EnablePortAutoNeg(unit, port);
    }

    return retval;
}

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
static BOOL_T SWDRV_LocalSetPort1000BaseTForceMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    BOOL_T retval;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    return TRUE;
#endif

    retval = DEV_SWDRV_PMGR_SetPort1000BaseTForceMode(unit, port, mode);
    return retval;
}
#endif

static BOOL_T SWDRV_LocalGetCopperEnergyDetect(UI32_T unit, UI32_T port, UI32_T *copper_energy_detect)
{
    BOOL_T retval;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    return TRUE;
#endif

    retval = DEV_SWDRV_PMGR_GetCopperEnergyDetect(unit, port, copper_energy_detect);
    return retval;
}

static BOOL_T SWDRV_LocalEnablePortAutoNeg(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

    if (DEV_SWDRV_PMGR_EnablePortAutoNeg(unit, port))
    {
        SWDRV_OM_SetPortInfoIsAutoNeg(port, TRUE);
        return TRUE;
    }

    return FALSE;

}

static BOOL_T SWDRV_LocalDisablePortAutoNeg(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    if (DEV_SWDRV_PMGR_DisablePortAutoNeg(unit, port))
    {
        SWDRV_OM_SetPortInfoIsAutoNeg(port, FALSE);
        return TRUE;
    }

    return FALSE;
}

static BOOL_T SWDRV_LocalEnablePortCfgFlowCtrl(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

    return DEV_SWDRV_PMGR_EnablePortCfgFlowCtrl(unit, port);

}

static UI8_T SWDRV_LocalDisablePortCfgFlowCtrl(UI32_T unit, UI32_T port)
{
    /* return value:
     * 1. the 1st bit: disable port flow control is successful or not.
     * 2. the 2nd bit of return value is indicated the flow control oper status is changed
     * or not.
     * (The remote unit should not notify in ISC thread. It will cause the ISC locked.)
     */

    UI8_T   retval = TRUE;

     if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return retval;
#endif

    if (DEV_SWDRV_PMGR_DisablePortCfgFlowCtrl(unit, port))
    {
        SWDRV_Port_Info_T  swdrv_port_info;
        UI32_T old_status;

        SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
        old_status = swdrv_port_info.flow_control_oper;

        SWDRV_OM_SetPortInfoFlowControlOper(port, VAL_portFlowCtrlStatus_none);
        if (old_status != VAL_portFlowCtrlStatus_none)
        {
            retval |= SWDRV_PORT_FLOW_CONTROL_OPER_STATUS_CHANGED;
        }

        return retval;
    }

    return retval;
}

static UI8_T SWDRV_LocalSetPortCfgFlowCtrl(UI32_T unit, UI32_T port, UI32_T mode)
{
    UI8_T   retval = TRUE;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
    {
        return retval;
    }
#endif


    if ( (retval = (UI8_T) DEV_SWDRV_PMGR_SetPortCfgFlowCtrl (unit, port, mode)) != FALSE)
    {
        if (VAL_portFlowCtrlCfg_disabled == mode)
        {
            /* disable only, follow old code.
             */
            SWDRV_Port_Info_T  swdrv_port_info;
            UI32_T old_status;

            memset(&swdrv_port_info, 0, sizeof(SWDRV_Port_Info_T));
            SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

            old_status = swdrv_port_info.flow_control_oper;
            SWDRV_OM_SetPortInfoFlowControlOper(port, VAL_portFlowCtrlStatus_none);

            if (old_status != VAL_portFlowCtrlStatus_none)
            {
                retval |= SWDRV_PORT_FLOW_CONTROL_OPER_STATUS_CHANGED;
            }

            return retval;
        }
    }

    return retval;
}

static BOOL_T SWDRV_LocalSetPortAutoNegCapability(UI32_T unit, UI32_T port, UI32_T capability)
{
    SWDRV_Port_Info_T swdrv_port_info;
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

    memset(&swdrv_port_info, 0, sizeof(SWDRV_Port_Info_T));
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

    return DEV_SWDRV_PMGR_SetPortAutoNegCapability(unit, port, capability);

}

static BOOL_T SWDRV_LocalGetPortType(UI32_T unit, UI32_T port, UI32_T *port_type)
{
    UI32_T status=0, link;
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_Port_Info_T   swdrv_port_info;

    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    if((port < swdrv_system_info.base_port_id) ||
       (port > swdrv_system_info.base_port_id+swdrv_system_info.port_number-1))
    {
        return FALSE;
    }


#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        *port_type = VAL_portType_hundredBaseTX;
        return TRUE;
    }
#endif

    if((DEV_SWDRV_PMGR_GetPortType(unit, port, &status) == TRUE) && (DEV_SWDRV_PMGR_GetPortLinkStatus(unit, port, &link) == TRUE))
    {   /*add by wx for 100fx*/
        if ((status == VAL_portType_thousandBaseSfp) && (link == TRUE))
        {
            SWDRV_OM_SetPortInfoPortType(port, VAL_portType_thousandBaseSfp);
        }
        else if ((status == VAL_portType_hundredBaseFX) && (link == TRUE))
        {
            SWDRV_OM_SetPortInfoPortType(port, VAL_portType_hundredBaseFX);
        }
    }

    memset(&swdrv_port_info, 0, sizeof(swdrv_port_info));
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
    *port_type = swdrv_port_info.port_type;

    if (*port_type == STKTPLG_PORT_TYPE_NOT_EXIST)
    {
        return FALSE;
    }

    return TRUE;
}

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
static BOOL_T SWDRV_LocalGetPortLoopbackTestResult(UI8_T test_result[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK])
{
    UI8_T unit_test_result[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];
    UI32_T  stack_id;

    memset(test_result, 0, SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

    if (FALSE == UC_MGR_GetLoopbackTestResult(unit_test_result))
    {
        return FALSE;
    }

    /* memcpy unit result to stack result by [swdrv_system_info.stack_id]
     */
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    memcpy((test_result)+(SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST)*(sstack_id - 1),
           unit_test_result,
           SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

    return TRUE;
}
#endif



/****************************************************************************/
/* SPANNING TREE                                                            */
/****************************************************************************/
static BOOL_T SWDRV_LocalSetPortSTAState(UI32_T unit, UI32_T vid, UI32_T port, UI32_T state)
{
    BOOL_T ret=TRUE;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif
#if (SYS_CPNT_HRDRV == TRUE)
    ret &= HRDRV_SetPortSTAState(unit, port, state);
#endif

    ret &= DEV_SWDRV_PMGR_SetPortSTAState(vid, 0, NULL, unit, port, state); /* need re-check */

    return ret;
}
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
static BOOL_T SWDRV_LocalEnableMultiSTA()
{
    BOOL_T ret=TRUE;
    ret &= DEV_SWDRV_PMGR_SetSTAMode(DEV_SWDRV_STAMODE_MSTP);
    return ret;
}

static BOOL_T SWDRV_LocalDisableMultiSTA()
{
    BOOL_T ret = TRUE;
    ret &= DEV_SWDRV_PMGR_SetSTAMode(DEV_SWDRV_STAMODE_SSTP);
    return ret;
}

static BOOL_T SWDRV_LocalAddVlanToMst(UI32_T vid, UI32_T mstidx)
{
    return DEV_SWDRV_PMGR_AddVlanToSTAWithMstidx( vid, mstidx);
}

static BOOL_T SWDRV_LocalDeleteVlanFromMst(UI32_T vid, UI32_T mstidx)
{
    return DEV_SWDRV_PMGR_DeleteVlanFromSTAWithMstidx( vid, mstidx);
}

#endif /* (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

static BOOL_T SWDRV_LocalSetPortXstpState(UI32_T mstid,
                                          UI32_T vlan_count,
                                          UI16_T *vlan_list,
                                          UI32_T unit_id,
                                          UI32_T port,
                                          UI32_T state)
{
    BOOL_T ret=TRUE;
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    ret &=SWDRV_CACHE_MGR_SetPortXstpState( mstid, vlan_count, vlan_list, unit_id, port, state);

    return ret;
#else

    ret &=DEV_SWDRV_PMGR_SetPortSTAState( mstid, vlan_count, vlan_list, unit_id, port, state);

    return ret;

#endif

}

static BOOL_T SWDRV_LocalSetPortStateWithMstidx(UI32_T mstidx,
                                                UI32_T unit_id,
                                                UI32_T port,
                                                UI32_T state)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_SetPortSTAStateWithMstidx( mstidx, unit_id, port, state);
}

/****************************************************************************/
/* VLAN                                                                     */
/****************************************************************************/
static BOOL_T SWDRV_LocalSetPortPVID(UI32_T unit_id, UI32_T port, UI32_T pvid)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_SetPVID(port, pvid);
#else

    return DEV_SWDRV_PMGR_SetPortPVID(unit_id, port, pvid);

#endif
}

static BOOL_T SWDRV_LocalCreateVlan(UI32_T vid)
{
#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_CreateVLAN(vid);
#else
    return DEV_SWDRV_PMGR_CreateVlan(vid);
#endif
}

static BOOL_T SWDRV_LocalDestroyVlan(UI32_T vid)
{
#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_DestoryVLAN(vid);
#else
    return DEV_SWDRV_PMGR_DestroyVlan(vid);
#endif
}

static BOOL_T SWDRV_LocalSetGlobalDefaultVlan(UI32_T vid)
{
    return DEV_SWDRV_PMGR_SetGlobalDefaultVlan(vid);
}

static BOOL_T SWDRV_LocalAddPortToVlanMemberSet(UI32_T unit, UI32_T port, UI32_T vid)
{
    BOOL_T retval;

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
    {
        return TRUE;
    }
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    if ((retval = SWDRV_CACHE_MGR_AddVlanMemberSet(port, vid)) == TRUE)
        SWDRV_CACHE_MGR_DeleteUntaggedSet(port, vid);
#else
    retval = DEV_SWDRV_PMGR_AddPortVlanSet(unit, port, vid);
#endif

    return retval;
}

static BOOL_T SWDRV_LocalDeletePortFromVlanMemberSet(UI32_T unit, UI32_T port, UI32_T vid)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
    {
        return TRUE;
    }
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_DeleteVlanMemberSet(port, vid);
#else
    return DEV_SWDRV_PMGR_DeletePortVlanSet(unit, port, vid);
#endif
}

static BOOL_T SWDRV_localAddPortToVlanUntaggedSet(UI32_T unit, UI32_T port, UI32_T vid)
{
     if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_AddUntaggedSet(port, vid);
#else
    return DEV_SWDRV_PMGR_AddPortUntaggedVlanSet(unit, port, vid);
#endif
}

static BOOL_T SWDRV_LocalDeletePortFromVlanUntaggedSet(UI32_T unit, UI32_T port,UI32_T vid)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

#if (SYS_CPNT_SWDRV_CACHE == TRUE)
    return SWDRV_CACHE_MGR_DeleteUntaggedSet(port, vid);
#else
    return DEV_SWDRV_PMGR_DeletePortUntaggedVlanSet(unit, port, vid);
#endif
}

static BOOL_T SWDRV_LocalSetSystemMTU(UI32_T status,UI32_T mtu)
{
    return DEV_SWDRV_PMGR_SetSystemMTU(status,mtu);
}

static BOOL_T SWDRV_LocalSetPortMTU(UI32_T unit,UI32_T port,UI32_T mtu)
{

    return DEV_SWDRV_PMGR_SetPortMTU(unit,port,mtu);
}

static BOOL_T SWDRV_LocalGetPortMaxFrameSize(UI32_T unit, UI32_T port, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p)
{
    return DEV_SWDRV_PMGR_GetPortMaxFrameSize(unit, port, untagged_max_frame_sz_p, tagged_max_frame_sz_p);
}

#if (SYS_CPNT_VXLAN == TRUE)
static BOOL_T SWDRV_LocalSetVxlanStatus(
    BOOL_T  is_enable,
    BOOL_T  is_random_src_port)
{
    return DEV_SWDRV_PMGR_SetVxlanStatus(is_enable, is_random_src_port);
}

static BOOL_T SWDRV_LocalSetVxlanStatusPort(
    UI32_T  unit,
    UI32_T  port,
    BOOL_T  is_acc_port,
    BOOL_T  is_enable)
{
    return DEV_SWDRV_PMGR_SetVxlanStatusPort(
                unit, port, is_acc_port, is_enable);
}

static BOOL_T SWDRV_LocalSetVxlanUdpPort(
    UI32_T  udp_port)
{
    return DEV_SWDRV_PMGR_SetVxlanUdpPort(udp_port);
}

static BOOL_T SWDRV_LocalSetVxlanVpn(
    SWDRV_VxlanVpnInfo_T    *vpn_info_p,
    BOOL_T                  is_add)
{
    DEV_SWDRV_VxlanVpnInfo_T    ds_vpn_info;
    BOOL_T                      ret;

    ds_vpn_info.bc_group = vpn_info_p->bc_group;
    ds_vpn_info.vfi      = vpn_info_p->vfi;
    ds_vpn_info.vnid     = vpn_info_p->vnid;

    ret = DEV_SWDRV_PMGR_SetVxlanVpn(&ds_vpn_info, is_add);
    if ((TRUE == ret) && (TRUE == is_add))
    {
        vpn_info_p->vfi      = ds_vpn_info.vfi;
        vpn_info_p->bc_group = ds_vpn_info.bc_group;
    }

    return ret;
}

static BOOL_T SWDRV_LocalAddVtepIntoMcastGroup(
    UI32_T  bcast_group,
    UI32_T  vxlan_port,
    BOOL_T  is_add)
{
    return DEV_SWDRV_PMGR_AddVtepIntoMcastGroup(
            bcast_group, vxlan_port, is_add);
}

static BOOL_T SWDRV_LocalCreateVTEP(
    UI32_T              vfi_id,
    UI32_T              l3_inf_id,
    UI32_T              unit,
    UI32_T              port,
    UI32_T              udp_port,
    UI8_T               r_mac[SYS_ADPT_MAC_ADDR_LEN],
    BOOL_T              is_mc,
    BOOL_T              is_acc_port,
    L_INET_AddrIp_T     *l_vtep_p,
    L_INET_AddrIp_T     *r_vtep_p,
    UI32_T              *vxlan_port_p)
{
    return FALSE;
}

static BOOL_T SWDRV_LocalDestroyVTEP(
    UI32_T  vfi_id,
    UI32_T  vxlan_port_id)
{
    return FALSE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_LocalSetVxlanPortLearning
 * -------------------------------------------------------------------------
 * FUNCTION: Disable/Enable port learning function
 * INPUT   : vxlan_port_id -- Which VXLAN logical port.
 *           is_learning -- TRUE to enable MAC learning.
 *                          FALSE to disable MAC learning.
 * OUTPUT  : none.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_LocalSetVxlanPortLearning(UI32_T vxlan_port_id, BOOL_T is_learning)
{
    return DEV_SWDRV_PMGR_SetVxlanPortLearning(vxlan_port_id, is_learning);
}
#endif /* #if (SYS_CPNT_VXLAN == TRUE) */

static BOOL_T SWDRV_LocalEnableIngressFilter(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_EnableIngressFilter(unit, port);
}

static BOOL_T SWDRV_LocalDisableIngressFilter(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_DisableIngressFilter(unit, port);
}

static BOOL_T SWDRV_LocalAdmitVLANTaggedFramesOnly(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_AdmitOnlyVlanTaggedFrames(unit, port);
}

static BOOL_T SWDRV_LocalAdmitVLANUntaggedFramesOnly(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_AdmitOnlyVlanUntaggedFrames(unit, port);
}

static BOOL_T SWDRV_LocalAdmitAllFrames(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

    return DEV_SWDRV_PMGR_AdmitAllFrames(unit, port);

}

static BOOL_T SWDRV_LocalEnableTrapUnspecifiedTagFrame(void)
{
    return DEV_SWDRV_PMGR_EnableTrapUnspecifiedTagFrame();
}

static BOOL_T SWDRV_LocalDisableTrapUnspecifiedTagFrame(void)
{
    return DEV_SWDRV_PMGR_DisableTrapUnspecifiedTagFrame();
}

static BOOL_T SWDRV_LocalAddHostToVlan(UI32_T vid)
{
     return DEV_SWDRV_PMGR_AddCpuToVlan(vid);
}

static BOOL_T SWDRV_LocalDeleteHostFromVlan(UI32_T vid)
{
    return DEV_SWDRV_PMGR_DeleteCpuFromVlan(vid);
}

/****************************************************************************/
/* Port Mirroring                                                           */
/****************************************************************************/
static BOOL_T SWDRV_LocalSetPortMirroring(SYS_TYPE_Uport_T from_port,
                              SYS_TYPE_Uport_T rx_to_port,
                              SYS_TYPE_Uport_T tx_to_port)
{
    UI32_T  stack_id;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if ((SYS_ADPT_MGMT_PORT == from_port.port)  ||
        (SYS_ADPT_MGMT_PORT == rx_to_port.port) ||
        (SYS_ADPT_MGMT_PORT == tx_to_port.port))
        return FALSE;
#endif

    if(DEV_SWDRV_PMGR_DeletePortMirroring(from_port,rx_to_port)== FALSE)
        return FALSE;
    return DEV_SWDRV_PMGR_SetPortMirroring(from_port, rx_to_port, tx_to_port);
}

static BOOL_T SWDRV_LocalDeletePortMirroring(SYS_TYPE_Uport_T from_port ,SYS_TYPE_Uport_T to_port)
{
    UI32_T  stack_id;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if ((SYS_ADPT_MGMT_PORT == from_port.port)  ||
        (SYS_ADPT_MGMT_PORT == to_port.port))
        return FALSE;
#endif

    return DEV_SWDRV_PMGR_DeletePortMirroring(from_port,to_port);

}

static BOOL_T SWDRV_LocalEnablePortMirroring(SYS_TYPE_Uport_T from_port)
{
    return DEV_SWDRV_PMGR_EnablePortMirroring(from_port);
}

static BOOL_T SWDRV_LocalDisablePortMirroring(SYS_TYPE_Uport_T from_port)
{
    return DEV_SWDRV_PMGR_DisablePortMirroring(from_port);
}

/****************************************************************************/
/* VLAN Mirroring                                                           */
/****************************************************************************/
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static BOOL_T SWDRV_LocalAddVlanMirror(UI32_T unit, UI32_T port, UI32_T vid)
{
    return DEV_SWDRV_PMGR_AddVlanMirror(unit, port, vid);
}

static BOOL_T SWDRV_LocalDeleteVlanMirror(UI32_T unit, UI32_T port, UI32_T vid)
{
    return DEV_SWDRV_PMGR_DeleteVlanMirror(unit, port, vid);
}
#endif /* End of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

/****************************************************************************/
/* Mac-based Mirroring                                                      */
/****************************************************************************/
#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
static BOOL_T SWDRV_LocalSetMacMirrorEntry(UI8_T *mac_address)
{
    /* unused now,
     * should re-implement it if chip can support MAC-based mirror without rule
     */
    return RULE_CTRL_SetMacMirrorEntry(mac_address);
}

static BOOL_T SWDRV_LocalDeleteMacMirrorEntry(UI8_T *mac_address)
{
    /* unused now,
     * should re-implement it if chip can support MAC-based mirror without rule
     */
    return RULE_CTRL_DeleteMacMirrorEntry(mac_address);
}

static BOOL_T SWDRV_LocalSetDestPortForMacMirror(UI32_T unit, UI32_T port, BOOL_T mode)
{
    return DEV_SWDRV_PMGR_SetDestPortForMacMirror(unit, port, mode);
}
#endif /* end of #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

/****************************************************************************/
/* ACL-based Mirroring                                                      */
/****************************************************************************/
#if (SYS_CPNT_ACL_MIRROR == TRUE)
static BOOL_T SWDRV_LocalSetDestPortForAclMirror(UI32_T unit, UI32_T port, BOOL_T mode)
{
    return DEV_SWDRV_PMGR_SetDestPortForAclMirror(unit, port, mode);
}
#endif /* end of #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

/****************************************************************************/
/* Trunking                                                                 */
/****************************************************************************/
static BOOL_T SWDRV_LocalCreateTrunk(UI32_T trunk_id)
{
    SWDRV_Trunk_Info_T swdrv_trunk_info;

    memset(&swdrv_trunk_info, 0, sizeof(swdrv_trunk_info));
    SWDRV_OM_GetTrunkInfo(trunk_id, &swdrv_trunk_info);

    if(swdrv_trunk_info.used)
        return TRUE;

    SWDRV_OM_SetTrunkInfoUsed(trunk_id, TRUE);
    return TRUE;
}

static BOOL_T SWDRV_LocalDestroyTrunk(UI32_T trunk_id)
{
    SWDRV_Trunk_Info_T swdrv_trunk_info;

    memset(&swdrv_trunk_info, 0, sizeof(swdrv_trunk_info));
    SWDRV_OM_GetTrunkInfo(trunk_id, &swdrv_trunk_info);

    if(swdrv_trunk_info.used)
        return TRUE;

    SWDRV_OM_SetTrunkInfoUsed(trunk_id, FALSE);
    return TRUE;
}

static BOOL_T SWDRV_LocalSetTrunkPorts(UI32_T trunk_id,
                                       UI32_T port_count,
                                       SYS_TYPE_Uport_T *port_member)
{
    UI32_T  broadcast_port;
    UI8_T   i;
#if 0 /* JinhuaWei, 03 August, 2008 2:31:37 */
    UI32_T  stack_id;
#endif /* #if 0 */
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_Trunk_Info_T swdrv_trunk_info;

    memset(&swdrv_trunk_info, 0, sizeof(swdrv_trunk_info));
    SWDRV_OM_GetTrunkInfo(trunk_id, &swdrv_trunk_info);

    if(!(swdrv_trunk_info.used))
            return FALSE;

    for(i=0; i<port_count; i++)
    {
        if((port_member[i].unit < 1) || (port_member[i].unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
            return FALSE;

        /* MIKE modify 12/28/04 for AMTR_Refinement polling trunk hit bit using */
        SWDRV_OM_SetTrunkInfoMemberUnit(trunk_id, i, port_member[i].unit);
        SWDRV_OM_SetTrunkInfoMemberPort(trunk_id, i, port_member[i].port);
        /*
        if((port_member[i].port < 1) || (port_member[i].port > swdrv_system_info.port_number))
            return FALSE;
        */
    }
    SWDRV_OM_SetTrunkInfoMemberNum(trunk_id, port_count);

    /* Since the port list is sorted, the lowest port is the first member in list
     */

    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    if (swdrv_system_info.stack_id == port_member[0].unit)
    {
        broadcast_port = port_member[0].port;
    }

    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        broadcast_port = swdrv_system_info.stacking_port;
#endif
    }

    DEV_SWDRV_PMGR_SetTrunkPortMembers(trunk_id,
                                     port_count,
                                     port_member);


    return TRUE;
}

static BOOL_T SWDRV_LocalSetTrunkBalanceMode(UI32_T mode)
{
    return DEV_SWDRV_PMGR_SetTrunkLoadBalanceMode(mode);
}

/****************************************************************************/
/* IGMP Functions                                                           */
/****************************************************************************/
static BOOL_T SWDRV_LocalEnableIgmpTrap(void)
{
#if (SYS_CPNT_SWDRV_TRAP_IGMP_BY_RULE == TRUE)
    return RULE_CTRL_TrapPacket2CpuForSwdrv(TRUE, RULE_TYPE_PacketType_IGMP, NULL);
#else
    #if (SYS_CPNT_HRDRV == TRUE)
        #if(defined(STRATA_SWITCH)||defined(XGS_SWITCH))
            return HRDRV_EnableIgmpTrap(HRDRV_ADMIN_MODE);
        #else
            return TRUE;
        #endif
    #else
        return DEV_SWDRV_PMGR_EnableIgmpTrap();
    #endif
#endif
}

static BOOL_T SWDRV_LocalDisableIgmpTrap(void)
{
#if (SYS_CPNT_SWDRV_TRAP_IGMP_BY_RULE == TRUE)
    return RULE_CTRL_TrapPacket2CpuForSwdrv(FALSE, RULE_TYPE_PacketType_IGMP, NULL);
#else
    #if (SYS_CPNT_HRDRV == TRUE)
        #if(defined(STRATA_SWITCH)||defined(XGS_SWITCH))
            return HRDRV_DisableIgmpTrap(HRDRV_ADMIN_MODE);
        #else
            return TRUE;
        #endif
    #else
        return DEV_SWDRV_PMGR_DisableIgmpTrap();
    #endif
#endif
}

/****************************************************************************/
/* DHCP Functions                                                           */
/****************************************************************************/
static BOOL_T SWDRV_LocalTrapDhcpServerPacket(BOOL_T to_cpu, BOOL_T flood)
{

    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2CpuForSwdrv(TRUE, RULE_TYPE_PacketType_DHCP_SERVER, &rule_info);
}

static BOOL_T SWDRV_LocalTrapDhcpClientPacket(BOOL_T to_cpu, BOOL_T flood)
{

    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2CpuForSwdrv(TRUE, RULE_TYPE_PacketType_DHCP_CLIENT, &rule_info);
}

static BOOL_T SWDRV_LocalSetOrgSpecificTrap(BOOL_T to_cpu, BOOL_T flood)
{
    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2CpuForSwdrv(TRUE, RULE_TYPE_PacketType_ORG_SPECIFIC, &rule_info);
}

static BOOL_T SWDRV_LocalAddMulticastAddrToTrunkMember(UI8_T *mac,UI32_T vid,UI32_T trunk_id,
                                                  SYS_TYPE_Uport_T trunk_member)
{
/*  UI8_T i, existing = FALSE;*/
    SWDRV_Trunk_Info_T swdrv_trunk_info;

    memset(&swdrv_trunk_info, 0, sizeof(swdrv_trunk_info));
    SWDRV_OM_GetTrunkInfo(trunk_id, &swdrv_trunk_info);
    if(!(swdrv_trunk_info.used))
            return FALSE;
/*
    for(i=0; i<swdrv_trunk_info[trunk_id].member_number; i++)
        if(trunk_member.port == swdrv_trunk_info[trunk_id].member_list[i])
            existing = TRUE;

    if(!existing)
        return FALSE;
*/

    return DEV_SWDRV_PMGR_AddMulticastAddrToTrunkMember(mac,
                                                   vid,
                                                   swdrv_trunk_info.bcmdrv_trunk_id,
                                                   trunk_member);
}

static BOOL_T SWDRV_LocalSetUnknownIPMcastFwdPortList (UI8_T port_list[])
{
    return TRUE;
}

static BOOL_T SWDRV_LocalSetBroadcastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == FALSE)
        memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
        for(i= swdrv_system_info.base_port_id;
            i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            i++)
        {

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (SYS_ADPT_MGMT_PORT == i)
                continue;
#endif

            retval &= (BOOL_T )DEV_SWDRV_PMGR_SetBroadcastStormControlThreshold(unit, i, threshold, mode);
        }
#else
        retval &= (BOOL_T )DEV_SWDRV_PMGR_SetBroadcastStormControlThreshold(unit, port, threshold, mode);
#endif
        return retval;
}

static BOOL_T SWDRV_LocalSetMulticastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == FALSE)
        memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
        for(i= swdrv_system_info.base_port_id;
            i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            i++)
        {
#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (SYS_ADPT_MGMT_PORT == i)
                continue;
#endif
            retval &= (BOOL_T )DEV_SWDRV_PMGR_SetMulticastStormControlThreshold(unit, i, threshold, mode);
        }
#else
        retval &= (BOOL_T )DEV_SWDRV_PMGR_SetMulticastStormControlThreshold(unit, port, threshold, mode);
#endif
        return retval;
}

static BOOL_T SWDRV_LocalSetUnknownUnicastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_UNKNOWN_USTORM_RATE_PER_PORT_CTRL == FALSE)
        memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
        SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
        for(i= swdrv_system_info.base_port_id;
            i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            i++)
        {
#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (SYS_ADPT_MGMT_PORT == i)
                continue;
#endif
            retval &= (BOOL_T )DEV_SWDRV_PMGR_SetUnknownUnicastStormControlThreshold(unit, i, threshold, mode);
        }
#else
        retval &= (BOOL_T )DEV_SWDRV_PMGR_SetUnknownUnicastStormControlThreshold(unit, port, threshold, mode);
#endif
        return retval;
}

static BOOL_T SWDRV_LocalEnableBroadcastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
    UI32_T i;
    SWDRV_Switch_Info_T swdrv_system_info;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (SYS_ADPT_MGMT_PORT == port)
            continue;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_EnableBroadcastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_EnableBroadcastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalDisableBroadcastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
            return TRUE;
#endif

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_DisableBroadcastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_DisableBroadcastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalEnableMulticastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (SYS_ADPT_MGMT_PORT == port)
            continue;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_EnableMulticastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_EnableMulticastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalDisableMulticastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
            return TRUE;
#endif

#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_DisableMulticastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_DisableMulticastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalEnableUnknownUnicastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (SYS_ADPT_MGMT_PORT == port)
            continue;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_EnableUnknownUnicastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_EnableUnknownUnicastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalDisableUnknownUnicastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == FALSE)
    SWDRV_Switch_Info_T swdrv_system_info;
    UI32_T i;
#endif
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
            return TRUE;
#endif

#if (SYS_CPNT_UNKNOWN_USTORM_ENABLE_PER_PORT == FALSE)
    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
        /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_DisableUnknownUnicastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_DisableUnknownUnicastStormControl(unit, port);
#endif
    return retval;
}


/****************************************************************************/
/* Local ATC Broadcast Multicast Storm                                      */
/****************************************************************************/
#if (SYS_CPNT_ATC_BSTORM == TRUE)
static BOOL_T SWDRV_LocalSetATCBroadcastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == FALSE)
        /* per block setting : FE block and GE block */
        for(i= swdrv_system_info.base_port_id;
            i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            i++)
        {

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (SYS_ADPT_MGMT_PORT == i)
                continue;
#endif

            retval &= (BOOL_T )DEV_SWDRV_PMGR_SetBroadcastStormControlThreshold(unit, i, threshold, mode);
        }
#else
        retval &= (BOOL_T )DEV_SWDRV_PMGR_SetBroadcastStormControlThreshold(unit, port, threshold, mode);

#endif
        return retval;
}

static BOOL_T SWDRV_LocalEnableATCBroadcastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
    /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (SYS_ADPT_MGMT_PORT == port)
            continue;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_EnableBroadcastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_EnableBroadcastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalDisableATCBroadcastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
            return TRUE;
#endif

#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
        /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_DisableBroadcastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_DisableBroadcastStormControl(unit, port);
#endif
    return retval;
}
#endif

#if (SYS_CPNT_ATC_MSTORM == TRUE)
static BOOL_T SWDRV_LocalSetATCMulticastStormControlThreshold(UI32_T unit, UI32_T port, UI32_T threshold, UI32_T mode)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == FALSE)
        /* per block setting : FE block and GE block */
        for(i= swdrv_system_info.base_port_id;
            i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
            i++)
        {

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (SYS_ADPT_MGMT_PORT == i)
                continue;
#endif

            retval &= (BOOL_T )DEV_SWDRV_PMGR_SetMulticastStormControlThreshold(unit, i, threshold, mode);
        }
#else
        retval &= (BOOL_T )DEV_SWDRV_PMGR_SetMulticastStormControlThreshold(unit, port, threshold, mode);
#endif
        return retval;
}

static BOOL_T SWDRV_LocalEnableATCMulticastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return FALSE;
#endif

#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
    /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (SYS_ADPT_MGMT_PORT == port)
            continue;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_EnableMulticastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_EnableMulticastStormControl(unit, port);
#endif
    return retval;
}

static BOOL_T SWDRV_LocalDisableATCMulticastStormControl(UI32_T unit, UI32_T port)
{
    BOOL_T retval = TRUE;
#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
    UI32_T i;
#endif
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
            return TRUE;
#endif

#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
        /* per block setting : FE block and GE block */
    for(i= swdrv_system_info.base_port_id;
        i<=swdrv_system_info.base_port_id+swdrv_system_info.port_number-1;
        i++)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SYS_ADPT_MGMT_PORT == port)
        return TRUE;
#endif

        retval &= (BOOL_T )DEV_SWDRV_PMGR_DisableMulticastStormControl(unit, i);
    }
#else
    return (BOOL_T )DEV_SWDRV_PMGR_DisableMulticastStormControl(unit, port);
#endif
    return retval;
}
#endif

static BOOL_T SWDRV_LocalGetPortStormGranularity(UI32_T unit, UI32_T port, UI32_T mode, UI32_T *granularity)
{
    return DEV_SWDRV_PMGR_GetPortStormGranularity(unit, port, mode, granularity);
}

/****************************************************************************/
/* Quality of Service                                                       */
/****************************************************************************/
static BOOL_T SWDRV_LocalSetPortUserDefaultPriority(UI32_T unit, UI32_T port, UI32_T priority)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

    return DEV_SWDRV_PMGR_SetPortUserDefaultPriority(unit, port, priority);
}

static BOOL_T SWDRV_LocalSetPriorityMapping(UI32_T unit, UI32_T port, UI8_T mapping[8])
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

    DEV_SWDRV_PMGR_SetPriorityMapping(unit, port, mapping);

    return TRUE;
}

static BOOL_T SWDRV_LocalSetPriorityMappingPerSystem(UI8_T mapping[8])
{
    return (BOOL_T )DEV_SWDRV_PMGR_SetPriorityMappingPerSystem(mapping);

}

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_LocalSetStackingPortPriorityMapping(UI32_T unit, UI32_T port, UI8_T mapping[8])
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

    DEV_SWDRV_PMGR_SetStackingPortPriorityMapping(unit, port, mapping);

    return TRUE;
}
#endif
/***************************************************************************/
/* Private VLAN APIs                                                       */
/***************************************************************************/
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SWDRV_LocalEnableTrafficSegmatation(void)
{
    #if(SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == FALSE)
#if 0
        return HRDRV_EnablePrivateVlan();
#endif
    #else
        return DEV_SWDRVL4_PMGR_EnableTrafficSegmatation();
    #endif
}

static BOOL_T SWDRV_LocalDisableTrafficSegmatation(void)
{
    #if(SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == FALSE)
#if 0
        return HRDRV_DisablePrivateVlan();
#endif
    #else
        return DEV_SWDRVL4_PMGR_DisableTrafficSegmatation();
    #endif
}

static BOOL_T SWDRV_LocalSetTrafficSegmatation( SYS_TYPE_Uport_T    *uplink_uport_list,
                                                UI32_T              uplink_uport_list_cnt,
                                                SYS_TYPE_Uport_T    *downlink_uport_list,
                                                UI32_T              downlink_uport_list_cnt)
{
    #if(SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == FALSE)
#if 0
        return HRDRV_SetPrivateVlan(uplink_port_list, downlink_port_list);
#endif
    #else
#if 0
        return DEV_SWDRVL4_PMGR_SetTrafficSegmatation(uplink_uport_list, uplink_uport_list_cnt,
                                                 downlink_uport_list, downlink_uport_list_cnt);
#endif
    #endif
    return FALSE;  /*added by Jinhua Wei ,to remove warning ,becaued control reaches end of non-void function*/
}

static BOOL_T SWDRV_LocalResetTrafficSegmatation(void)
{
    #if(SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == FALSE)
        return HRDRV_ResetPrivateVlan();
    #else
        return DEV_SWDRVL4_PMGR_ResetTrafficSegmatation();
    #endif
}
static BOOL_T SWDRV_LocalSetTrafficSegmatationByPortlist(UI8_T *uplink_port_list,
                                                         UI8_T *downlink_port_list)
{
    #if(SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == FALSE)
        return HRDRV_SetPrivateVlan(uplink_port_list, downlink_port_list);
    #else
        return DEV_SWDRVL4_PMGR_SetTrafficSegmatationByPortlist(uplink_port_list, downlink_port_list);
    #endif
}
#endif /* End of SYS_CPNT_PORT_TRAFFIC_SEGMENTATION is TRUE */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static BOOL_T SWDRV_LocalSetPrivateVlanPortlistBySessionId(UI32_T session_id,
                                                      UI8_T  *uplink_port_list,
                                                      UI8_T  *downlink_port_list)
{
    return DEV_SWDRVL4_PMGR_SetPrivateVlanPortlistBySessionId(
                session_id, uplink_port_list, downlink_port_list);
}/* End of SWDRV_LocalSetPrivateVlanPortlistBySessionId() */

static BOOL_T SWDRV_LocalDeletePrivateVlanPortlistBySessionId(UI32_T session_id,
                                                      UI8_T  *uplink_port_list,
                                                      UI8_T  *downlink_port_list)
{
    return DEV_SWDRVL4_PMGR_DeletePrivateVlanPortlistBySessionId(
                session_id, uplink_port_list, downlink_port_list);
}/* End of SWDRV_LocalDeletePrivateVlanPortlistBySessionId() */

static BOOL_T SWDRV_LocalEnablePrivateVlanUplinkToUplinkBlockingMode()
{
    return DEV_SWDRVL4_PMGR_SetPrivateVlanUplinkPortMode(TRUE);
}/* End of SWDRV_LocalEnablePrivateVlanUplinkToUplinkBlockingMode() */

static BOOL_T SWDRV_LocalDisablePrivateVlanUplinkToUplinkBlockingMode()
{
    return DEV_SWDRVL4_PMGR_SetPrivateVlanUplinkPortMode(FALSE);
}/* End of SWDRV_LocalDisablePrivateVlanUplinkToUplinkBlockingMode() */

static BOOL_T SWDRV_LocalSetPrivateVlanTrunkMode(UI32_T session_id, UI32_T trunk_id, BOOL_T is_uplink)
{
    return DEV_SWDRVL4_PMGR_SetPrivateVlanTrunkMode(session_id, trunk_id, is_uplink);
}
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

/***************************************************************************/
/* Rate Limit APIs                                                         */
/***************************************************************************/
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWDRV_LocalEnablePortIngressRateLimit(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

/*modify Macro ECN430_FB2,michael.wang 2008-6-25 */
#if 1
    #if((SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
        return TRUE;//return RULE_CTRL_EnableRateLimit(unit, port);/* anzhen.zheng, 6/4/2008 */
    #else
        return DEV_SWDRVL4_PMGR_EnablePortIngressRateLimit(unit, port);
    #endif
#else /* ES4626H */
#if (SYS_CPNT_HRDRV == FALSE)
    return DEV_SWDRVL4_PMGR_EnablePortIngressRateLimit(unit, port);
#else
    #if(defined(STRATA_SWITCH)||defined(XGS_SWITCH))
        return HRDRV_EnablePortIngressRateLimit(unit, port) ;
    #else
        return TRUE;
    #endif
#endif
#endif /* ES4626H */
}

static BOOL_T SWDRV_LocalDisablePortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

/*modify Macro ECN430_FB2,michael.wang 2008-6-25 */
#if 1
    #if((SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
        return RULE_CTRL_DeleteRateLimit(unit, port, trunk_id);/* anzhen.zheng, 6/4/2008 */
    #else /* SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE */
        return DEV_SWDRVL4_PMGR_DisablePortIngressRateLimit(unit, port);
    #endif
#else /* ES4626H */
    #if (SYS_CPNT_HRDRV == FALSE)
        return DEV_SWDRVL4_PMGR_DisablePortIngressRateLimit(unit, port);
    #else
        #if(defined(STRATA_SWITCH)||defined(XGS_SWITCH)) && (SYS_CPNT_HRDRV == TRUE)
            return HRDRV_DisablePortIngressRateLimit(unit, port);
        #else
            return TRUE;
        #endif
    #endif
#endif /* ES4626H */
}


static BOOL_T SWDRV_LocalSetPortIngressRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id, UI32_T rate)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

/*modify Macro ECN430_FB2,michael.wang 2008-6-25 */
#if 1
    #if((SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
        return RULE_CTRL_SetRateLimit(unit, port, trunk_id, rate);/* anzhen.zheng, 9/10/2008 */
    #else
        return DEV_SWDRVL4_PMGR_SetPortIngressRateLimit(unit, port, rate);
    #endif
#else /* no ES4626H */
    #if (SYS_CPNT_HRDRV == FALSE)
        return DEV_SWDRVL4_PMGR_SetPortIngressRateLimit(unit, port, rate);
    #else /* #else SYS_CPNT_HRDRV == TRUE */
        #if(defined(STRATA_SWITCH)||defined(XGS_SWITCH))
        return HRDRV_SetPortIngressRateLimit(unit, port, rate);
        #endif
        return TRUE;
    #endif
#endif
}
#endif /* SYS_CPNT_INGRESS_RATE_LIMIT */

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWDRV_LocalEnablePortEgressRateLimit(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_EnablePortEgressRateLimit(unit, port);
}

static BOOL_T SWDRV_LocalDisablePortEgressRateLimit(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_DisablePortEgressRateLimit(unit, port);
}

static BOOL_T SWDRV_LocalSetPortEgressRateLimit(UI32_T unit, UI32_T port, UI32_T rate)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortEgressRateLimit(unit, port, rate);
}
#endif

/***************************************************************************/
/* Jumbo Frame APIs                                                        */
/***************************************************************************/
#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
static BOOL_T SWDRV_LocalEnableJumboFrame(void)
{
    return DEV_SWDRV_PMGR_EnableJumboFrame();
}
static BOOL_T SWDRV_LocalDisableJumboFrame(void)
{
    return DEV_SWDRV_PMGR_DisableJumboFrame();
}
#endif

/***************************************************************************/
/* WRR APIs                                                                */
/***************************************************************************/
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
static BOOL_T SWDRV_LocalSetEgressSchedulingMethod(UI32_T method)
{
    return DEV_SWDRVL4_PMGR_SetEgressSchedulingMethod(method);
}
#endif

static BOOL_T SWDRV_LocalSetPortEgressSchedulingMethod(UI32_T unit, UI32_T port, UI32_T method)
{
#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */
    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif

    /* 2008-06-02: Jinfeng.Chen: modified for FireBolt2, it supports the per port set
     * return DEV_SWDRVL4_PMGR_SetEgressSchedulingMethod(method);
     */
    return DEV_SWDRVL4_PMGR_SetPortEgressSchedulingMethod(unit, port, method);
}

static BOOL_T SWDRV_LocalEnablePortWrrQueueWeight(void)
{
    return DEV_SWDRVL4_PMGR_SetEgressSchedulingMethod(DEV_SWDRVL4_WeightedFairRoundRobinScheduling);
}

static BOOL_T SWDRV_LocalDisablePortWrrQueueWeight(void)
{
    return DEV_SWDRVL4_PMGR_SetEgressSchedulingMethod(DEV_SWDRVL4_StrictPriorityScheduling);
}

#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
static BOOL_T SWDRV_LocalSetWrrQueueWeight(UI32_T q_id, UI32_T weight)
{
    return DEV_SWDRVL4_PMGR_SetWrrQueueWeight(q_id, weight);
}

static BOOL_T SWDRV_LocalSetStrictPriorityQueue(UI32_T q_id)
{
    return DEV_SWDRVL4_PMGR_SetStrictPriorityQueue(q_id);
}
#endif

static BOOL_T SWDRV_LocalSetPortWrrQueueWeight(UI32_T unit, UI32_T port, UI32_T q_id, UI32_T weight)
{
#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortWrrQueueWeight(unit, port, q_id, weight);
}

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
static BOOL_T SWDRV_LocalSetPortComboForcedMode(UI32_T unit, UI32_T port, UI32_T forcedmode
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
, UI32_T fiber_speed
#endif
)
{
    UI32_T config_forcedmode = forcedmode;
    UI32_T config_fiber_speed = VAL_portType_other;

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
    /* fiber_speed is only used for sfpForced,
     * for other mode, always take fiber_speed as VAL_portType_other
     */
    if (forcedmode == VAL_portComboForcedMode_sfpForced)
    {
        config_fiber_speed = fiber_speed;
    }
#endif

    /* for none mode,
     * select appropriate mode to config chip
     */
    if (forcedmode == VAL_portComboForcedMode_none)
    {
        UI32_T media_cap = 0;

        STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

        if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER))
        {
            config_forcedmode = VAL_portComboForcedMode_copperForced;
        }
        else
        {
            config_forcedmode = VAL_portComboForcedMode_sfpForced;
        }
    }

    /* config chip.
     */
    if (!SWDRV_LocalSetPortComboForcedModeToChip(port, TRUE, config_forcedmode, config_fiber_speed))
    {
        return FALSE;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_LocalSetPortComboForcedModeToChip
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set active medium type to chip
 * INPUT   : port           -- which port to set
 *           is_user_cfg    -- is trigger by upper layer or not
 *           forcedmode     -- valid only if is_user_cfg == TRUE
 *           fiber_speed    -- valid only if is_user_cfg == TRUE
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_LocalSetPortComboForcedModeToChip(UI32_T port, BOOL_T is_user_cfg, UI32_T forcedmode, UI32_T fiber_speed)
{
    static UI32_T fiber_type_list[] = {
        VAL_portType_hundredGBaseQSFP,
        VAL_portType_fortyGBaseQSFP,
        VAL_portType_twentyFiveGBaseSFP,
        VAL_portType_tenGBaseSFP,
        VAL_portType_thousandBaseSfp,
        VAL_portType_thousandBaseSfp,
        VAL_portType_hundredBaseFX
    };

    SWDRV_Port_Info_T swdrv_port_info;
    UI32_T unit;
    UI32_T cfg_forcedmode, cfg_fiber_speed = VAL_portType_other;
    UI32_T hw_forcedmode;
    UI32_T mau_type, mau_type_speed;
    UI32_T tmp_mau_type, tmp_mau_type_speed;
    UI32_T update_port_type = VAL_portType_other;
    UI32_T sfp_index = 0;
    BOOL_T fiber_medium_is_active;
    BOOL_T find_alternate_fiber_type = TRUE;
    BOOL_T config_chip;
    BOOL_T swdrv_provision_complete;
    BOOL_T swdrv_port_sfp_present = FALSE;

    SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
    SWDRV_OM_GetSystemInfoStackId(&unit);
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

    if(STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
        SWDRV_OM_GetPortSfpPresent(sfp_index, &swdrv_port_sfp_present);

    /* if no user cfg specified, read cfg from OM.
     */
    if (is_user_cfg)
    {
        cfg_forcedmode = forcedmode;
        cfg_fiber_speed = fiber_speed;
    }
    else
    {
        cfg_forcedmode = swdrv_port_info.forcedmode;
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        cfg_fiber_speed = swdrv_port_info.fiber_speed;
#endif
    }

    /* determine if fiber medium is active or not.
     */
    if ((cfg_forcedmode == VAL_portComboForcedMode_sfpPreferredAuto &&
            swdrv_port_sfp_present) ||
        (cfg_forcedmode == VAL_portComboForcedMode_sfpForced))
    {
        fiber_medium_is_active = TRUE;
    }
    else
    {
        fiber_medium_is_active = FALSE;
    }

    mau_type = SYS_VAL_dot3MauTypeOther;

    /* determine new port type.
     *
     * if fiber medium is active is
     *     update port type to fiber port type,
     * otherwise,
     *     update port type to default port type
     */
    if (fiber_medium_is_active)
    {
        SWDRV_LocalGetSfpPortType(port, &update_port_type, &mau_type, &mau_type_speed);

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        /* if fiber port type is pre-specified, overwrite it.
         */
        if (cfg_fiber_speed != VAL_portType_other)
        {
            /* if detected mau type doesn't match up with user-specified type,
             * ignore detected mau type.
             */
            if (update_port_type != cfg_fiber_speed)
            {
                mau_type_speed = 0;
            }

            update_port_type = cfg_fiber_speed;
            find_alternate_fiber_type = FALSE;
        }
#endif
    }
    else
    {
        STKTPLG_POM_GetPortType(unit, port, &update_port_type);
        find_alternate_fiber_type = FALSE;
    }

    if (mau_type == SYS_VAL_dot3MauTypeOther || mau_type_speed == 0)
    {
        UI32_T tmp_mau_type;

        /* use detected mau_type to specify interface type, such as CR or SR.
         * use alternate tmp_mau_type_speed to specify interface speed.
         */
        SWDRV_ConvertPortTypeToMauType(update_port_type, &tmp_mau_type, &mau_type_speed);

        if (mau_type == SYS_VAL_dot3MauTypeOther)
            mau_type = tmp_mau_type;
    }

    /* config chip
     *
     *                   sfpPreferredAuto sfpForced copperForced
     *                   ---------------- --------- ------------
     * HW medium detect  once             always    once
     * SW medium detect  always           always    always
     *
     * 'once' means to config chip only when the transaction is triggered by upper layer.
     */
#if (SYS_CPNT_SWDRV_COMBO_PORT_MEDIA_PREFERRED_AUTO_BY_HW == TRUE)
    config_chip = (is_user_cfg || forcedmode == VAL_portComboForcedMode_sfpForced);
    hw_forcedmode = forcedmode;
#else
    config_chip = TRUE;
    hw_forcedmode = fiber_medium_is_active ?
        VAL_portComboForcedMode_sfpForced : VAL_portComboForcedMode_copperForced;
#endif

    if (config_chip)
    {
        if (!SWDRV_IsSfpPortTypeSupported(unit, port, update_port_type) ||
            !DEV_SWDRV_PMGR_SetPortComboForcedMode(unit, port, hw_forcedmode, mau_type, mau_type_speed))
        {
            if (find_alternate_fiber_type)
            {
                UI32_T tmp_mau_type, tmp_mau_type_speed;
                int i;

                for (i = 0; i < sizeof(fiber_type_list)/sizeof(*fiber_type_list); i++)
                {
                    if (update_port_type == fiber_type_list[i])
                    {
                        continue;
                    }

                    if (!SWDRV_IsSfpPortTypeSupported(unit, port, fiber_type_list[i]))
                    {
                        continue;
                    }

                    /* use detected mau_type to specify interface type, such as CR or SR.
                     * use alternate tmp_mau_type_speed to specify interface speed.
                     */
                    SWDRV_ConvertPortTypeToMauType(fiber_type_list[i], &tmp_mau_type, &tmp_mau_type_speed);

                    if (DEV_SWDRV_PMGR_SetPortComboForcedMode(unit, port, hw_forcedmode, mau_type, tmp_mau_type_speed))
                    {
                        update_port_type = fiber_type_list[i];
                        break;
                    }
                }
                if (i >= sizeof(fiber_type_list)/sizeof(*fiber_type_list))
                {
                    SWDRV_OM_SetPortInfoPortType(port, VAL_portType_other);
                    return FALSE;
                }
            }
            else
            {
                SWDRV_OM_SetPortInfoPortType(port, VAL_portType_other);
                return FALSE;
            }
        }
    }

    /* update database.
     */
    if (is_user_cfg)
    {
        SWDRV_OM_SetComboForceMode(port, cfg_forcedmode);
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        SWDRV_OM_SetComboForceSpeed(port, cfg_fiber_speed);
#endif
    }

    /* update port type
     *
     * chip port config maybe reset after devdrv update interface setting,
     * so always notify port type changed for upper layer to reapply user-
     * config to chip.
     */
    if (update_port_type != VAL_portType_other)
    {
        SWDRV_OM_SetPortInfoPortType(port, update_port_type);

        if (swdrv_port_info.port_type == VAL_portType_other)
        {
            SWDRV_Notify_ModuleTypeChanged(unit, port, swdrv_port_info.module_id, update_port_type);
            SWDRV_OM_SetPortInfoIsAutoNeg(port, TRUE);
        }
        else
        if (swdrv_provision_complete || is_user_cfg)
        {
            SWDRV_Notify_PortTypeChanged(unit, port, update_port_type);
            SWDRV_OM_SetPortInfoIsAutoNeg(port, TRUE);
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_LocalGetSfpPortType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get current port type for specified sfp port
 * INPUT   : port
 * OUTPUT  : port_type_p
 *           mau_type_p         -- SYS_VAL_dot3MauType
 *           mau_type_speed_p   -- data rate of mau type
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_LocalGetSfpPortType(UI32_T port, UI32_T *port_type_p, UI32_T *mau_type_p, UI32_T *mau_type_speed_p)
{
    UI32_T unit;
    UI32_T mau_type, mau_type_speed;
    UI32_T tmp_mau_type, tmp_mau_type_speed;
    UI32_T port_type;

    SWDRV_OM_GetSystemInfoStackId(&unit);

    port_type = VAL_portType_other;
    mau_type = SYS_VAL_dot3MauTypeOther;
    mau_type_speed = 0;

    /* eeprom -> mau_type/mau_type_speed -> port_type
     */
    if (SWDRV_LocalGetSfpMauType(port, &mau_type, &mau_type_speed))
    {
        if (mau_type_speed >= 100000)
            port_type = VAL_portType_hundredGBaseQSFP;
        else if (mau_type_speed >= 40000)
            port_type = VAL_portType_fortyGBaseQSFP;
        else if (mau_type_speed >= 25000)
            port_type = VAL_portType_twentyFiveGBaseSFP;
        else if (mau_type_speed >= 10000)
            port_type = VAL_portType_tenGBaseSFP;
        else if (mau_type_speed >= 1000)
            port_type = VAL_portType_thousandBaseSfp;
        else if (mau_type_speed >= 100)
            port_type = VAL_portType_hundredBaseFX;
        else
        {
            UI32_T media_cap;

            /* For unidentifiable transceiver,
             * assume transceiver type is
             *     1) port type defined in board info for non combo port.
             *     2) SYS_DFLT_STKTPLG_MEDIA_TYPE_FOR_UNIDENTIFIABLE_SFP for combo port.
             */

            if (STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap) &&
                (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) &&
                (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
            {
                port_type = SYS_DFLT_STKTPLG_MEDIA_TYPE_FOR_UNIDENTIFIABLE_SFP;
                mau_type == SYS_VAL_dot3MauTypeOther;
            }
        }
    }

    /* get board default port type if port_type is undetermined.
     */
    if (port_type == VAL_portType_other)
    {
        STKTPLG_POM_GetPortType(unit, port, &port_type);
        mau_type = SYS_VAL_dot3MauTypeOther;
    }

    /* get mau_type from port_type if mau_type is undetermined.
     */
    if (mau_type == SYS_VAL_dot3MauTypeOther || mau_type_speed == 0)
    {
        SWDRV_ConvertPortTypeToMauType(port_type, &tmp_mau_type, &tmp_mau_type_speed);

        if (mau_type == SYS_VAL_dot3MauTypeOther)
            mau_type = tmp_mau_type;
        if (mau_type_speed == 0)
            mau_type_speed = tmp_mau_type_speed;
    }

    if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
    {
        BACKDOOR_MGR_Printf("%s: uport:%u/%u port_type:%u mau_type:%u/%u\n", __func__, unit, port, port_type, mau_type, mau_type_speed);
    }

    if (port_type_p)
        *port_type_p = port_type;
    if (mau_type_p)
        *mau_type_p = mau_type;
    if (mau_type_speed_p)
        *mau_type_speed_p = mau_type_speed;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_LocalGetSfpMauType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get mau type from SFP eeprom
 * INPUT   : port
 * OUTPUT  : mau_type_p         -- SYS_VAL_dot3MauType
 *           mau_type_speed_p   -- data rate of mau type
 * RETURN  : TRUE if SFP is installed
 *           FALSE if SFP is not installed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_LocalGetSfpMauType(UI32_T port, UI32_T *mau_type_p, UI32_T *mau_type_speed_p)
{
#define BITRATE_TO_DATARATE(bitrate) \
        ((bitrate >= 1000) ? 100000 : \
        ((bitrate >= 400) ? 40000 : \
        ((bitrate >= 100) ? 10000 : \
        ((bitrate >= 10) ? 1000 : \
        ((bitrate >= 1) ? 100 : \
        0)))))

    UI32_T unit;
    UI32_T sfp_index;
    BOOL_T swdrv_port_sfp_present = FALSE;
    UI32_T bitrate = 0;
    UI32_T mau_type, mau_type_speed;
#if (SYS_CPNT_STKTPLG_DETECT_SFP_TYPE == TRUE)
    BOOL_T sfp_info_valid = FALSE;
    SWDRV_TYPE_SfpInfo_T sfp_info;
#endif

    SWDRV_OM_GetSystemInfoStackId(&unit);

    if (!STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
        {
            BACKDOOR_MGR_Printf("%s: uport:%u/%u not a sfp port\n", __func__, unit, port);
        }
        return FALSE;
    }

    SWDRV_OM_GetPortSfpPresent(sfp_index, &swdrv_port_sfp_present);

    if (!swdrv_port_sfp_present)
    {
        if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
        {
            BACKDOOR_MGR_Printf("%s: uport:%u/%u not present\n", __func__, unit, port);
        }
        return FALSE;
    }

    mau_type = SYS_VAL_dot3MauTypeOther;
    mau_type_speed = 0;

#if (SYS_CPNT_STKTPLG_DETECT_SFP_TYPE == TRUE)
/* macro for SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE
 */
#define mau_type \
    (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE) && \
     BACKDOOR_MGR_Printf("%s:%d: uport:%u 10g:0x%02x eth:0x%02x ext:0x%02x\n", \
        __func__,__LINE__, \
        (unsigned int)port, \
        (unsigned int)sfp_info.transceiver[0], \
        (unsigned int)sfp_info.transceiver[3], \
        (unsigned int)sfp_info.transceiver_1)),\
    mau_type
#define mau_type_speed \
    (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE) && \
     BACKDOOR_MGR_Printf("%s:%d: uport:%u bitrate:%u\n", \
        __func__,__LINE__, \
        (unsigned int)port, \
        (unsigned int)bitrate)),\
    mau_type_speed

    SWDRV_OM_GetPortSfpInfoValid(sfp_index, &sfp_info_valid);

    if (!sfp_info_valid)
    {
        if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
        {
            BACKDOOR_MGR_Printf("%s: uport:%u/%u can't get sfp info\n", __func__, unit, port);
        }
        return TRUE;
    }

    SWDRV_OM_GetPortSfpInfo(sfp_index, &sfp_info);

    if (sfp_info.bitrate < 255)
    {
        bitrate = sfp_info.bitrate * 100;
    }
    else if (sfp_info.bitrate_in_250mbd < 255)
    {
        bitrate = sfp_info.bitrate_in_250mbd * 250;
    }

    if (sfp_info.identifier == SWDRV_TYPE_GBIC_ID_SFP)
    {
        if (sfp_info.transceiver[0] & SWDRV_TYPE_GBIC_10G_ETH_COMP_CODES_10GBASE_ER)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseER;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_GBIC_10G_ETH_COMP_CODES_10GBASE_LRM)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLRM;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_GBIC_10G_ETH_COMP_CODES_10GBASE_LR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_GBIC_10G_ETH_COMP_CODES_10GBASE_SR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseSR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_BASE_BX10)
        {
            /* 100BASE-BX10-D  1550nm
             * 100BASE-BX10-U  1310nm
             * 1000BASE-BX10-D 1490nm
             * 1000BASE-BX10-U 1310nm
             */
            int is_upstream;

            is_upstream = (sfp_info.wavelength == 1310);
            mau_type_speed = BITRATE_TO_DATARATE(bitrate);

            if (mau_type_speed == 100)
            {
                mau_type = is_upstream ? SYS_VAL_dot3MauType100BaseBX10U : SYS_VAL_dot3MauType100BaseBX10D;
            }
            else if (mau_type_speed == 1000)
            {
                mau_type = is_upstream ? SYS_VAL_dot3MauType1000BaseBX10U : SYS_VAL_dot3MauType1000BaseBX10D;
            }
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_100BASE_FX)
        {
            mau_type = SYS_VAL_dot3MauType100baseFXFD;
            mau_type_speed = 100;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_100BASE_LX_LX10)
        {
            mau_type = SYS_VAL_dot3MauType100BaseLX10;
            mau_type_speed = 100;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_1000BASE_T)
        {
            mau_type = SYS_VAL_dot3MauType1000baseTFD;
            mau_type_speed = 1000;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_1000BASE_CX)
        {
            mau_type = SYS_VAL_dot3MauType1000baseCXFD;
            mau_type_speed = 1000;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_1000BASE_LX)
        {
            mau_type = SYS_VAL_dot3MauType1000baseLXFD;
            mau_type_speed = 1000;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_1000BASE_SX)
        {
            mau_type = SYS_VAL_dot3MauType1000baseSXFD;
            mau_type_speed = 1000;
        }
        else if (sfp_info.transceiver[3] & SWDRV_TYPE_GBIC_ETH_COMP_CODES_1000BASE_SX)
        {
            mau_type = SYS_VAL_dot3MauType1000baseSXFD;
            mau_type_speed = 1000;
        }
    }
    else if (sfp_info.identifier == SWDRV_TYPE_GBIC_ID_XFP)
    {
        if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_SR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseSR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_LR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_ER)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseER;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_LRM)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLRM;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_SW)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseSW;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_LW)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLW;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_XFP_10G_ETH_COMP_CODES_10GBASE_EW)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseEW;
            mau_type_speed = 10000;
        }
    }
    else if (sfp_info.identifier == SWDRV_TYPE_GBIC_ID_QSFP ||
             sfp_info.identifier == SWDRV_TYPE_GBIC_ID_QSFP_PLUS ||
             sfp_info.identifier == SWDRV_TYPE_GBIC_ID_QSFP28)
    {
        bitrate *= 4;

        if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_10GBASE_LRM)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLRM;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_10GBASE_LR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseLR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_10GBASE_SR)
        {
            mau_type = SYS_VAL_dot3MauType10GbaseSR;
            mau_type_speed = 10000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_40GBASE_CR4)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseCR4;
            mau_type_speed = 40000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_40GBASE_SR4)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseSR4;
            mau_type_speed = 40000;
        }
        else if (sfp_info.transceiver[0] & SWDRV_TYPE_QSFP_40G_ETH_COMP_CODES_40GBASE_LR4)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseLR4;
            mau_type_speed = 40000;
        }
        else if (sfp_info.connector == SWDRV_TYPE_GBIC_CONNECTOR_MPO_PARALLEL_OPTIC)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseSR4;
            mau_type_speed = 40000;
        }
        else if (sfp_info.connector == SWDRV_TYPE_GBIC_CONNECTOR_COPPER_PIGTAIL)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseCR4;
            mau_type_speed = 40000;
        }
    }

    if (sfp_info.transceiver_1 != 0)
    {
        if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100GBASE_SR4)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseSR4; /* workaround: alternate dot3MauType */
            mau_type_speed = 100000;
        }
        else if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100GBASE_LR4)
        {
            mau_type = SYS_VAL_dot3MauType100GbaseLR4;
            mau_type_speed = 100000;
        }
        else if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100GBASE_ER4)
        {
            mau_type = SYS_VAL_dot3MauType100GbaseER4;
            mau_type_speed = 100000;
        }
        else if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100GBASE_SR10)
        {
            mau_type = SYS_VAL_dot3MauType100GbaseSR10;
            mau_type_speed = 100000;
        }
        else if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100G_CWDM4_FEC)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseSR4; /* workaround: alternate dot3MauType */
            mau_type_speed = 100000;
        }
        else if (sfp_info.transceiver_1 == SWDRV_TYPE_GBIC_EXT_COMP_CODES_100GBASE_CR4)
        {
            mau_type = SYS_VAL_dot3MauType40GbaseCR4; /* workaround: alternate dot3MauType */
            mau_type_speed = 100000;
        }
    }

    if (mau_type == SYS_VAL_dot3MauTypeOther && sfp_info.bitrate != 0)
    {
        mau_type_speed = BITRATE_TO_DATARATE(bitrate);
    }

/* macro for SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE
 */
#undef mau_type
#undef mau_type_speed
#endif /* (SYS_CPNT_STKTPLG_DETECT_SFP_TYPE == TRUE) */

    if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
    {
        BACKDOOR_MGR_Printf("%s: uport:%u/%u mau_type:%u/%u\n", __func__, unit, port, mau_type, mau_type_speed);
    }

    if (mau_type_p)
        *mau_type_p = mau_type;
    if (mau_type_speed_p)
        *mau_type_speed_p = mau_type_speed;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_ConvertPortTypeToMauType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get default mau type for specified port type
 * INPUT   : port_type
 * OUTPUT  : mau_type_p         -- SYS_VAL_dot3MauType
 *           mau_type_speed_p   -- data rate of mau type
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_ConvertPortTypeToMauType(UI32_T port_type, UI32_T *mau_type_p, UI32_T *mau_type_speed_p)
{
    UI32_T mau_type, mau_type_speed;

    switch (port_type)
    {
        case VAL_portType_hundredBaseTX:
            mau_type = SYS_VAL_dot3MauType100baseTXFD;
            mau_type_speed = 100;
            break;
        case VAL_portType_hundredBaseFX:
            mau_type = SYS_VAL_dot3MauType100baseFXFD;
            mau_type_speed = 100;
            break;
        case VAL_portType_thousandBaseT:
            mau_type = SYS_VAL_dot3MauType1000baseTFD;
            mau_type_speed = 1000;
            break;
        case VAL_portType_thousandBaseSfp:
            mau_type = SYS_VAL_dot3MauType1000baseTFD;
            mau_type_speed = 1000;
            break;
        case VAL_portType_tenGBaseT:
            mau_type = SYS_VAL_dot3MauType10GbaseT;
            mau_type_speed = 10000;
            break;
        case VAL_portType_tenGBaseXFP:
            mau_type = SYS_VAL_dot3MauType10GbaseR;
            mau_type_speed = 10000;
            break;
        case VAL_portType_tenGBaseSFP:
            mau_type = SYS_VAL_dot3MauType10GbaseX;
            mau_type_speed = 10000;
            break;
        case VAL_portType_fortyGBaseQSFP:
            mau_type = SYS_VAL_dot3MauType40GbaseCR4;
            mau_type_speed = 40000;
            break;
        case VAL_portType_hundredGBaseQSFP:
            mau_type = SYS_VAL_dot3MauType100GbaseCR10;
            mau_type_speed = 100000;
            break;
        case VAL_portType_twentyFiveGBaseSFP:
            mau_type = SYS_VAL_dot3MauType40GbaseCR4; /* workaround: alternate dot3MauType */
            mau_type_speed = 25000;
            break;
        default:
            mau_type = SYS_VAL_dot3MauTypeOther;
            mau_type_speed = 0;
            break;
    }

    if (SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE))
    {
        BACKDOOR_MGR_Printf("%s: port_type:%u mau_type:%u/%u\n", __func__, port_type, mau_type, mau_type_speed);
    }

    if (mau_type_p)
        *mau_type_p = mau_type;
    if (mau_type_speed_p)
        *mau_type_speed_p = mau_type_speed;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_IsSfpPortTypeSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if the port type is supported or not
 * INPUT   : unit
 *           port
 *           port_type
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWDRV_IsSfpPortTypeSupported(UI32_T unit, UI32_T port, UI32_T port_type)
{
    SWDRV_PortAbility_T ability;
    BOOL_T is_supported;

    if (!SWDRV_LocalGetPortAbility(unit, port, &ability))
    {
        return FALSE;
    }

    switch (port_type)
    {
        case VAL_portType_hundredBaseTX:
            is_supported = ability.medium_fiber_100m;
            break;
        case VAL_portType_hundredBaseFX:
            is_supported = ability.medium_fiber_100m;
            break;
        case VAL_portType_thousandBaseSfp:
            is_supported = ability.medium_fiber_1000m;
            break;
        case VAL_portType_tenGBaseXFP:
            is_supported = ability.medium_fiber_10g;
            break;
        case VAL_portType_tenGBaseSFP:
            is_supported = ability.medium_fiber_10g;
            break;
        case VAL_portType_twentyFiveGBaseSFP:
            is_supported = ability.medium_fiber_25g;
            break;
        case VAL_portType_fortyGBaseQSFP:
            is_supported = ability.medium_fiber_40g;
            break;
        case VAL_portType_hundredGBaseQSFP:
            is_supported = ability.medium_fiber_100g;
            break;
        default:
            is_supported = TRUE;
            break;
    }

    return is_supported;
}
#endif

/***************************************************************************/
/* IPMC APIs                                                                */
/***************************************************************************/
static BOOL_T SWDRV_LocalEnableIPMC(void)
{
    DEV_SWDRV_PMGR_EnableIPMC(ALL_DEVICE_ID);
    DEV_SWDRV_PMGR_IPMC_DisableSourcePortCheck(ALL_DEVICE_ID);
    DEV_SWDRV_PMGR_IPMC_EnableSourceIPSearch(ALL_DEVICE_ID);

    return TRUE;
}

static BOOL_T SWDRV_LocalDisableIPMC(void)
{
    /* biker, 12/13/01, 21:11:31, disable ipmc in chip*/
    /* if did not disable it, snooping won't work correctly */
    /* currently, it only have local device, so use device = 0 */
    DEV_SWDRV_PMGR_DisableIPMC(ALL_DEVICE_ID);
    /* biker, 12/13/01, 21:13:26 */

    return TRUE;
}

static BOOL_T SWDRV_LocalEnableUMCASTIpTrap(void)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return DEV_HRDRV_AddUnknownIPMC2Cpu();
#else
    return DEV_SWDRV_PMGR_EnableUMCASTIpTrap();
#endif
}

static BOOL_T SWDRV_LocalDisableUMCASTIpTrap(void)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return DEV_HRDRV_RemoveUnknownIPMC2Cpu();
#else
    return DEV_SWDRV_PMGR_DisableUMCASTIpTrap();
#endif
}

static BOOL_T SWDRV_LocalEnableUMCASTMacTrap(void)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return DEV_HRDRV_AddUnknownIPMC2Cpu();
#else
    return DEV_SWDRV_PMGR_EnableUMCASTMacTrap();
#endif
}

static BOOL_T SWDRV_LocalDisableUMCASTMacTrap(void)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return DEV_HRDRV_RemoveUnknownIPMC2Cpu();
#else
    return DEV_SWDRV_PMGR_DisableUMCASTMacTrap();
#endif
}

#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SWDRV_LocalSetPortRestartAutoNego (UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_SetPortRestartAutoNego(unit, port);
}

static BOOL_T SWDRV_LocalSetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T remote_fault)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_SetPortAutoNegoRemoteFaultAdvertisement(unit, port, remote_fault);
}

static BOOL_T SWDRV_LocalGetPortAutoNegoRemoteFaultAdvertisement (UI32_T unit, UI32_T port, UI32_T *remote_fault)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortAutoNegoRemoteFaultAdvertisement(unit, port, remote_fault);
}

static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoSignalingState (UI32_T unit, UI32_T port, UI32_T *state)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortLinkPartnerAutoNegoSignalingState (unit, port, state);
}

static BOOL_T SWDRV_LocalGetPortAutoNegoProcessState (UI32_T unit, UI32_T port, UI32_T *state)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortAutoNegoProcessState(unit, port, state);
}

static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoCapa (UI32_T unit, UI32_T port, UI32_T *capabilities)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortLinkPartnerAutoNegoCapa(unit, port, capabilities);
}

static BOOL_T SWDRV_LocalGetPortLinkPartnerAutoNegoRemoteFault (UI32_T unit, UI32_T port, UI32_T *remote_fault)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortLinkPartnerAutoNegoRemoteFault(unit, port, remote_fault);
}

static BOOL_T SWDRV_LocalGetPortJabberState (UI32_T unit, UI32_T port, UI32_T *state)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortJabberState(unit, port, state);
}

static BOOL_T SWDRV_LocalGetPortFalseCarrierSenseCounter (UI32_T unit, UI32_T port, UI32_T *cntr)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_GetPortFalseCarrierSenseCounter(unit, port, cntr);
}

#endif

#if (SYS_HWCFG_SUPPORT_PD==TRUE)
static BOOL_T SWDRV_LocalGetPDPortStatus (UI32_T unit, UI32_T port, UI8_T *status_p, UI8_T *mode_p)
{
    UI32_T my_board_id;
    UI32_T dev_addr, reg_addr, reg_mask, pg_val, at_flag_val;
    UI8_T  reg_val;
    BOOL_T current_pg_status, current_at_flag;

    if(STKTPLG_OM_GetUnitBoardID(unit, &my_board_id)==FALSE)
    {
        printf("%s(%d): Failed to get my board id.\r\n", __FUNCTION__, __LINE__);
        return FALSE;
    }
    /* check whether the port supports PD
     */
    if(STKTPLG_OM_IsPoEPDPort(unit, port)==FALSE)
    {
        SYSFUN_Debug_Printf("%s(%d): Failed to get PD port info.\r\n", __FUNCTION__, __LINE__);
        *status_p = SWDRV_POWER_SOURCE_NONE;
        *mode_p = SWDRV_POWERED_DEVICE_MODE_NONE;
        return FALSE;
    }
    *status_p = SWDRV_POWER_SOURCE_DOWN; /* power source status: down */
    *mode_p = SWDRV_POWERED_DEVICE_MODE_NONE;

    /* check the Power status of the port
     */
    if(SYS_HWCFG_GetPDPortPowerStatusRegInfo(my_board_id, port, &dev_addr, &reg_addr, &reg_mask, &pg_val)==FALSE)
    {
        printf("%s(%d): Failed to get Power Good Status Register info.\r\n", __FUNCTION__, __LINE__);
        return FALSE;
    }

    if(I2CDRV_GetI2CInfo(dev_addr, reg_addr, 0x1, &reg_val)==FALSE)
    {
        printf("%s(%d): I2C read error.\r\n", __FUNCTION__, __LINE__);
        return FALSE;
    }

    current_pg_status = ((reg_val & reg_mask)==pg_val)?TRUE:FALSE;


    if(current_pg_status==TRUE)
    {
        *status_p = SWDRV_POWER_SOURCE_UP;
    }
    else
    {
        *status_p = SWDRV_POWER_SOURCE_DOWN;
    }

    if(*status_p == SWDRV_POWER_SOURCE_UP)
    {
        /* check the Power mode of the port
         */
        #if (SYS_HWCFG_SUPPORT_PD_MODE_DETECT == TRUE)
        if(SYS_HWCFG_GetPDPortPowerATFlagRegInfo(my_board_id, port, &dev_addr, &reg_addr, &reg_mask, &at_flag_val)==FALSE)
        {
            printf("%s(%d): Failed to get AT Flag Register info.\r\n", __FUNCTION__, __LINE__);
            return FALSE;
        }

        if(I2CDRV_GetI2CInfo(dev_addr, reg_addr, 0x1, &reg_val )==FALSE)
        {
            printf("%s(%d): I2C read error.\r\n", __FUNCTION__, __LINE__);
            return FALSE;
        }

        current_at_flag = ((reg_val & reg_mask)==at_flag_val)?TRUE:FALSE;


        if(current_at_flag == TRUE)
        {
            *mode_p = SWDRV_POWERED_DEVICE_MODE_AT;
        }
        else
        {
            *mode_p = SWDRV_POWERED_DEVICE_MODE_AF;
        }
        #endif
    }
    return TRUE;
}
#endif /* end if #if (SYS_HWCFG_SUPPORT_PD==TRUE) */

/***************************************************************************/
/* Other APIs                                                              */
/***************************************************************************/
/* for L2 stacking callback functions */

#if (SYS_CPNT_PORT_SECURITY == TRUE)
static BOOL_T SWDRV_LocalEnablePortSecurity(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_EnablePortSecurity(unit, port);
}

static BOOL_T SWDRV_LocalDisablePortSecurity(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_DisablePortSecurity(unit, port);
}

static BOOL_T SWDRV_LocalPortSecurityActionNone(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortSecurityMode(unit, port, VAL_portSecAction_none);

}

static BOOL_T SWDRV_LocalPortSecurityActionTrap(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortSecurityMode(unit, port, VAL_portSecAction_trap);
}

static BOOL_T SWDRV_LocalPortSecurityActionShutdown(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortSecurityMode(unit, port, VAL_portSecAction_shutdown);
}

static BOOL_T SWDRV_LocalPortSecurityActionTrapAndShutdown(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* JBOS requirement:
       When enter master mode, PRI_MGR try to init this feature,
         SWDRV should return TRUE and do nothing.
       When runtime, UIs try to set this feature,
         SWDRV should return FALSE to warring user.
     */

    if (SYS_ADPT_MGMT_PORT == port)
    {
        BOOL_T swdrv_provision_complete;

        SWDRV_OM_GetProvisionComplete(&swdrv_provision_complete);
        if(swdrv_provision_complete == FALSE)
            return TRUE;
        else
            return FALSE;
    }
#endif
    return DEV_SWDRVL4_PMGR_SetPortSecurityMode(unit, port, VAL_portSecAction_trapAndShutdown);
}

#endif

#if (SYS_CPNT_MAC_VLAN == TRUE)
static BOOL_T SWDRV_LocalSetMacVlanEntry(UI8_T *mac_address, UI8_T *mask, UI16_T vid, UI8_T priority)
{
    #if (SYS_CPNT_MAC_VLAN_IMPLEMENTED_BY_RULE  == TRUE)
    return RULE_CTRL_SetMacVlanEntry(mac_address, mask, vid, priority);
    #else
    return DEV_SWDRV_PMGR_SetMacVlanEntry(mac_address, vid, priority);
    #endif
}
static BOOL_T SWDRV_LocalDeleteMacVlanEntry(UI8_T *mac_address, UI8_T *mask)
{
#if (SYS_CPNT_MAC_VLAN_IMPLEMENTED_BY_RULE  == TRUE)
    return  RULE_CTRL_DeleteMacVlanEntry(mac_address, mask);
#else
    return DEV_SWDRV_PMGR_DeleteMacVlanEntry(mac_address);
#endif
}
#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
static BOOL_T SWDRV_LocalSetPortPowerSave(UI32_T unit, UI32_T port, BOOL_T status)
{
    BOOL_T ret;
    SWDRV_Port_Info_T swdrv_port_info;

    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
    ret = DEV_SWDRV_PMGR_SetPortPowerSave(unit, port, status ,swdrv_port_info.link_status);
    return ret;
}
#endif /* end of #if (SYS_CPNT_POWER_SAVE == TRUE) */

static BOOL_T SWDRV_LocalTrapUnknownIpMcastToCPU(BOOL_T to_cpu, BOOL_T flood, UI32_T vid)
{
#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE == TRUE)
    if (vid == 0)
     /* when trap unknown packet by rule, there is no per vlan setting, only global setting
        if vid != 0, do not change the rule */
    {
    RULE_TYPE_CpuRuleInfo_T rule_info;

    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2CpuForSwdrv(to_cpu, RULE_TYPE_PacketType_UNKNOWN_IPMC, &rule_info);
    }
    else
        return TRUE;
#else
    return DEV_SWDRV_PMGR_TrapUnknownIpMcastToCPU(to_cpu, flood, vid);
#endif
} /* end of SWDRV_LocalTrapUnknownIpMcastToCPU */

#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SWDRV_LocalTrapUnknownIpv6McastToCPU(BOOL_T to_cpu, BOOL_T flood, UI32_T vid)
{
#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE == TRUE)
    RULE_TYPE_CpuRuleInfo_T rule_info;

    rule_info.common.to_cpu = to_cpu;
    rule_info.common.flood = flood;

    return RULE_CTRL_TrapPacket2CpuForSwdrv(to_cpu, RULE_TYPE_PacketType_UNKNOWN_IPV6MC, &rule_info);
#else
    return DEV_SWDRV_PMGR_TrapUnknownIpv6McastToCPU(to_cpu, flood, vid);
#endif
} /* end of SWDRV_LocalTrapUnknownIpv6McastToCPU */
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SWDRV_LocalTrapIpv6PIMToCPU(BOOL_T to_cpu)
{
    return RULE_CTRL_TrapPacket2CpuForSwdrv(to_cpu, RULE_TYPE_PacketType_PIM6, NULL);
} /* end of SWDRV_LocalTrapIpv6PIMToCPU */
#endif

/******************* Stacking Function : Slave SubRoutine *************************/
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveProvisionComplete(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI8_T status;

    SWDRV_OM_SetProvisionComplete(TRUE);
#if 1/*add by fen.wang*/
#if (SYS_CPNT_UNIT_HOT_SWAP == TRUE)

    STKTPLG_PMGR_SetSlavePastMasterMac();
   // DEV_SWDRV_PMGR_SavePreHotSwapPortMapping();
#endif
#endif
    status = TRUE;

    /* Module is to set SetBlockCPUForwardingAttr after it ProvisionComplete */
#if (SYS_CPNT_CPU_INTERFACE_CPU_JOIN_VLAN == TRUE)
    if(STKTPLG_POM_IsOptionModule())
        DEV_SWDRV_PMGR_SetBlockCPUForwardingAttr();
#endif
    return TRUE;
}

static BOOL_T SlaveEnablePortAdmin(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortAdmin( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortAdmin(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortAdmin( request_p->unit, request_p->port );
}

static BOOL_T SlaveSetPortCfgSpeedDuplex(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortCfgSpeedDuplex( request_p->unit, request_p->port,request_p->port_cfg_speed_duplex );
}

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
static BOOL_T SlaveSetPort1000BaseTForceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPort1000BaseTForceMode( request_p->unit, request_p->port, request_p->port_cfg_force_1000t_mode );
}
#endif

static BOOL_T SlaveGetCopperEnergyDetect(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_COPPEER_ENERGY_DETECT) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetCopperEnergyDetect(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveEnablePortAutoNeg(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortAutoNeg( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortAutoNeg(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortAutoNeg( request_p->unit,  request_p->port );
}

static BOOL_T SlaveEnablePortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortCfgFlowCtrl( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortCfgFlowCtrl( request_p->unit, request_p->port );
}

static BOOL_T SlaveSetPortCfgFlowCtrl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortCfgFlowCtrl(request_p->unit, request_p->port, request_p->combo_forcedmode);
}

static BOOL_T SlaveSetPortAutoNegCapability(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortAutoNegCapability( request_p->unit,  request_p->port,  request_p->port_cfg_capability );
}

static BOOL_T SlaveSetPortSTAState(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortSTAState( request_p->unit, request_p->port_cfg_vid,
                                       request_p->port, request_p->port_cfg_state );
}

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
static BOOL_T SlaveEnableMultiSTA(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableMultiSTA();
}

static BOOL_T SlaveDisableMultiSTA(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableMultiSTA();
}

static BOOL_T SlaveAddVlanToMst(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddVlanToMst( request_p->vlan_vid, request_p->port_cfg_mstid );
}

static BOOL_T SlaveDeleteVlanFromMst(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeleteVlanFromMst( request_p->vlan_vid, request_p->port_cfg_mstid );
}

#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

static BOOL_T SlaveSetPortXstpState(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{

    return SWDRV_LocalSetPortXstpState( request_p->port_cfg_mstid,
                                        request_p->port_cfg_vlan_count,
                                        (UI16_T *)request_p->port_cfg_vlan_list,
                                        request_p->port_cfg_unit_id,
                                        request_p->port,
                                        request_p->port_cfg_state );
}


static BOOL_T SlaveSetPortStateWithMstidx(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortStateWithMstidx( request_p->port_cfg_mstid,
                                                request_p->port_cfg_unit_id,
                                                request_p->port,
                                                request_p->port_cfg_state );
}


static BOOL_T SlaveGetPortType(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_TYPE) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->data.u32 = STKTPLG_PORT_TYPE_NOT_EXIST;
    isc_reply_p->return_value.bool = SWDRV_LocalGetPortType(request_p->unit,request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
static BOOL_T SlaveGetPortLoopbackTestResult(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T max_port_number, drv_unit;

    /* Reply is not necessary before provision complete,
     * and the function used before provision complete only
     */
    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T      unit_bitmap = 0;
        UI32_T      module_port_num = 0;
        UI32_T      stack_id;

        if (0 == (unit_bitmap |= ((0x01) << (request_p->unit-1))))
        {
            return FALSE;
        }

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(UI32_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_LOOPBACK_TEST_RESULT) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        /* Copy data from buffer to packet and send */
        isc_buffer_p->ServiceID   = SWDRV_GET_PORT_LOOPBACK_TEST_RESULT;
        isc_buffer_p->unit        = stack_id;

        /* Set option_module field, if reply from module */
        if (STKTPLG_POM_IsOptionModule())
        {
           isc_buffer_p->option_module = SWDRV_OPTION_MODULE;
           STKTPLG_POM_GetLocalModulePortNumber(&module_port_num);
           isc_buffer_p->option_num_port = module_port_num;
        }

        if (FALSE == SWDRV_LocalGetPortLoopbackTestResult(isc_buffer_p->info.loopback_test_result))
        {
                printf("slave get local loop back fail\n");
        }
        if (ISC_SendMcastReliable(unit_bitmap,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE;
        }
    }
    else if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_MASTER_MODE)
    {
        UI32_T byte = SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*(request_p->unit-1);
        UI32_T port_loop_back_list[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]={0};
        UI32_T unit_bitmap;

        if ((request_p->option_module) == SWDRV_OPTION_MODULE)
        {
            STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number);

            byte = ((SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST*(request_p->unit-1)) + (max_port_number/8));

            SWDRV_OM_GetPortLoopbackList(port_loop_back_list);
            memcpy(&port_loop_back_list[byte],
                   &request_p->info.loopback_test_result[byte],
                   (((request_p->option_num_port)/8)));
            SWDRV_OM_SetPortLoopbackList(port_loop_back_list);

            STKTPLG_POM_OptionModuleIsExist(request_p->unit, &drv_unit);

            SWDRV_OM_GetUnitBitmap(&unit_bitmap);
            unit_bitmap |= ((0x01) << (drv_unit-1));
            SWDRV_OM_SetUnitBitMap(UI32_T bitmap)
        }
        else
        {
            STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number);

            SWDRV_OM_GetPortLoopbackList(port_loop_back_list);
            memcpy(&port_loop_back_list[byte],
                   &request_p->info.loopback_test_result[byte],
                   (((request_p->option_num_port)/8)));
            SWDRV_OM_SetPortLoopbackList(port_loop_back_list);

            SWDRV_OM_GetUnitBitmap(&unit_bitmap);
            unit_bitmap |= ((0x01) << (drv_unit-1));
            SWDRV_OM_SetUnitBitMap(UI32_T bitmap)
        }
    }
    return TRUE;
}
#endif

static BOOL_T SlaveSetPortPVID(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortPVID( request_p->unit, request_p->port, request_p->vlan_pvid );
}

static BOOL_T SlaveCreateVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalCreateVlan(request_p->vlan_vid);
}

static BOOL_T SlaveDestroyVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDestroyVlan(request_p->vlan_vid);
}

static BOOL_T SlaveSetGlobalDefaultVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetGlobalDefaultVlan(request_p->vlan_vid);
}

static BOOL_T SlaveAddPortToVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddPortToVlanMemberSet( request_p->unit, request_p->port,  request_p->vlan_vid );
}

static BOOL_T SlaveDeletePortFromVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeletePortFromVlanMemberSet(request_p->unit, request_p->port, request_p->vlan_vid);
}

static BOOL_T SlaveAddPortToVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_localAddPortToVlanUntaggedSet( request_p->unit, request_p->port, request_p->vlan_vid );
}

static BOOL_T SlaveDeletePortFromVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeletePortFromVlanUntaggedSet(request_p->unit, request_p->port, request_p->vlan_vid);
}

static BOOL_T SlaveSetLocalPortMtu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortMTU(request_p->unit,request_p->port,request_p->mtu);
}

static BOOL_T SlaveGetPortMaxFrameSize(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_MAX_FRAME_SIZE) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortMaxFrameSize(request_p->unit, request_p->port,
                                        &isc_reply_p->data.u32x2.u32_1, &isc_reply_p->data.u32x2.u32_2);

    return ISC_RemoteReply(mref_handle_p, key);
}

#if (SYS_CPNT_VXLAN == TRUE)
static BOOL_T SlaveSetVxlanStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVxlanStatus(
                request_p->info.vxlan_status.is_enable,
                request_p->info.vxlan_status.is_random_src_port);
}

static BOOL_T SlaveSetVxlanStatusPort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVxlanStatusPort(
                request_p->unit,
                request_p->port,
                request_p->info.vxlan_status_port.is_acc_port,
                request_p->info.vxlan_status_port.is_enable);
}

static BOOL_T SlaveSetVxlanUdpPort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVxlanUdpPort(
                request_p->info.udp_port);
}

static BOOL_T SlaveSetVxlanVpn(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVxlanVpn(
                &request_p->info.vxlan_vpn.vpn_info,
                request_p->info.vxlan_vpn.is_add);
}

static BOOL_T SlaveAddVtepIntoMcastGroup(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddVtepIntoMcastGroup(
                request_p->info.vxlan_add_mcg.bcast_group,
                request_p->info.vxlan_add_mcg.vxlan_port,
                request_p->info.vxlan_add_mcg.is_add);
}

static BOOL_T SlaveCreateVTEP(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T  local_vxlan_port;

    return SWDRV_LocalCreateVTEP(
                request_p->info.vxlan_cvtep.vfi_id,
                request_p->info.vxlan_cvtep.l3_inf_id,
                request_p->unit,
                request_p->port,
                request_p->info.vxlan_cvtep.udp_port,
                request_p->info.vxlan_cvtep.r_mac,
                request_p->info.vxlan_cvtep.is_mc,
                request_p->info.vxlan_cvtep.is_acc_port,
                &request_p->info.vxlan_cvtep.l_vtep,
                &request_p->info.vxlan_cvtep.r_vtep,
                &local_vxlan_port);
}

static BOOL_T SlaveDestroyVTEP(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDestroyVTEP(
                request_p->info.vxlan_dvtep.vfi_id,
                request_p->info.vxlan_dvtep.vxlan_port_id);
}

static BOOL_T SlaveSetVxlanPortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVxlanPortLearning(
                request_p->info.vxlan_port_leaning.vxlan_port_id,
                request_p->info.vxlan_port_leaning.is_learning);
}
#endif /* end of #if (SYS_CPNT_VXLAN == TRUE)*/

static BOOL_T SlaveEnableIngressFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableIngressFilter( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisableIngressFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableIngressFilter( request_p->unit, request_p->port );
}

static BOOL_T SlaveAdmitVLANTaggedFramesOnly(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAdmitVLANTaggedFramesOnly( request_p->unit, request_p->port );
}

static BOOL_T SlaveAdmitVLANUntaggedFramesOnly(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAdmitVLANUntaggedFramesOnly( request_p->unit, request_p->port );
}

static BOOL_T SlaveAdmitAllFrames(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAdmitAllFrames( request_p->unit, request_p->port );
}

static BOOL_T SlaveEnableTrapUnspecifiedTagFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableTrapUnspecifiedTagFrame();
}

static BOOL_T SlaveDisableTrapUnspecifiedTagFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableTrapUnspecifiedTagFrame();
}

static BOOL_T SlaveAddHostToVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddHostToVlan(request_p->vlan_vid);
}

static BOOL_T SlaveDeleteHostFromVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeleteHostFromVlan(request_p->vlan_vid);
}

static BOOL_T SlaveSetPortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortMirroring( request_p->port_mirror_src,
                                          request_p->port_mirror_rx,
                                          request_p->port_mirror_tx );
}

static BOOL_T SlaveDeletePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeletePortMirroring(request_p->port_mirror_src,request_p->port_mirror_rx);
}

static BOOL_T SlaveEnablePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortMirroring(request_p->port_mirror_src);
}

static BOOL_T SlaveDisablePortMirroring(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortMirroring(request_p->port_mirror_src);
}

static BOOL_T SlaveCreateTrunk(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalCreateTrunk(request_p->trunking_id);
}

static BOOL_T SlaveDestroyTrunk(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDestroyTrunk(request_p->trunking_id);
}

static BOOL_T SlaveSetTrunkPorts(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetTrunkPorts( request_p->trunking_id,
                                       request_p->trunking_port_count,
                                       request_p->trunking_port_member );
}

static BOOL_T SlaveSetTrunkBalanceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetTrunkBalanceMode(request_p->info.general_32_bits);
}

static BOOL_T SlaveEnableIgmpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableIgmpTrap();
}

static BOOL_T SlaveDisableIgmpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableIgmpTrap();
}

/* DHCP slave unit function */
static BOOL_T SlaveTrapDhcpServerPacket(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalTrapDhcpServerPacket(request_p->info.packet_trap_info.to_cpu, request_p->info.packet_trap_info.flood);
}


static BOOL_T SlaveTrapDhcpClientPacket(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalTrapDhcpClientPacket(request_p->info.packet_trap_info.to_cpu, request_p->info.packet_trap_info.flood);
}

static BOOL_T SlaveSetOrgSpecificTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetOrgSpecificTrap(request_p->info.packet_trap_info.to_cpu, request_p->info.packet_trap_info.flood);
}

static BOOL_T SlaveAddMulticastAddrToTrunkMember(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddMulticastAddrToTrunkMember( request_p->trunking_mac,
                                                       request_p->trunking_vid,
                                                       request_p->trunking_id,
                                                       request_p->trunking_member );
}

static BOOL_T SlaveSetUnknownIPMcastFwdPortlist(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetUnknownIPMcastFwdPortList(request_p->unknown_mcast_fwd_port_list);
}

static BOOL_T SlaveSetBroadcastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetBroadcastStormControlThreshold(stack_id,
                                                           request_p->port,
                                                           request_p->storm_control_threshold,
                                                           request_p->storm_control_mode);
}

static BOOL_T SlaveSetMulticastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetMulticastStormControlThreshold( stack_id,
                                                           request_p->port,
                                                           request_p->storm_control_threshold,
                                                           request_p->storm_control_mode);
}

static BOOL_T SlaveSetUnknownUnicastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetUnknownUnicastStormControlThreshold( stack_id,
                                                           request_p->port,
                                                           request_p->storm_control_threshold,
                                                           request_p->storm_control_mode);
}

static BOOL_T SlaveEnableBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalEnableBroadcastStormControl(stack_id, request_p->port );
}

static BOOL_T SlaveDisableBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalDisableBroadcastStormControl(stack_id, request_p->port );
}

static BOOL_T SlaveEnableMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalEnableMulticastStormControl(stack_id,  request_p->port );
}

static BOOL_T SlaveDisableMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalDisableMulticastStormControl( stack_id, request_p->port );
}

static BOOL_T SlaveEnableUnknownUnicastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalEnableUnknownUnicastStormControl(stack_id,  request_p->port );
}

static BOOL_T SlaveDisableUnknownUnicastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalDisableUnknownUnicastStormControl( stack_id, request_p->port );
}

static BOOL_T SlaveGetPortStormGranularity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_STORM_GRANULARITY) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortStormGranularity(request_p->unit, request_p->port,request_p->info.general_32_bits, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

#if (SYS_CPNT_ATC_BSTORM == TRUE)
static BOOL_T SlaveSetATCBroadcastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetATCBroadcastStormControlThreshold( request_p->unit,request_p->port,
                                                           request_p->storm_control_threshold,request_p->storm_control_mode);
}

static BOOL_T SlaveEnableATCBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalEnableATCBroadcastStormControl( request_p->unit,request_p->port );
}

static BOOL_T SlaveDisableATCBroadcastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalDisableATCBroadcastStormControl( request_p->unit,request_p->port );
}
#endif

#if (SYS_CPNT_ATC_MSTORM == TRUE)
static BOOL_T SlaveSetATCMulticastStormControlThreshold(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetATCMulticastStormControlThreshold( request_p->unit,request_p->port,
                                                           request_p->storm_control_threshold,request_p->storm_control_mode);

}

static BOOL_T SlaveEnableATCMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalEnableATCMulticastStormControl( request_p->unit,request_p->port );


}

static BOOL_T SlaveDisableATCMulticastStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalDisableATCMulticastStormControl( request_p->unit,request_p->port );
}
#endif



static BOOL_T SlaveSetPortUserDefaultPriority(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortUserDefaultPriority( request_p->unit,
                                                    request_p->port,
                                                    request_p->qos_priority );
}

static BOOL_T SlaveSetPriorityMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPriorityMapping( request_p->unit,
                                            request_p->port,
                                            request_p->qos_mapping );
}

static BOOL_T SlaveSetPriorityMappingPerSystem(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPriorityMappingPerSystem(request_p->qos_mapping);
}

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetStackingPortPriorityMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetStackingPortPriorityMapping( request_p->unit,
                                                        request_p->port,
                                                        request_p->qos_mapping );
}
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SlaveEnableTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableTrafficSegmatation();
}

static BOOL_T SlaveDisableTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableTrafficSegmatation();
}

static BOOL_T SlaveSetTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetTrafficSegmatation( request_p->traffic_segematation_uplink_uport_list,
                                        request_p->traffic_segematation_uplink_uport_count,
                                        request_p->traffic_segematation_downlink_uport_list,
                                        request_p->traffic_segematation_downlink_uport_count );
}

static BOOL_T SlaveResetTrafficSegmatation(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalResetTrafficSegmatation();
}

static BOOL_T SlaveSetTrafficSegmatationByPortList(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetTrafficSegmatationByPortlist(request_p->traffic_segematation_by_port_list_uplink_port_list,
                                                        request_p->traffic_segematation_by_port_list_downlink_port_list);
}
#endif /* End of SYS_CPNT_PORT_TRAFFIC_SEGMENTATION is TRUE */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static BOOL_T SlaveSetPrivateVlanPortlistBySessionId(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPrivateVlanPortlistBySessionId(request_p->private_vlan_port_list_by_session_group_session_id,
                                                        request_p->private_vlan_port_list_by_session_group_uplink_port_list,
                                                        request_p->private_vlan_port_list_by_session_group_downlink_port_list);
}

static BOOL_T SlaveDeletePrivateVlanPortlistBySessionId(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeletePrivateVlanPortlistBySessionId(request_p->private_vlan_port_list_by_session_group_session_id,
                                                           request_p->private_vlan_port_list_by_session_group_uplink_port_list,
                                                           request_p->private_vlan_port_list_by_session_group_downlink_port_list);
}

static BOOL_T SlaveEnablePrivateVlanUplinkToUplinkBlockingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePrivateVlanUplinkToUplinkBlockingMode();
}

static BOOL_T SlaveDisablePrivateVlanUplinkToUplinkBlockingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePrivateVlanUplinkToUplinkBlockingMode();
}

static BOOL_T SlaveSetPrivateVlanTrunkMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPrivateVlanTrunkMode(request_p->info.u32_u32_b.u32_a1,
                                              request_p->info.u32_u32_b.u32_a2,
                                              request_p->info.u32_u32_b.bool_a1);
}
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */


#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
static BOOL_T SlaveSetPortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortIngressRateLimit( request_p->unit,
                                                 request_p->port,
                                                 request_p->ratelimit_trunkid,
                                                 request_p->ratelimit );
}

static BOOL_T SlaveEnablePortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortIngressRateLimit( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortIngressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortIngressRateLimit( request_p->unit, request_p->port, request_p->ratelimit_trunkid);
}
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
static BOOL_T SlaveEnablePortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortEgressRateLimit( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortEgressRateLimit( request_p->unit, request_p->port );
}

static BOOL_T SlaveSetPortEgressRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortEgressRateLimit( request_p->unit,
                                                request_p->port,
                                                request_p->ratelimit );
}
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
static BOOL_T SlaveEnableJumboFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableJumboFrame();
}

static BOOL_T SlaveDisableJumboFrame(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableJumboFrame();
}
#endif

static BOOL_T SlaveEnablePortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortWrrQueueWeight();
}

static BOOL_T SlaveDisablePortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortWrrQueueWeight();
}

#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
static BOOL_T SlaveSetWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetWrrQueueWeight(
            request_p->wrr_queue_id, request_p->wrr_queue_weight);
}

static BOOL_T SlaveSetStrictPriorityQueue(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetStrictPriorityQueue(request_p->wrr_queue_id);
}
#endif

static BOOL_T SlaveSetPortWrrQueueWeight(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetPortWrrQueueWeight( stack_id,
                                               request_p->port,
                                               request_p->wrr_queue_id,
                                               request_p->wrr_queue_weight );
}

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
static BOOL_T SlaveSetEgressSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetEgressSchedulingMethod(request_p->egress_method);
}
#endif

static BOOL_T SlaveSetPortEgressSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T stack_id;
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    return SWDRV_LocalSetPortEgressSchedulingMethod(stack_id, request_p->port, request_p->egress_method);
}

#if (SYS_CPNT_PORT_SECURITY == TRUE)
static BOOL_T SlaveEnablePortSecurity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortSecurity( request_p->unit, request_p->port );
}

static BOOL_T SlaveDisablePortSecurity(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortSecurity(request_p->unit, request_p->port );
}

static BOOL_T SlavePortSecurityActionNone(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalPortSecurityActionNone( request_p->unit, request_p->port );
}

static BOOL_T SlavePortSecurityActionTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalPortSecurityActionTrap( request_p->unit, request_p->port );
}

static BOOL_T SlavePortSecurityActionShutdown(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalPortSecurityActionShutdown( request_p->unit, request_p->port );
}

static BOOL_T SlavePortSecurityActionTrapAndShutdown(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalPortSecurityActionTrapAndShutdown( request_p->unit, request_p->port );
}

#endif

static BOOL_T SlaveEnableIPMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableIPMC();
}

static BOOL_T SlaveDisableIPMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableIPMC();
}


static BOOL_T SlaveDisablePortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisablePortLearning(request_p->unit, request_p->port);
}

static BOOL_T SlaveEnablePortLearning(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortLearning(request_p->unit, request_p->port);
}

static BOOL_T SlaveSetPortLearningStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortLearningStatus(
        request_p->unit,
        request_p->port,
        request_p->info.u32_u32_u32.u32_a1,
        request_p->info.u32_u32_u32.u32_a2,
        request_p->info.u32_u32_u32.u32_a3);
}

#if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE)
static BOOL_T SlaveSetVlanLearningStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVlanLearningStatus(
        request_p->info.u32_b.u32_a1,
        request_p->info.u32_b.bool_a1);
}
#endif

static BOOL_T SlaveEnableUMCASTIpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableUMCASTIpTrap();
}

static BOOL_T SlaveDisableUMCASTIpTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableUMCASTIpTrap();
}

static BOOL_T SlaveEnableUMCASTMacTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableUMCASTMacTrap();
}

static BOOL_T SlaveDisableUMCASTMacTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableUMCASTMacTrap();
}

#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SlaveSetPortRestartAutoNego (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortRestartAutoNego(request_p->unit, request_p->port );
}

static BOOL_T SlaveSetPortAutoNegoRemoteFaultAdvertisement (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortAutoNegoRemoteFaultAdvertisement(request_p->unit,
                                                                request_p->port,
                                                                request_p->general_32_bits_parameter );
}

static BOOL_T SlaveGetPortAutoNegoRemoteFaultAdvertisement (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_AUTO_NEGO_REMOTE_FAULT_ADVERTISEMENT) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortAutoNegoRemoteFaultAdvertisement(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveGetPortLinkPartnerAutoNegoSignalingState (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_SIGNALING_STATE) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortLinkPartnerAutoNegoSignalingState(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveGetPortAutoNegoProcessState (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_AUTO_NEGO_PROCESS_STATE) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortAutoNegoProcessState(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveGetPortLinkPartnerAutoNegoCapa (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_CAPA) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortLinkPartnerAutoNegoCapa(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveGetPortLinkPartnerAutoNegoRemoteFault (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_LINK_PARTNER_AUTO_NEGO_REMOTE_FAULT) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortLinkPartnerAutoNegoRemoteFault(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

#if (SYS_HWCFG_SUPPORT_PD==TRUE)
static BOOL_T SlaveGetPDPortStatus (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PD_PORT_STATUS) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPDPortStatus(request_p->unit, request_p->port, &isc_reply_p->data.pd_info.status, &isc_reply_p->data.pd_info.mode);

    return ISC_RemoteReply(mref_handle_p, key);
}
#endif

static BOOL_T SlaveGetPortJabberState (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_JABBER_STATE) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortJabberState(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SlaveGetPortFalseCarrierSenseCounter (ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_FALSE_CARRIER_SENSE_COUNTER) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortFalseCarrierSenseCounter(request_p->unit, request_p->port, &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}
#endif

#if (SYS_CPNT_DOT1X == TRUE)
static BOOL_T SlaveSetDot1xAuthTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetDot1xAuthTrap(request_p->unit, request_p->port, request_p->dot1x_auth_trap_mode);
}

static BOOL_T SlaveSetDot1xAuthControlMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetDot1xAuthControlMode(request_p->unit, request_p->port, request_p->dot1x_auth_control_mode);
}

static BOOL_T SlaveSetEapolFramePassThrough(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetEapolFramePassThrough(request_p->info.dot1x_auth.eapol_frame_pass_through);
}

#endif

#if (SYS_CPNT_MAC_VLAN == TRUE)
static BOOL_T SlaveSetMacVlanEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    #if (SYS_CPNT_MAC_VLAN_IMPLEMENTED_BY_RULE  == TRUE)
    return RULE_CTRL_SetMacVlanEntry(request_p->info.mac_vlan_entry.mac_addr,
                                     request_p->info.mac_vlan_entry.mask,
                                     request_p->info.mac_vlan_entry.vid, request_p->info.mac_vlan_entry.priority);
    #else
    return DEV_SWDRV_PMGR_SetMacVlanEntry(request_p->info.mac_vlan_entry.mac_addr,
                                          request_p->info.mac_vlan_entry.vid, request_p->info.mac_vlan_entry.priority);
    #endif
}
static BOOL_T SlaveDeleteMacVlanEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    #if (SYS_CPNT_MAC_VLAN_IMPLEMENTED_BY_RULE  == TRUE)
    return RULE_CTRL_DeleteMacVlanEntry(request_p->info.mac_vlan_entry.mac_addr,
                                        request_p->info.mac_vlan_entry.mask);
    #else
    return DEV_SWDRV_PMGR_DeleteMacVlanEntry(request_p->info.mac_vlan_entry.mac_addr);
    #endif
}
#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
static BOOL_T SWDRV_SlaveSetPortPowerSave(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    BOOL_T ret;
    SWDRV_Port_Info_T swdrv_port_info;

    SWDRV_OM_GetPortInfo(request_p->info.port_power_saving.port, &swdrv_port_info);
    ret = DEV_SWDRV_PMGR_SetPortPowerSave(request_p->info.port_power_saving.unit,
                                          request_p->info.port_power_saving.port,
                                          request_p->info.port_power_saving.status,
                                          swdrv_port_info.link_status);
    return ret;
} /* End of SWDRV_SlaveSetPortPowerSave() */
#endif

static BOOL_T SlaveTrapUnknownIpMcastToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalTrapUnknownIpMcastToCPU(request_p->info.packet_trap_byvlan_info.to_cpu, request_p->info.packet_trap_byvlan_info.flood, request_p->info.packet_trap_byvlan_info.vid);
} /* End of SlaveTrapUnknownIpMcastToCPU() */

#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SlaveTrapUnknownIpv6McastToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalTrapUnknownIpv6McastToCPU(request_p->info.packet_trap_byvlan_info.to_cpu, request_p->info.packet_trap_byvlan_info.flood, request_p->info.packet_trap_byvlan_info.vid);
} /* End of SlaveTrapUnknownIpv6McastToCPU() */
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SlaveTrapIpv6PIMToCPU(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalTrapIpv6PIMToCPU(request_p->info.packet_trap_info.to_cpu);
} /* End of SlaveTrapIpv6PIMToCPU() */
#endif

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static BOOL_T SlaveAddVlanMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalAddVlanMirror(request_p->vlan_mirror_unit, request_p->vlan_mirror_port, request_p->vlan_mirror_vid);
}

static BOOL_T SlaveDeleteVlanMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeleteVlanMirror(request_p->vlan_mirror_unit, request_p->vlan_mirror_port, request_p->vlan_mirror_vid);
}
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
static BOOL_T SlaveSetMacMirrorEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetMacMirrorEntry(request_p->mac_mirror_mac);
}

static BOOL_T SlaveDeleteMacMirrorEntry(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDeleteMacMirrorEntry(request_p->mac_mirror_mac);
}

static BOOL_T SlaveSetDestPortForMacMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetDestPortForMacMirror(request_p->set_mirror_dest_port_unit,
                                              request_p->set_mirror_dest_port_port,
                                              request_p->set_mirror_dest_port_mode);
}
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
static BOOL_T SlaveSetDestPortForAclMirror(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetDestPortForAclMirror(request_p->set_mirror_dest_port_unit,
                                              request_p->set_mirror_dest_port_port,
                                              request_p->set_mirror_dest_port_mode);
}
#endif

/******************* Stacking Function : Master SubRoutine *************************/
static BOOL_T CallbackMasterHotSwapInsert(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_TYPE_CallBack_T  *fun_list;
    UI32_T               max_port_number;

    for(fun_list=HotSwapInsert_callbacklist; fun_list; fun_list=fun_list->next)
    {
        if ((request_p->option_module) == SWDRV_OPTION_MODULE)
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number) == FALSE)
            {
                printf("CallbackMasterHotSwapInsert STKTPLG_POM_GetMaxPortNumberOnBoard UNIT=%ldFAIL\n", (long)request_p->unit);
                return FALSE;
            }
            else
            {
                fun_list->func(request_p->unit, ((request_p->port)+max_port_number));
            }
        }
        else
                fun_list->func(request_p->unit, request_p->port);
    }
    return TRUE;
}

static BOOL_T CallbackMasterHotSwapRemove(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_TYPE_CallBack_T  *fun_list;
    UI32_T               max_port_number;

    for(fun_list=HotSwapRemove_callbacklist; fun_list; fun_list=fun_list->next)
    {
        if ((request_p->option_module) == SWDRV_OPTION_MODULE)
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number) == FALSE)
            {
                printf("CallbackMasterHotSwapRemove STKTPLG_POM_GetMaxPortNumberOnBoard UNIT=%ldFAIL\n", (long)request_p->unit);
                return FALSE;
            }
            else
            {
                fun_list->func(request_p->unit, ((request_p->port)+max_port_number));
            }
        }
        else
                fun_list->func(request_p->unit, request_p->port);
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - CallbackMasterPortLinkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Update port link status of remote mainboard( or option module)
 *           to Master by this call-back function.
 * INPUT   : ISC_Key_T          *key
 *           L_MM_Mref_Handle_T *mref_handle_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *
 * -------------------------------------------------------------------------*/
static BOOL_T CallbackMasterPortLinkStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T   base_port_id;
    UI32_T   port_num;
    UI32_T   unit;
    BOOL_T   is_front_not_align = FALSE;  /* Does first port bit not start from the left bit of array element? */
    BOOL_T   is_back_not_align  = FALSE;  /* Does last port bit not start from the right bit of array element? */
    UI8_T    array_index;
    UI8_T    bit_index;
    UI32_T   port_index;
    UI32_T   end_port;
    UI32_T   start_port;
    UI32_T   swdrv_thread_id;
    SWDRV_LinkStatus_T swdrv_port_link_status;

    base_port_id = request_p->port;
    port_num     = request_p->option_num_port;
    unit         = request_p->unit;

    /* Is base_port_id not 1,9,17,25,....?
     * (Is port bit not BIT_7 of array element ?)
     */
    if ((((base_port_id+7)%8)!=0))
    {
        is_front_not_align = TRUE;
    }

    /* total port number can't align 8.
     */
    if (((base_port_id + port_num -1)%8)!=0)
    {
        is_back_not_align = TRUE;
    }
    memset(&swdrv_port_link_status, 0, sizeof(SWDRV_LinkStatus_T));
    SWDRV_OM_GetPortLinkStatusBitmaps(unit, &swdrv_port_link_status);

    if (is_front_not_align)
    {

        /* This ISC packet comes from option module.
         */
        start_port = base_port_id;
        end_port =(start_port+7)/8*8;


        for (port_index = start_port; port_index <= end_port;port_index++)
        {
            array_index = SWDRV_LPORT_INDEX(port_index);
            bit_index   = SWDRV_LPORT_BIT_IN_UI8_T(port_index);
            /* clear specific bit
             */

            swdrv_port_link_status.link_st_bitmap[array_index] &= (~bit_index);
            swdrv_port_link_status.link_st_bitmap[array_index] |= ((request_p->info.new_link_st_bitmap[array_index])& bit_index);
        }
        /* below for-loop, minimum array_index = SWDRV_LPORT_INDEX(start_port)
         */
        start_port = end_port + 1;
    }
    else
    {
        /* below for-loop, minimum array_index = SWDRV_LPORT_INDEX(start_port)
         */
        start_port = base_port_id;
    }
    /* below for-loop, maximum array_index = SWDRV_LPORT_INDEX(end_port)
     */
    end_port =  ((base_port_id + port_num - 1)/8)*8;

    /* minimum array_index = SWDRV_LPORT_INDEX(start_port) ; maximum array_index = SWDRV_LPORT_INDEX(end_port)
     */

    for (array_index = SWDRV_LPORT_INDEX(start_port); array_index <= SWDRV_LPORT_INDEX(end_port);array_index++)
    {
        swdrv_port_link_status.link_st_bitmap[array_index] = request_p->info.new_link_st_bitmap[array_index];
    }


    if (is_back_not_align)
    {
        start_port = end_port + 1;
        end_port = base_port_id + port_num - 1;


        for (port_index = start_port; port_index <= end_port;port_index++)
        {
            array_index = SWDRV_LPORT_INDEX(port_index);
            bit_index   = SWDRV_LPORT_BIT_IN_UI8_T(port_index);
            /* clear specific bit
             */
            swdrv_port_link_status.link_st_bitmap[array_index] &= (~bit_index);
            swdrv_port_link_status.link_st_bitmap[array_index] |= ((request_p->info.new_link_st_bitmap[array_index])& bit_index);
        }

    }
    SWDRV_OM_SetPortLinkStatusBitmaps(unit, &swdrv_port_link_status, SWDRV_OM_F_REALTIME);
    SWDRV_OM_GetThreadId(&swdrv_thread_id);
    SYSFUN_SendEvent (swdrv_thread_id, SWDRV_EVENT_UPDATE_PORT_LINK_STATUS);
    return TRUE;
}

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - CallbackMasterPortSfpPresentStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Update port link status of remote mainboard( or option module)
 *           to Master by this call-back function.
 * INPUT   : ISC_Key_T          *key
 *           L_MM_Mref_Handle_T *mref_handle_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *
 * -------------------------------------------------------------------------
 */
static BOOL_T CallbackMasterPortSfpPresentStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T   base_port_id;
    UI32_T   port_num;
    UI32_T   unit;
    UI32_T   port_index;
    UI32_T   end_port;
    UI32_T   start_port;
    UI32_T   swdrv_sfp_thread_id;
    BOOL_T   is_front_not_align = FALSE;  /* Does first port bit not start from the left bit of array element? */
    BOOL_T   is_back_not_align  = FALSE;  /* Does last port bit not start from the right bit of array element? */
    UI8_T    array_index;
    UI8_T    bit_index;
    SWDRV_TYPE_SfpPresentStatus_T swdrv_port_sfp_present_status;

    base_port_id = request_p->port;
    port_num     = request_p->option_num_port;
    unit         = request_p->unit;

    /* Is base_port_id not 1,9,17,25,....?
     * (Is port bit not BIT_7 of array element ?)
     */
    if((((base_port_id+7)%8)!=0))
    {
        is_front_not_align = TRUE;
    }

    /* total port number can't align 8.
     */
    if(((base_port_id + port_num -1)%8)!=0)
    {
        is_back_not_align = TRUE;
    }

    memset(&swdrv_port_sfp_present_status, 0, sizeof(SWDRV_TYPE_SfpPresentStatus_T));
    SWDRV_OM_GetPortSfpPresentStatusBitmaps(unit, &swdrv_port_sfp_present_status);

    if(is_front_not_align)
    {
        /* This ISC packet comes from option module.
         */
        start_port = base_port_id;
        end_port =(start_port+7)/8*8;

        for(port_index = start_port; port_index <= end_port;port_index++)
        {
            array_index = SWDRV_LPORT_INDEX(port_index);
            bit_index   = SWDRV_LPORT_BIT_IN_UI8_T(port_index);
            /* clear specific bit
             */

            swdrv_port_sfp_present_status.sfp_present_st_bitmap[array_index] &= (~bit_index);
            swdrv_port_sfp_present_status.sfp_present_st_bitmap[array_index] |= ((request_p->info.new_sfp_present_st_bitmap[array_index])& bit_index);
        }
        /* below for-loop, minimum array_index = SWDRV_LPORT_INDEX(start_port)
         */
        start_port = end_port + 1;
    }
    else
    {
        /* below for-loop, minimum array_index = SWDRV_LPORT_INDEX(start_port)
         */
        start_port = base_port_id;
    }
    /* below for-loop, maximum array_index = SWDRV_LPORT_INDEX(end_port)
     */
    end_port = ((base_port_id + port_num - 1)/8)*8;

    /* minimum array_index = SWDRV_LPORT_INDEX(start_port) ; maximum array_index = SWDRV_LPORT_INDEX(end_port)
     */

    for(array_index = SWDRV_LPORT_INDEX(start_port); array_index <= SWDRV_LPORT_INDEX(end_port);array_index++)
    {
        swdrv_port_sfp_present_status.sfp_present_st_bitmap[array_index] = request_p->info.new_sfp_present_st_bitmap[array_index];
    }

    if(is_back_not_align)
    {
        start_port = end_port + 1;
        end_port = base_port_id + port_num - 1;

        for(port_index = start_port; port_index <= end_port;port_index++)
        {
            array_index = SWDRV_LPORT_INDEX(port_index);
            bit_index   = SWDRV_LPORT_BIT_IN_UI8_T(port_index);
            /* clear specific bit
             */
            swdrv_port_sfp_present_status.sfp_present_st_bitmap[array_index] &= (~bit_index);
            swdrv_port_sfp_present_status.sfp_present_st_bitmap[array_index] |= ((request_p->info.new_sfp_present_st_bitmap[array_index])& bit_index);
        }

    }
    SWDRV_OM_SetPortSfpPresentStatusBitmaps(unit, &swdrv_port_sfp_present_status, SWDRV_OM_F_REALTIME);
    SWDRV_OM_GetThreadId(&swdrv_sfp_thread_id);
    SYSFUN_SendEvent(swdrv_sfp_thread_id, SWDRV_EVENT_UPDATE_PORT_SFP_PRESENT_STATUS);

    return TRUE;
}/* End of CallbackMasterPortSfpPresentStatus() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - CallbackMasterPortSfpInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Update port link status of remote mainboard( or option module)
 *           to Master by this call-back function.
 * INPUT   : ISC_Key_T          *key
 *           L_MM_Mref_Handle_T *mref_handle_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *
 * -------------------------------------------------------------------------
 */
static BOOL_T CallbackMasterPortSfpInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_CALLBACK_MGR_SWDRV_PortSfpInfo(SYS_MODULE_SWDRV, request_p->unit, request_p->port, &(request_p->info.sfp_info));
    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - CallbackMasterPortSfpDdmInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Update port link status of remote mainboard( or option module)
 *           to Master by this call-back function.
 * INPUT   : ISC_Key_T          *key
 *           L_MM_Mref_Handle_T *mref_handle_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *
 * -------------------------------------------------------------------------
 */
static BOOL_T CallbackMasterPortSfpDdmInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_CALLBACK_MGR_SWDRV_PortSfpDdmInfo(SYS_MODULE_SWDRV, request_p->unit, request_p->port, &(request_p->info.sfp_ddm_info));

    return TRUE;
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - CallbackMasterPortSfpDdmInfoMeasured
 * -------------------------------------------------------------------------
 * FUNCTION: Update port link status of remote mainboard( or option module)
 *           to Master by this call-back function.
 * INPUT   : ISC_Key_T          *key
 *           L_MM_Mref_Handle_T *mref_handle_p
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *
 * -------------------------------------------------------------------------
 */
static BOOL_T CallbackMasterPortSfpDdmInfoMeasured(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_CALLBACK_MGR_SWDRV_PortSfpDdmInfoMeasured(SYS_MODULE_SWDRV, request_p->unit, request_p->port, &(request_p->info.sfp_ddm_info.measured));

    return TRUE;
}
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

static BOOL_T CallbackMasterPortTypeChanged(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SYS_CALLBACK_MGR_SWDRV_PortTypeChanged(SYS_MODULE_SWDRV, request_p->unit, request_p->port, request_p->event_module_id, request_p->event_port_type);
}

static BOOL_T CallbackMasterPortSpeedDuplex(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
#if 0
    SYS_TYPE_CallBack_T  *fun_list;
    UI32_T               max_port_number;
#endif /* #if 0 */
#if 0
    for(fun_list=PortSpeedDuplex_callbacklist; fun_list; fun_list=fun_list->next)
    {
        if ((request_p->option_module) == SWDRV_OPTION_MODULE)
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number) == FALSE)
            {
                printf("CallbackMasterPortSpeedDuplex STKTPLG_POM_GetMaxPortNumberOnBoard UNIT=%ldFAIL\n",request_p->unit);
                return FALSE;
            }
            else
            {
                fun_list->func(request_p->unit,  ((request_p->port)+max_port_number),
                      request_p->event_speed_duplex );

                /*
                printf("CallbackMasterPortSpeedDuplex unit=%ld port=%ld\n",request_p->unit,(request_p->port)+max_port_number);
                */
            }
        }
        else
        {
            fun_list->func(request_p->unit, request_p->port,
                      request_p->event_speed_duplex );
        }
    }
#endif
        SYS_CALLBACK_MGR_SWDRV_PortSpeedDuplex(SYS_MODULE_SWDRV, request_p->unit, request_p->port, request_p->event_speed_duplex);

    return TRUE;
}

static BOOL_T CallbackMasterPortFlowControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
#if 0 /* JinhuaWei, 03 August, 2008 2:41:04 */
    SYS_TYPE_CallBack_T  *fun_list;
    UI32_T               max_port_number;
#endif /* #if 0 */
    /*EPR:ES4827G-FLF-ZZ-00147
      *Problem: DUT failed to handle flow control in stacking mode
      *Solution: When slave change the flow control status need notify to
      *               master
      *Approved by: Hardsun
      *Modify file:swdrv.c
      */
#if 0
    for(fun_list=PortFlowCtrl_callbacklist; fun_list; fun_list=fun_list->next)
    {
        if ((request_p->option_module) == SWDRV_OPTION_MODULE)
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(request_p->unit, &max_port_number) == FALSE)
            {
                printf("CallbackMasterPortFlowControl STKTPLG_POM_GetMaxPortNumberOnBoard UNIT=%ldFAIL\n",request_p->unit);
                return FALSE;
            }
            else
            {
                fun_list->func(request_p->unit,  ((request_p->port)+max_port_number),
                      request_p->event_flow_control );
            }
        }
        else
        {
            fun_list->func(request_p->unit, request_p->port,
                      request_p->event_flow_control );
        }
    }
#endif
        SYS_CALLBACK_MGR_SWDRV_PortFlowCtrl(SYS_MODULE_SWDRV, request_p->unit, request_p->port, request_p->event_flow_control);

    return TRUE;
}

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
/* since only on thread, that is STKCTRL, in SWCTRL enter master
 * mode will trigger this action, database and race condition protection is not necessary.
 */
static void SWDRV_WaitForRemotePortLoopBackGot(UI32_T unit_bitmap_waiting_for)
{
    UI32_T retry_count=0;
    UI32_T swdrv_unit_bitmap;

    while(1)
    {
        SWDRV_OM_GetUnitBitmap(&swdrv_unit_bitmap);
        if (swdrv_unit_bitmap == unit_bitmap_waiting_for)
        {
            SWDRV_OM_SetUnitBitMap(0);
            break;
        }
        else
        {
            if (retry_count == 24)
            {
                printf("SWDRV_WaitForRemotePortLoopBackGot timeout\n");
                break;
            }
            else
            {
                retry_count++;
                SYSFUN_Sleep(100); /*force re-scheduling*/
            }
        }
    }
    return;
}
#endif

/* -------------------------------------------------------------------------
 * Function : SWDRV_ISC_Handler
 * -------------------------------------------------------------------------
 * Purpose  : This function will manipulte all of SWDRV via ISC
 * INPUT    : *key      -- key of ISC
 *            *mem_ref  -- transfer data
 *            svc_id    -- service id
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : call by ISC_Agent
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_ISC_Handler(ISC_Key_T *key, L_MM_Mref_Handle_T *mref_handle_p)
{
    SWDRV_Rx_IscBuf_T   *buf;
    UI32_T  service;
    UI32_T  start_time,end_time;

    buf = L_MM_Mref_GetPdu(mref_handle_p, &service); /* service is used as dummy here */
    if(buf==NULL)
        return FALSE;

    service = buf->ServiceID;
    SWDRV_BD_IncRxCounter(service);
    start_time = SYS_TIME_GetSystemTicksBy10ms();
    /*
     * Check to abort operation if callback service id(opcode) is more then
     * number of callback service on this drive.
     */
    if(service >= SWDRV_NBR_OF_SERVICE_ID || SWDRV_func_tab[service]==NULL)
    {
        printf("SWDRV: Service ID [%lu] is invalid.\r\n", (unsigned long)service);
    }
    else
    {
        SWDRV_func_tab[service](key,buf);
         end_time = SYS_TIME_GetSystemTicksBy10ms()-start_time;
          if(end_time>swdrv_isc_max_tick[0])
          {
              swdrv_isc_max_tick[0]=end_time;
              swdrv_isc_max_tick[1]=service;
          }
    }
    L_MM_Mref_Release(&mref_handle_p);

    return TRUE;
}
#endif

#ifdef BACKDOOR_OPEN
static BOOL_T SWDRV_BD_IsUnitExist(UI32_T unit)
{
#if (SYS_CPNT_STACKING == TRUE)
    UI32_T index_of_SWDRV_UnitTbl;
    SWDRV_Switch_Info_T swdrv_system_info;

    memset(&swdrv_system_info, 0, sizeof(swdrv_system_info));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    for(index_of_SWDRV_UnitTbl=0; index_of_SWDRV_UnitTbl<swdrv_system_info.num_of_units; index_of_SWDRV_UnitTbl++)
    {
        if(unit == swdrv_system_info.stack_unit_tbl[index_of_SWDRV_UnitTbl])
            return TRUE;
    }
    return FALSE;
#else /* SYS_CPNT_STACKING == TRUE */
    UI32_T my_unit;

    if ((STKTPLG_POM_GetMyUnitID(&my_unit)==FALSE) ||
        (my_unit != unit))
    {
        return FALSE;
    }
    return TRUE;
#endif /* SYS_CPNT_STACKING == TRUE */
}

static void SWDRV_DB_EnablePortAdmin(void)
{
    UI32_T  unit;
    UI32_T  port;
    UI8_T   ch;


    BACKDOOR_MGR_Print("\n");
    BACKDOOR_MGR_Print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    BACKDOOR_MGR_Print("         Enable Port Admin         \n");
    BACKDOOR_MGR_Print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    BACKDOOR_MGR_Print("\n Which unit you address:");

    /*unit*/
    ch = BACKDOOR_MGR_GetChar();
    if ((ch < 0x30)||(ch>0x39))
    {
        BACKDOOR_MGR_Print("\nout of unit range\n");
        return;
    }

    ch -= 0x30;
    BACKDOOR_MGR_Printf("%d\n",ch);
    if(!SWDRV_BD_IsUnitExist((UI32_T)ch))
    {
        BACKDOOR_MGR_Printf("The unit %d doesn't exist\n", ch);
        return;
    }
    unit = (UI32_T)ch;

    /*port*/
    BACKDOOR_MGR_Printf("\n Set port[1~%d]:", SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD);
    port = 0;
    ch=BACKDOOR_MGR_GetChar();
    while(ch != '\n' && ch != '\r')
    {
        ch -= 0x30;
        if(ch>9)
        {
            BACKDOOR_MGR_Print("Erro in Input\n");
            return;
        }
        BACKDOOR_MGR_Printf("%d", ch);
        port = port*10+ch;
        ch=BACKDOOR_MGR_GetChar();
    }
    BACKDOOR_MGR_Print("\n");
    if(port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD)
    {
        BACKDOOR_MGR_Print("port too large. Do nothing!\n");
        return;
    }

    if(!SWDRV_EnablePortAdmin(unit, port))
        BACKDOOR_MGR_Print("Set SWDRV_EnablePortAdmin fail!\n");
    else
        BACKDOOR_MGR_Print("Set SWDRV_EnablePortAdmin success!\n");

    return;
}


static void SWDRV_DB_DisablePortAdmin(void)
{
    UI32_T  unit;
    UI32_T  port;
    UI8_T   ch;


    BACKDOOR_MGR_Print("\n");
    BACKDOOR_MGR_Print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    BACKDOOR_MGR_Print("         Disable Port Admin         \n");
    BACKDOOR_MGR_Print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    BACKDOOR_MGR_Print("\n Which unit you address:");

    /*unit*/
    ch = BACKDOOR_MGR_GetChar();
    if ((ch < 0x30)||(ch>0x39))
    {
        BACKDOOR_MGR_Print("\nout of unit range\n");
        return;
    }

    ch -= 0x30;
    BACKDOOR_MGR_Printf("%d\n",ch);
    if(!SWDRV_BD_IsUnitExist((UI32_T)ch))
    {
        BACKDOOR_MGR_Printf("The unit %d doesn't exist\n", ch);
        return;
    }
    unit = (UI32_T)ch;

    /*port*/
    BACKDOOR_MGR_Printf("\n Set port[1~%d]:", SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD);
    port = 0;
    ch=BACKDOOR_MGR_GetChar();
    while(ch != '\n' && ch != '\r')
    {
        ch -= 0x30;
        if(ch>9)
        {
            BACKDOOR_MGR_Print("Erro in Input\n");
            return;
        }
        BACKDOOR_MGR_Printf("%d", ch);
        port = port*10+ch;
        ch=BACKDOOR_MGR_GetChar();
    }
    BACKDOOR_MGR_Print("\n");
    if(port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD)
    {
        BACKDOOR_MGR_Print("port too large. Do nothing!\n");
        return;
    }

    if(!SWDRV_DisablePortAdmin(unit, port))
        BACKDOOR_MGR_Print("Set SWDRV_DisablePortAdmin fail!\n");
    else
        BACKDOOR_MGR_Print("Set SWDRV_DisablePortAdmin success!\n");

    return;
}

static void SWDRV_BackDoor_ShowComboPortInfo(void)
{
    SWDRV_Port_Info_T swdrv_port_info;
    UI32_T my_unit_id;
    UI32_T unit, port, combo_sfp_index;
    UI32_T port_media;

    STKTPLG_POM_GetMyUnitID(&my_unit_id);
    unit = my_unit_id;

    for (combo_sfp_index = 1;
         STKTPLG_POM_SfpIndexToUserPort(unit, combo_sfp_index, &port);
         combo_sfp_index++)
    {
        BACKDOOR_MGR_Printf("\n port%02d: ", (int)port);

        if (!DEV_SWDRV_PMGR_GetPortMediaActive(unit, port, &port_media))
        {
            BACKDOOR_MGR_Print("DEV_SWDRV_PMGR_GetPortMediaActive failed");
            continue;
        }

        SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

        BACKDOOR_MGR_Printf("media:%d type:%d link:%d speed:%d flowctrl:%d",
            (int)port_media,
            (int)swdrv_port_info.port_type,
            (int)swdrv_port_info.link_status,
            (int)swdrv_port_info.speed_duplex_oper,
            (int)swdrv_port_info.flow_control_oper);
    }
    BACKDOOR_MGR_Print("\n");
}

static void SWDRV_BackDoor_Port_SubMenu (void)
{
    UI8_T   ch;
    BOOL_T  eof=FALSE;
    /*  BODY
     */
    while (! eof)
    {
        BACKDOOR_MGR_Print("\n==========SWDRV BackDoor Sub Menu===[Port]=====\n");
        BACKDOOR_MGR_Print("\n 0. Exit\n");
        BACKDOOR_MGR_Print(" 1. Enable Port Admin\n");
        BACKDOOR_MGR_Print(" 2. Disable Port Admin\n");
#if (SYS_CPNT_SFLOW == TRUE)
        BACKDOOR_MGR_Print(" 3. Set sFlow status\n");
        BACKDOOR_MGR_Print(" 4. Set sFlow sample rate\n");
#endif
        BACKDOOR_MGR_Print(" 5. Combo port info\n");
        BACKDOOR_MGR_Print("=================================================\n");
        BACKDOOR_MGR_Print("     select =");
        ch = BACKDOOR_MGR_GetChar();
#if 0
        if ((ch < 0x30)||(ch>0x39))
            continue;
        ch -= 0x30;
#endif

        BACKDOOR_MGR_Printf("%c",ch);
        switch (ch)
        {
            case '0' :
                eof = TRUE;
                break;
            case '1':
                SWDRV_DB_EnablePortAdmin();
                break;
            case '2':
                SWDRV_DB_DisablePortAdmin();
                break;
#if (SYS_CPNT_SFLOW == TRUE)
            case '3':
                SWDRV_BackDoor_Enable_Sflow();
                break;
            case '4':
                SWDRV_BackDoor_Set_Sflow_Rate();
                break;
#endif
            case '5':
                SWDRV_BackDoor_ShowComboPortInfo();
                break;
            default :
                ch = 0;
                break;
        }
    }   /*  end of while    */
}   /*  ISC_BackDoor_Menu   */


static void SWDRV_BackDoor_Debug_SubMenu(void)
{
    UI8_T   ch;
    BOOL_T  eof=FALSE;
    char  buf[16];

    while (! eof)
    {
        BACKDOOR_MGR_Print("\n==========SWDRV BackDoor Sub Menu===[Debug]=====\n");
        BACKDOOR_MGR_Print("\n 0. Exit\n");
        BACKDOOR_MGR_Printf(" 1. SWDRV_TYPE_DEBUG_FLAG_GBIC_INFO: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_INFO));
        BACKDOOR_MGR_Printf(" 2. SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_PRESENT: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_PRESENT));
        BACKDOOR_MGR_Printf(" 3. SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_DDM_TEMP: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_DDM_TEMP));
        BACKDOOR_MGR_Printf(" 4. SWDRV_TYPE_DEBUG_FLAG_GBIC_STOP_MONITOR: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_STOP_MONITOR));
        BACKDOOR_MGR_Printf(" 5. SWDRV_TYPE_DEBUG_FLAG_PD: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_PD));
        BACKDOOR_MGR_Printf(" 6. SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE: %d\n", SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE));
        BACKDOOR_MGR_Printf(" 7. set sfp present delay(now=%lu)\n", (unsigned long)SWDRV_OM_GetSfpPresentDelay());
        BACKDOOR_MGR_Print("=================================================\n");
        BACKDOOR_MGR_Print("     select =");
        ch = BACKDOOR_MGR_GetChar();

        BACKDOOR_MGR_Printf("%c",ch);
        switch (ch)
        {
            case '0' :
                eof = TRUE;
                break;
            case '1':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_INFO, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_INFO));
                break;
            case '2':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_PRESENT, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_PRESENT));
                break;
            case '3':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_DDM_TEMP, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_SHOW_DDM_TEMP));
                break;
            case '4':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_STOP_MONITOR, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_STOP_MONITOR));
                break;
            case '5':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_PD, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_PD));
                break;
            case '6':
                SWDRV_OM_SetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE, !SWDRV_OM_GetDebugFlag(SWDRV_TYPE_DEBUG_FLAG_GBIC_MAU_TYPE));
                break;
            case '7':
                BACKDOOR_MGR_Printf("\r\nDelay=");
                if (BACKDOOR_MGR_RequestKeyIn(buf, sizeof(buf) - 1) == TRUE)
                {
                    UI32_T delay;

                    BACKDOOR_MGR_Printf("\r\n");
                    delay = (UI32_T)(strtoul(buf, NULL, 0));
                    SWDRV_OM_SetSfpPresentDelay(delay);
                }
                else
                {
                    BACKDOOR_MGR_Printf("\r\nInput error.\r\n");
                }
                break;
            default :
                ch = 0;
                break;
        }
    }/* End of while */
}/* End of SWDRV_BackDoor_Debug_SubMenu() */

static void SWDRV_BackDoor_Port_Mapping_Table_SubMenu (void)
{
    UI8_T   ch;
    BOOL_T  eof=FALSE;
    SWDRV_LinkStatus_T link_status;
    UI32_T array_index = 0;
    SWDRV_Switch_Info_T swdrv_system_info;

    /*  BODY
     */
    while (! eof)
    {
        BACKDOOR_MGR_Print("\n==========SWDRV BackDoor Sub Menu===[Port Mapping Talbe]=====\n");
        BACKDOOR_MGR_Print("\n 0. Exit\n");
        BACKDOOR_MGR_Print(" 1. Display \n");
        BACKDOOR_MGR_Print("=================================================\n");
        BACKDOOR_MGR_Print("     select =");
        ch = BACKDOOR_MGR_GetChar();


        BACKDOOR_MGR_Printf("%c",ch);
        switch (ch)
        {
            case '0' :
                eof = TRUE;
                break;
            case '1':

                memset(&swdrv_system_info, 0, sizeof(SWDRV_Switch_Info_T));
                SWDRV_OM_GetSystemInfo(&swdrv_system_info);

                memset(&link_status, 0, sizeof(SWDRV_LinkStatus_T));
                if (!SWDRV_OM_GetPortLinkStatusBitmaps(swdrv_system_info.stack_id, &link_status))
                    break;

                BACKDOOR_MGR_Printf("swdrv_system_info.stack_id:%d\n",swdrv_system_info.stack_id);
                for (array_index=0;array_index<(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);array_index++)
                {
                    BACKDOOR_MGR_Printf("link_status.link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.link_st_bitmap[array_index]);
                    BACKDOOR_MGR_Printf("link_status.previous_link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.previous_link_st_bitmap[array_index]);
                }

                memset(&link_status, 0, sizeof(SWDRV_LinkStatus_T));
                if (!SWDRV_OM_GetPortLinkStatusBitmaps(1, &link_status))
                    break;

                BACKDOOR_MGR_Print("swdrv_system_info.stack_id:1\n");
                for (array_index=0;array_index<(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);array_index++)
                {
                    BACKDOOR_MGR_Printf("link_status.link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.link_st_bitmap[array_index]);
                    BACKDOOR_MGR_Printf("link_status.previous_link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.previous_link_st_bitmap[array_index]);
                }

                memset(&link_status, 0, sizeof(SWDRV_LinkStatus_T));
                if (!SWDRV_OM_GetPortLinkStatusBitmaps(2, &link_status))
                    break;

                BACKDOOR_MGR_Print("swdrv_system_info.stack_id:2\n");
                for (array_index=0;array_index<(SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);array_index++)
                {
                    BACKDOOR_MGR_Printf("link_status.link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.link_st_bitmap[array_index]);
                    BACKDOOR_MGR_Printf("link_status.previous_link_st_bitmap[%lu]:%d\n",(unsigned long)array_index,link_status.previous_link_st_bitmap[array_index]);
                }
                break;
            default :
                ch = 0;
                break;
        }
    }   /*  end of while    */
}   /*  ISC_BackDoor_Menu   */




static void SWDRV_BackDoor_Menu (void)
{
    UI8_T   ch;
    BOOL_T  eof=FALSE;
    UI32_T  unit, port, max_port_num = 0;

    char inputStr[32];
    UI32_T  vid = 1;
    BOOL_T  vlan_flooding_flag_ukn_uc = TRUE;
    BOOL_T  vlan_flooding_flag_ukn_mc = TRUE;
    BOOL_T  vlan_flooding_flag_bc = TRUE;

    while (! eof)
    {
        BACKDOOR_MGR_Print("\n ============= SWDRV Backdoor Menu =============\n");
        BACKDOOR_MGR_Print("\n 0. Exit\n");
        BACKDOOR_MGR_Print(" 1. Port Related\n");
        BACKDOOR_MGR_Print(" 3. Port Mapping Table\n");
        BACKDOOR_MGR_Print(" 4. Debug Flags\n");
        BACKDOOR_MGR_Print(" 5. Print SFP EEPROM Raw Data: \n");
#if 0
        printf(" 2. Spawn Chip Task \n");
        printf(" 3. Enter Chip Backdoor\n");
#endif
        BACKDOOR_MGR_Print(" 6. OpenFlow - Create VLAN & Empty VLAN Members\n");
        BACKDOOR_MGR_Print(" 7. OpenFlow - Toggle VLAN Flooding State\n");
        BACKDOOR_MGR_Print(" 8. OpenFlow - Enable Port to OpenFlow Mode\n");

        BACKDOOR_MGR_Print(" ===============================================\n");
        BACKDOOR_MGR_Print(" Select = ");
        ch = BACKDOOR_MGR_GetChar();
#if 0
        if ((ch < 0x30)||(ch>0x39))
            continue;
        ch -= 0x30;
#endif

        BACKDOOR_MGR_Printf("%c",ch);
        switch (ch)
        {
            case '0' :
                eof = TRUE;
                break;
            case '1':
                SWDRV_BackDoor_Port_SubMenu();
                break;
            case '3':
                SWDRV_BackDoor_Port_Mapping_Table_SubMenu();
                break;

            case '4':
                SWDRV_BackDoor_Debug_SubMenu();
                break;

            case '5':
            {
                BACKDOOR_MGR_Print("\r\n 5. Input the port number: ");
                BACKDOOR_MGR_RequestKeyIn(inputStr, 31);
                port = atoi(inputStr);
                unit = 1;
#if (SYS_CPNT_STACKING == TRUE)
                SWDRV_OM_GetSystemInfoStackId(&unit);
#endif
                BACKDOOR_MGR_Printf("\r\nunit:%d, port:%d\r\n", unit, port);

                SWDRV_ShowPortSfpInfo(unit, port);

                break;
            }
#if 0
            case '2':
            {
                UI32_T cli_task_id;
                BOOL_T swdrv_chip_task_is_created;

                SWDRV_OM_GetChipTaskStatus(&swdrv_chip_task_is_created);
                if (swdrv_chip_task_is_created == FALSE)
                {
                    SYSFUN_TaskNameToID ("CLITASK0", &cli_task_id);

                    /* gordon: this must be modified to Linux spawn
                     */
                    /* vxSpawn(cli_task_id, 0, 0);
                     */
                    SWDRV_OM_SetChipTaskStatus(TRUE);

                }
                break;
            }
            case '3':
            {
                UI32_T tid, cli_task_id;

#ifdef BCM_SDK_5_4_X
                SYSFUN_TaskNameToID("bcmCLI", &tid);
#else
                SYSFUN_TaskNameToID("tSOC-CLI", &tid);
#endif

#if 0
                 /*resume BCM task*/
                 if(SYSFUN_ResumeThread(tid)== SYSFUN_OK)
                 {
                    printf("\r\nEnter Broadcom backdoor\r\r\n");
                    SYSFUN_Sleep(20);

                    /*suspend Mercury CLI task*/
                    SYSFUN_TaskNameToID ("CLITASK0", &cli_task_id);
                    SYSFUN_SuspendThread(cli_task_id);
                 }
                 else
                 {
                    printf("\r\nERROR: Cannot rusume backdoor debug tSOC-CLI task!\r\r\n\n");
                 }
#endif
                break;
            }
#endif
            /* OF TEST */
            case '6' :
                unit = 0;
                /*
                while (STKTPLG_POM_GetNextUnit(&unit))
                {
                    max_port_num = 0;
                    if (FALSE == STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_num))
                    {
                        printf("\r\n%s: %d, failed to get max port number of unit %ld\n", __FUNCTION__, __LINE__, unit);
                        continue;
                    }
                    for (port = 1; port <= max_port_num; port ++)
                    {

                        if (FALSE == SWDRV_DeletePortFromVlanMemberSet(unit, port, SYS_DFLT_1Q_PORT_VLAN_PVID))
                        {
                            printf("\r\n%s: %d, failed to remove unit %ld port %ld from VLAN %ld\n", __FUNCTION__, __LINE__, unit, port, vid);
                        }
                    }
                }
                */
                for (vid = 1; vid <= SYS_ADPT_MAX_VLAN_ID; vid ++)
                {
                    if (FALSE == SWDRV_CreateVlan(vid))
                    {
                        printf("\r\n%s: %d, failed to create VLAN %ld\n", __FUNCTION__, __LINE__, (long)vid);
                    }
                    if (FALSE == SWDRV_DeleteAllPortFromVlan(vid))
                    {
                        printf("\r\n%s: %d, failed to remove all port from VLAN %ld\n", __FUNCTION__, __LINE__, (long)vid);
                    }
                }
                break;

            case '7':
                BACKDOOR_MGR_Print(" \r\n");
                BACKDOOR_MGR_Print(" -----------------------------------------------\n");
                BACKDOOR_MGR_Print(" a. VLAN Flooding for Unknown UC - ");
                BACKDOOR_MGR_Printf("%s\n", vlan_flooding_flag_ukn_uc ? "TRUE" : "FALSE");
                BACKDOOR_MGR_Print(" b. VLAN Flooding for Unknown MC - ");
                BACKDOOR_MGR_Printf("%s\n", vlan_flooding_flag_ukn_mc ? "TRUE" : "FALSE");
                BACKDOOR_MGR_Print(" c. VLAN Flooding for BC - ");
                BACKDOOR_MGR_Printf("%s\n", vlan_flooding_flag_bc ? "TRUE" : "FALSE");
                BACKDOOR_MGR_Print(" d. Exit\n");
                BACKDOOR_MGR_Print(" -----------------------------------------------\n");
                BACKDOOR_MGR_Print(" Select = ");
                ch = BACKDOOR_MGR_GetChar();
                BACKDOOR_MGR_Printf("%c", ch);

                if (ch == 'a')
                {
                    for (vid = 1; vid <= SYS_ADPT_MAX_VLAN_ID; vid ++)
                    {
                        if (FALSE == SWDRV_SetVlanFloodingForUknUC(vid, !vlan_flooding_flag_ukn_uc))
                        {
                            printf("\r\n%s: %d, failed to disable VLAN %ld flooding for Uknown UC\n", __FUNCTION__, __LINE__, (long)vid);
                        }
                    }
                    vlan_flooding_flag_ukn_uc = !vlan_flooding_flag_ukn_uc;
                }
                else if (ch == 'b')
                {
                    for (vid = 1; vid <= SYS_ADPT_MAX_VLAN_ID; vid ++)
                    {
                        if (FALSE == SWDRV_SetVlanFloodingForUknMC(vid, !vlan_flooding_flag_ukn_mc))
                        {
                            printf("\r\n%s: %d, failed to disable VLAN %ld flooding for Uknown MC\n", __FUNCTION__, __LINE__, (long)vid);
                        }
                    }
                    vlan_flooding_flag_ukn_mc = !vlan_flooding_flag_ukn_mc;
                }
                else if (ch == 'c')
                {
                    for (vid = 1; vid <= SYS_ADPT_MAX_VLAN_ID; vid ++)
                    {
                        if (FALSE == SWDRV_SetVlanFloodingForBC(vid, !vlan_flooding_flag_bc))
                        {
                            printf("\r\n%s: %d, failed to disable VLAN %ld flooding for BC\n", __FUNCTION__, __LINE__, (long)vid);
                        }
                    }
                    vlan_flooding_flag_bc = !vlan_flooding_flag_bc;
                }
                break;

            case '8':
                unit = 0;
                while (STKTPLG_POM_GetNextUnit(&unit))
                {
                    max_port_num = 0;
                    if (FALSE == STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_num))
                    {
                        printf("\r\n%s: %d, failed to get max port number of unit %ld\n", __FUNCTION__, __LINE__, (long)unit);
                        continue;
                    }
                    for (port = 1; port <= max_port_num; port ++)
                    {
                        if (FALSE == SWDRV_EnablePortOpenFlowMode(unit, port))
                        {
                            printf("\r\n%s: %d, failed to enable unit %ld port %ld to open flow mode \n", __FUNCTION__, __LINE__, (long)unit, (long)port);
                        }
                    }
                }
                break;

            default :
                ch = 0;
                break;
        }
    }   /*  end of while    */
}   /*  ISC_BackDoor_Menu   */


#endif/*BACKDOOR_OPEN*/

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_EnableUMCASTIpTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will enable trap unknown multicast ip
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_EnableUMCASTIpTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_UMCAST_IP_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable trap umcast ip of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_UMCAST_IP_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalEnableUMCASTIpTrap())
        {

             return FALSE;
        }

        return TRUE;
    }
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DisableUMCASTIpTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will disable trap unknown multicast ip
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_DisableUMCASTIpTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_UMCAST_IP_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable trap UMCAST IP of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_UMCAST_IP_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableUMCASTIpTrap())
        {

            return FALSE;
        }

        return TRUE;
    }
}

void SWDRV_SfpInserted(UI32_T unit, UI32_T sfp_index)
{
    UI32_T port;

    STKTPLG_POM_SfpIndexToUserPort(unit, sfp_index, &port);

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
    SWDRV_LocalSetPortComboForcedModeToChip(port, FALSE, 0, 0);
#endif

    DEV_SWDRV_PMGR_UpdatePortSfpTxEnable(unit, port);
}


void SWDRV_SfpRemoved(UI32_T unit, UI32_T sfp_index)
{
    UI32_T port;

    STKTPLG_POM_SfpIndexToUserPort(unit, sfp_index, &port);

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
    SWDRV_LocalSetPortComboForcedModeToChip(port, FALSE, 0, 0);
#endif
}

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
static void SWDRV_MonitorCopperEnergyDetect(UI32_T port)
{
    UI32_T  copper_cable_insert = FALSE;
    UI32_T  stack_id;
    UI32_T  workaround_status;
    SWDRV_Port_Info_T swdrv_port_info;
/* Before to call the function, the port is no-neg (1000BASE-T) forced mode port.
 * And port type is copper (VAL_portType_thousandBaseT) also.
 */
    memset(&swdrv_port_info, 0, sizeof(swdrv_port_info));
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);
    if (swdrv_port_info.port_type != VAL_portType_thousandBaseT ||
        swdrv_port_info.is_autoneg != FALSE ||
        swdrv_port_info.speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex1000)
    {
        return;
    }

#if 0
    if (shmem_data_p->swdrv_port_info[port].port_type == VAL_portType_thousandBaseT &&
        shmem_data_p->swdrv_port_info[port].link_status)
    {
        return;
    }
#endif
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    SWDRV_LocalGetCopperEnergyDetect(stack_id, port, &copper_cable_insert);

    SWDRV_OM_GetWorkAroundStauts(port, &workaround_status);

    if (copper_cable_insert && swdrv_port_info.link_status)
    {
        UI32_T workaround_status;
        if (workaround_status == WORKAROUND_STATUS_FORCED)
            return;
        /* Step1: Set to phy register  0x00 to 0x0140 */
        DEV_SWDRV_PMGR_DisablePortAutoNeg(stack_id, port);
        /* Step2: Set the phy register 0x09 to config mode */
        DEV_SWDRV_PMGR_SetPort1000BaseTForceMode(stack_id, port, swdrv_port_info.forced_1000t_mode);
        SWDRV_OM_SetWorkAroundStatus(port, WORKAROUND_STATUS_FORCED);
    }
    else
    {
        if (workaround_status == WORKAROUND_STATUS_AUTO)
            return;
        /* Step1: Set to phy register  0x00 to 0x0140 */
        DEV_SWDRV_PMGR_EnablePortAutoNeg(stack_id, port);
        /* Step2: Set the phy register 0x09 to auto detection master/slave mode */
        DEV_SWDRV_PMGR_SetPort1000BaseTForceMode(stack_id, port, VAL_portMasterSlaveModeCfg_auto);
        SWDRV_OM_SetWorkAroundStatus(port, WORKAROUND_STATUS_AUTO);
    }

    return;
}
#endif

#if 0/*do not call this interface ,call new interface,michael.wang 20080829*/
static BOOL_T SWDRV_IsComboPort(UI32_T unit, UI32_T port,UI32_T *media_cap)
{
    UI32_T media_cap;

    if (FALSE == STKTPLG_POM_GetPortMediaCapability(unit, port, media_cap))
    {
        return FALSE;
    }

    return TRUE;

}
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
static BOOL_T SlaveSetPortForceMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
    return SWDRV_LocalSetPortComboForcedMode( request_p->unit,
                                       request_p->port,
                                       request_p->combo_forcedmode,
                                       request_p->combo_forced_mode_speed);
#else
    return SWDRV_LocalSetPortComboForcedMode( request_p->unit,
                                       request_p->port,
                                       request_p->combo_forcedmode );
#endif
}
#endif

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_EnableUMCASTMacTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will enable trap unknown multicast mac
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_EnableUMCASTMacTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_UMCAST_MAC_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable trap umcast MAC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_ENABLE_UMCAST_MAC_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableUMCASTMacTrap())
        {

            return FALSE;
        }

        return TRUE;
    }
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DisableUMCASTMacTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will disable trap unknown multicast mac
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_DisableUMCASTMacTrap(void)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DISABLE_UMCAST_MAC_TRAP)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* disable trap UMCAST MAC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DISABLE_UMCAST_MAC_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableUMCASTMacTrap())
        {

            return FALSE;
        }

        return TRUE;
    }
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DisablePortLearning
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion returns TRUE if the specified unit ID is
 *              one of the existed one. Otherwise, FALSE is returned.
 * INPUT    :   unit_id      --  Unit ID in stack
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_DisablePortLearning(UI32_T unit, UI32_T port)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_DISABLE_LEARNING)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* port security action trap and shutdown of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_DISABLE_LEARNING;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalDisablePortLearning(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

BOOL_T SWDRV_EnablePortLearning(UI32_T unit, UI32_T port)
{


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;


            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;  /* remote unit NOT exist */
            }
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_PORT_ENABLE_LEARNING)/* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* port security action trap and shutdown of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_PORT_ENABLE_LEARNING;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
            if (SWDRV_LocalEnablePortLearning(unit, port) == FALSE)
            {

                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/
    }

    return TRUE;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetPortLearningStatus
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port learning status and NA handling
 *              behavior
 * INPUT    :   unit
 *              port
 *              learning
 *              to_cpu
 *              drop
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetPortLearningStatus(UI32_T unit, UI32_T port, BOOL_T learning, BOOL_T to_cpu, BOOL_T drop)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T  unit_bmp = 0;

        if (!SWDRV_GetValidDrvUnitBmpByUnitPort(unit, port, &unit_bmp))
        {
            return FALSE;
        }

        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LEARNING_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID  = SWDRV_SET_PORT_LEARNING_STATUS;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.u32_u32_u32.u32_a1 = learning;
            isc_buffer_p->info.u32_u32_u32.u32_a2 = to_cpu;
            isc_buffer_p->info.u32_u32_u32.u32_a3 = drop;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

        if (unit_bmp == 0 || unit == 0)
#endif /*SYS_CPNT_STACKING*/
        {
            if(!SWDRV_LocalSetPortLearningStatus(unit, port, learning, to_cpu, drop))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_AddMyMACIP2Cpu
 * -------------------------------------------------------------------------
 * FUNCTION: Add mgmt MAC address and mgmt ip address.
 * INPUT   : UI32_T ip     - ip address
 *           UI8_T *mac    - MAC address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_AddMyMACIP2Cpu (UI8_T *mac, UI32_T ip)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    /* if stacking
     */
#if (SYS_CPNT_STACKING == TRUE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ADD_MY_MAC_IP_TO_CPU) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID               = SWDRV_ADD_MY_MAC_IP_TO_CPU;
            isc_buffer_p->info.my_mac_ip.my_ip    = ip;
            memcpy(isc_buffer_p->info.my_mac_ip.my_mac, mac, SYS_ADPT_MAC_ADDR_LEN);
            /* config slave / option module */
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
#if (SYS_CPNT_HRDRV == TRUE)
        if (HRDRV_AddMyMACIP2Cpu(mac, ip) == FALSE)
        {

            return FALSE;
        }

#endif

        return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif
    return FALSE;
} /* End of BOOL_T SWDRV_AddMyMACIP2Cpu (UI8_T *mac, UI32_T ip) */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_RemoveMyMACIP2Cpu
 * -------------------------------------------------------------------------
 * FUNCTION: Remove mgmt MAC address and mgmt ip address.
 * INPUT   : UI32_T ip     - ip address
 *           UI8_T *mac    - MAC address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_RemoveMyMACIP2Cpu (UI8_T *mac, UI32_T ip)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        return FALSE;
    }
    /* if stacking
     */
#if (SYS_CPNT_STACKING == TRUE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_REMOVE_MY_MAC_IP_TO_CPU) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            isc_buffer_p->ServiceID               = SWDRV_REMOVE_MY_MAC_IP_TO_CPU;
            isc_buffer_p->info.my_mac_ip.my_ip    = ip;
            memcpy(isc_buffer_p->info.my_mac_ip.my_mac, mac, SYS_ADPT_MAC_ADDR_LEN);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
#if (SYS_CPNT_HRDRV == TRUE)
        if (HRDRV_RemoveMyMACIP2Cpu(mac, ip) == FALSE)
        {

            return FALSE;
        }
#endif

        return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
    }
#endif
    return FALSE;
} /* End of BOOL_T SWDRV_RemoveMyMACIP2Cpu (UI8_T *mac, UI32_T ip) */

#if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetVlanLearningStatus
 * ------------------------------------------------------------------------
 * PURPOSE  : Enable/disable vlan learning of specified vlan
 * INPUT    : vid
 *            learning
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetVlanLearningStatus(UI32_T vid, BOOL_T learning)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
#if (SYS_CPNT_AMTR_HW_LEARN_ON_STANDALONE == FALSE)
    /* Now, SW learn does not need to set to chip.
     * We directly return here.
     */
    return TRUE;
#endif
    {
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T  unit_bmp = 0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VLAN_LEARNING_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID  = SWDRV_SET_VLAN_LEARNING_STATUS;
            isc_buffer_p->info.u32_b.u32_a1 = vid;
            isc_buffer_p->info.u32_b.bool_a1 = learning;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

#endif /*SYS_CPNT_STACKING*/
        if(!SWDRV_LocalSetVlanLearningStatus(vid, learning))
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif /* #if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE) */

#if (SYS_CPNT_OSPF == TRUE)
static BOOL_T Slave_EnableOSPFTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnableOSPFTrap(request_p->cpu_mac_addr);
}

static BOOL_T Slave_DisableOSPFTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalDisableOSPFTrap(request_p->cpu_mac_addr);
}
#endif

static BOOL_T SlaveAddMyMACIP2Cpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return HRDRV_AddMyMACIP2Cpu(request_p->info.my_mac_ip.my_mac,
                        request_p->info.my_mac_ip.my_ip);
#else
    return TRUE;
#endif
}

static BOOL_T SlaveRemoveMyMACIP2Cpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return HRDRV_RemoveMyMACIP2Cpu(request_p->info.my_mac_ip.my_mac,
                           request_p->info.my_mac_ip.my_ip);
#else
    return TRUE;
#endif
}

static BOOL_T SWDRV_LocalDisablePortLearning(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_DisablePortLearning(unit, port);
}

static BOOL_T SWDRV_LocalEnablePortLearning(UI32_T unit, UI32_T port)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_EnablePortLearning(unit, port);
}

static BOOL_T SWDRV_LocalSetPortLearningStatus(UI32_T unit, UI32_T port, BOOL_T learning, BOOL_T to_cpu, BOOL_T drop)
{
    if(!SWDRV_CheckPortIsExist(port))
        return FALSE;
    return DEV_SWDRV_PMGR_SetPortLearningStatus(unit, port, learning, to_cpu, drop);
}

#if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE)
static BOOL_T SWDRV_LocalSetVlanLearningStatus(UI32_T vid, BOOL_T learning)
{
#if (SYS_CPNT_AMTR_HW_LEARN_ON_STANDALONE == TRUE)
    return DEV_SWDRV_PMGR_SetVlanLearningStatus(vid, learning);
#else
    return TRUE;
#endif
}
#endif

#if (SYS_CPNT_OSPF == TRUE)
static BOOL_T SWDRV_LocalEnableOSPFTrap(UI8_T *cpu_mac)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return HRDRV_EnableTrapOspfToCpu(cpu_mac);
#else
    return TRUE;
#endif
}

static BOOL_T SWDRV_LocalDisableOSPFTrap(UI8_T *cpu_mac)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return HRDRV_DisableTrapOspfToCpu(cpu_mac);
#else
    return TRUE;
#endif
}
#endif

#if (SYS_CPNT_DOT1X == TRUE)
static BOOL_T SWDRV_LocalSetDot1xAuthTrap(UI32_T unit, UI32_T port, UI32_T mode)
{
#if (SYS_CPNT_HRDRV == TRUE)
    return HRDRV_SetDot1xAuthTrap(unit, port, mode);
#else
    return TRUE;
#endif
}

static BOOL_T SWDRV_LocalSetDot1xAuthControlMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    return DEV_SWDRV_PMGR_SetPortAuthMode(unit, port, mode);
}
#endif /* SYS_CPNT_DOT1X == TRUE */

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
static BOOL_T SWDRV_LocalSetEapolFramePassThrough(BOOL_T state)
{
    return DEV_SWDRV_PMGR_SetEapolFramePassThrough(state);
}
#endif /* #if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE) */

void SWDRV_LocalUpdatePortLinkStatus(UI32_T port, UI8_T new_port_status)
{
    UI8_T array_index;
    UI8_T bit_index;
    UI32_T stack_id;
    SWDRV_LinkStatus_T swdrv_port_link_status;


    array_index = SWDRV_LPORT_INDEX(port);
    bit_index = SWDRV_LPORT_BIT_IN_UI8_T(port);

    SWDRV_OM_SetPortInfoLinkStatus(port, new_port_status);
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    SWDRV_OM_GetPortLinkStatusBitmaps(stack_id, &swdrv_port_link_status);
    if(new_port_status)
    {
        /* Turn ON the specific bit.
         */
        swdrv_port_link_status.link_st_bitmap[array_index] |= bit_index;
    }
    else
    {
        /* Turn OFF the specific bit.
         */
        swdrv_port_link_status.link_st_bitmap[array_index] &= (~bit_index);
    }
    SWDRV_OM_SetPortLinkStatusBitmaps(stack_id, &swdrv_port_link_status, SWDRV_OM_F_REALTIME);

    if (SWDRV_OM_GetOperatingMode() == SYS_TYPE_STACKING_MASTER_MODE)
    {
#if (SYS_CPNT_HW_LINKSCAN == TRUE)
        /* To speed up link up notification,
         * notify upper layer here without sending event.
         */
        if (new_port_status)
        {
            swdrv_port_link_status.previous_link_st_bitmap[array_index] |= bit_index;
            SWDRV_OM_SetPortLinkStatusBitmaps(stack_id, &swdrv_port_link_status, SWDRV_OM_F_ANNOUNCED);
            SWDRV_Notify_PortLinkUp(stack_id, port);
        }
        else
        {
            swdrv_port_link_status.previous_link_st_bitmap[array_index] &= ~bit_index;
            SWDRV_OM_SetPortLinkStatusBitmaps(stack_id, &swdrv_port_link_status, SWDRV_OM_F_ANNOUNCED);
            SWDRV_Notify_PortLinkDown(stack_id, port);
        }
#else
        /* trigger Master to notify upper layer
         */
        UI32_T swdrv_thread_id;

        SWDRV_OM_GetThreadId(&swdrv_thread_id);
        SYSFUN_SendEvent (swdrv_thread_id, SWDRV_EVENT_UPDATE_PORT_LINK_STATUS);
#endif
    }
}

#if (SYS_CPNT_EFM_OAM == TRUE)
static BOOL_T SWDRV_LocalSetOamLoopback(
    UI32_T unit, UI32_T port, BOOL_T is_enable, UI32_T type)
{
#define LOOPBACK_PASSIVE    0 /* SWCTRL_LOOPBACK_MODE_TYPE_PASSIVE */
#define LOOPBACK_ACTIVE     1 /* SWCTRL_LOOPBACK_MODE_TYPE_ACTIVE  */

    BOOL_T  ret = FALSE;

    /* only support passive...
     */
    if (LOOPBACK_PASSIVE == type)
    {
#if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY_BY_RULE != TRUE)
        ret =  DEV_SWDRV_PMGR_SetOamPduToCpu(unit, port, is_enable);
        ret &= DEV_SWDRV_PMGR_SetOamLoopback(unit, port, is_enable);
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY_BY_RULE != TRUE) */
    }

    return ret;
}

static BOOL_T SlaveSetOamLoopback(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetOamLoopback(request_p->unit,
                                     request_p->port,
                                     request_p->info.efm_oam.is_enable,
                                     request_p->info.efm_oam.type);
}
#endif /* (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
static BOOL_T SWDRV_LocalSetInternaLoopback(UI32_T unit, UI32_T port, BOOL_T is_enable)
{
    if(is_enable)
        return DEV_SWDRV_PMGR_EnableInternalLoopback(port);
    else
        return DEV_SWDRV_PMGR_DisableInternalLoopback(port);
}

static BOOL_T SlaveSetInternalLoopback(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetInternaLoopback(request_p->unit,
                                         request_p->port,
                                         request_p->info.internal_loopback_status.is_enable);

}
#endif

/*------------------------------------------------------------------------------
 * FUNCTION NAME: SWDRV_GetValidDrvUnitBmp
 *------------------------------------------------------------------------------
 * PURPOSE: Getting UnitBmp for all exist unit or module.
 * INPUT  : None
 * OUTPUT : None
 * RETURN : unit_bmp    -- which driver units are exist
 * NOTES  : This function is to search all exist unit id by stktplg
 *          then ISC can forward the information to all exist unit.
 *------------------------------------------------------------------------------*/
static UI16_T SWDRV_GetValidDrvUnitBmp(void)
{
    UI32_T unit_index;
    UI16_T unit_bmp=0;
    UI32_T  stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    for (unit_index = 0; STKTPLG_POM_GetNextDriverUnit(&unit_index); )
    {
        if (unit_index == stack_id)
        {
            continue;
        }
        unit_bmp |= BIT_VALUE(unit_index-1);
    }
    return unit_bmp;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME: SWDRV_GetValidUnitBmp
 *------------------------------------------------------------------------------
 * PURPOSE: Getting UnitBmp for all exist unit or module.
 * INPUT  : None
 * OUTPUT : None
 * RETURN : unit_bmp    -- which units are exist
 * NOTES  : This function is to search all exist unit id by stktplg
 *          then ISC can forward the information to all exist unit.
 *------------------------------------------------------------------------------*/
static UI16_T SWDRV_GetValidUnitBmp(void)
{
    UI32_T unit_index;
    UI16_T unit_bmp=0;
    UI32_T  stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    for (unit_index = 0; STKTPLG_POM_GetNextUnit(&unit_index); )
    {
        if (unit_index == stack_id)
        {
            continue;
        }
        unit_bmp |= BIT_VALUE(unit_index-1);
    }
    return unit_bmp;
}

static BOOL_T SWDRV_CheckPortIsExist(UI32_T port)
{
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_Port_Info_T   swdrv_port_info;
    memset(&swdrv_system_info, 0, sizeof(SWDRV_Switch_Info_T));
    memset(&swdrv_port_info, 0, sizeof(SWDRV_Port_Info_T));

    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    SWDRV_OM_GetPortInfo(port, &swdrv_port_info);

    if ( ((port < swdrv_system_info.base_port_id) ||
          (port > swdrv_system_info.base_port_id+swdrv_system_info.port_number-1))  ||
          (FALSE == swdrv_port_info.existing))
          return FALSE;

    return TRUE;
}

static UI16_T SWDRV_GetValidDrvUnitBmpByUnitPort(UI32_T unit, UI32_T port, UI16_T *unit_bmp)
{
    UI32_T max_port_number, stack_id;

    if (unit == 0) /* set all unit */
    {
        *unit_bmp = SWDRV_GetValidDrvUnitBmp();
    }
    else
    {
        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            UI32_T  drv_unit;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     *unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 *unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }
        }
    }

    return TRUE;
}

/*Add by fen.wang*/
/*------------------------------------------------------------------------------
 * FUNCTION NAME: SWDRV_CheckModulePortExist
 *------------------------------------------------------------------------------
 * PURPOSE: check if has module port
 * INPUT  : maxport  main board max port
 * OUTPUT : None
 * RETURN : True    -- module port exist
                        FALSE--- not exist
 * NOTES  :
 *------------------------------------------------------------------------------*/

static BOOL_T SWDRV_CheckModulePortExist(UI32_T maxport, UI8_T *port_list,UI16_T maxlist)
{
   UI16_T byte=maxport/8;
   UI16_T shift =maxport%8;
   UI8_T tem_value;

   if(port_list== NULL)
    return FALSE;

   if(shift == 0)
     byte = byte +1;
   else
   {
       tem_value = port_list[byte]<<shift;
       if(tem_value !=0)
        return TRUE;
       else
         byte++;/*add by fen.wang,in order to check the next byte or it will check the curret byte
                                      and may always return TRUE*/
   }

   for(;byte<maxlist;byte++)
   {
      if(port_list[byte]!=0)
       return TRUE;
   }
   return FALSE;
}

BOOL_T SWDRV_SetPortToVlanMemberSet(UI32_T vid, UI8_T *port_list)
{
    UI32_T  stack_id;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    SWDRV_OM_GetSystemInfoStackId(&stack_id);

#if (SYS_CPNT_STACKING == TRUE)
    UI32_T  unit_id;

    for (unit_id = 1; unit_id <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit_id++)
    {
        if (unit_id != stack_id)
        {
            /* remote unit
             */
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;
            UI32_T              max_port_number;

            if (STKTPLG_POM_UnitExist(unit_id) == FALSE)
            {
                continue;
            }

            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit_id, &max_port_number) == FALSE)
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_TO_VLAN_MEMBER_SET) /* user_id */);

            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID         = SWDRV_SET_PORT_TO_VLAN_MEMBER_SET;
            isc_buffer_p->unit              = unit_id;
            isc_buffer_p->info.vlan_set.vid = vid;
            memcpy(isc_buffer_p->info.vlan_set.port_list,
                   &port_list[(unit_id-1)*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST],
                   SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

            /* step 1: check any option port exist */
/*add by fen.wang 2008-8-15,check module port exist*/
#if 0
            if (isc_buffer_p->info.vlan_set.port_list[max_port_number/8] != 0)
#else
            if (SWDRV_CheckModulePortExist(max_port_number,isc_buffer_p->info.vlan_set.port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST))
#endif
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit_id, &drv_unit) == TRUE)
                {
                     unit_bmp |= SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    L_MM_Mref_Release(&mref_handle_p);
                    return FALSE;
                }
            }

            /* step 2: set remote unit */
            unit_bmp |= SWDRV_UNIT_TO_UNITBMP(unit_id);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)
                != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING*/

            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortToVlanMemberSet(stack_id, vid,
                    &port_list[(stack_id-1)*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST]) == FALSE)
            {
                return FALSE;
            }

#if (SYS_CPNT_STACKING == TRUE)
        } /* end of else */
    } /* end of for */
#endif /*SYS_CPNT_STACKING*/

    return TRUE;
}

static BOOL_T SlaveSetPortToVlanMemberSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortToVlanMemberSet(request_p->unit,
                                             request_p->info.vlan_set.vid,
                                             request_p->info.vlan_set.port_list);
}

static BOOL_T SWDRV_LocalSetPortToVlanMemberSet(UI32_T unit_id, UI32_T vid, UI8_T *port_list)
{
    return DEV_SWDRV_PMGR_SetPortToVlanMemberSet(unit_id, vid, port_list);
}

BOOL_T SWDRV_SetPortToVlanUntaggedSet(UI32_T vid, UI8_T *port_list)
{
    UI32_T  stack_id;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    SWDRV_OM_GetSystemInfoStackId(&stack_id);

#if (SYS_CPNT_STACKING == TRUE)
    UI32_T  unit_id;

    for (unit_id = 1; unit_id <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit_id++)
    {
        if (unit_id != stack_id)
        {
            /* remote unit
             */
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            UI32_T              drv_unit;
            UI32_T              max_port_number;

            if (STKTPLG_POM_UnitExist(unit_id) == FALSE)
            {
                continue;
            }

            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit_id, &max_port_number) == FALSE)
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_TO_VLAN_UNTAGGED_SET) /* user_id */);

            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID         = SWDRV_SET_PORT_TO_VLAN_UNTAGGED_SET;
            isc_buffer_p->unit              = unit_id;
            isc_buffer_p->info.vlan_set.vid = vid;
            memcpy(isc_buffer_p->info.vlan_set.port_list,
                   &port_list[(unit_id-1)*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST],
                   SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

 /* step 1: check any option port exist *//*add by fen.wang 2008-8-15,check module port exist*/
#if 0
            if (isc_buffer_p->info.vlan_set.port_list[max_port_number/8] != 0)
#else
            if (SWDRV_CheckModulePortExist(max_port_number,isc_buffer_p->info.vlan_set.port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST))
#endif
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit_id, &drv_unit) == TRUE)
                {
                     unit_bmp |= SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    L_MM_Mref_Release(&mref_handle_p);
                    return FALSE;
                }
            }

            /* step 2: set remote unit */
            unit_bmp |= SWDRV_UNIT_TO_UNITBMP(unit_id);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)
                != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING*/

            /* if local unit or standalone
             */
            if (SWDRV_LocalSetPortToVlanUntaggedSet(stack_id, vid,
                    &port_list[(stack_id-1)*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST]) == FALSE)
            {
                return FALSE;
            }

#if (SYS_CPNT_STACKING == TRUE)
        } /* end of else */
    } /* end of for */
#endif /*SYS_CPNT_STACKING*/

    return TRUE;
}

static BOOL_T SlaveSetPortToVlanUntaggedSet(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortToVlanUntaggedSet(request_p->unit,
                                               request_p->info.vlan_set.vid,
                                               request_p->info.vlan_set.port_list);
}

static BOOL_T SWDRV_LocalSetPortToVlanUntaggedSet(UI32_T unit_id, UI32_T vid, UI8_T *port_list)
{
    return DEV_SWDRV_PMGR_SetPortToVlanUntaggedSet(unit_id, vid, port_list);
}

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetCableDiag
 * -------------------------------------------------------------------------
 * FUNCTION: Get Cable diag result of specific port by latest result
 * INPUT   : lport : Logical port num
 * OUTPUT  : cable_diag_result : result of the cable diag test for the port
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetCableDiag(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_result)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_CABLE_DIAG) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* get copper energy detect of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_GET_CABLE_DIAG;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (!ISC_RemoteCall((UI8_T)unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE; /* can't control remote unit */
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            memcpy(cable_diag_result, &isc_reply.data.cable_diag, sizeof(SWDRV_CableDiagInfo_T));
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalGetCableDiag(unit, port, cable_diag_result) == FALSE)
        {
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }
    return TRUE;
}

static BOOL_T SWDRV_LocalGetCableDiag(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_result)
{
    DEV_SWDRV_CableDiagResult_T diag_result;

    if(!SWDRV_CheckPortIsExist(port))
    {
        return FALSE;
    }

    if(!DEV_SWDRV_PMGR_GetCableDiag(unit, port, &diag_result))
    {
        return FALSE;
    }

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
    cable_diag_result->state = diag_result.state;
    cable_diag_result->npairs = diag_result.npairs;
    memcpy(cable_diag_result->pair_state, diag_result.pair_state, sizeof(UI32_T) * 4);
    memcpy(cable_diag_result->pair_len, diag_result.pair_len, sizeof(UI32_T) * 4);
    cable_diag_result->fuzz_len = diag_result.fuzz_len;
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
#else
#error "Chip not defined!"
#endif

    return TRUE;
}

static BOOL_T SlaveGetCableDiag(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_CABLE_DIAG) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetCableDiag(request_p->unit, request_p->port, &isc_reply_p->data.cable_diag);

    return ISC_RemoteReply(mref_handle_p, key);
}

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetCableDiagResult
 * -------------------------------------------------------------------------
 * FUNCTION: Get Cable diag result of specific port after test
 * INPUT   : lport : Logical port num
 * OUTPUT  : cable_diag_result : result of the cable diag test for the port
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetCableDiagResult(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_result)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_CABLE_DIAG_RESULT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* get copper energy detect of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_GET_CABLE_DIAG_RESULT;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (!ISC_RemoteCall((UI8_T)unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE; /* can't control remote unit */
            }

            if (!isc_reply.return_value.bool)
                return FALSE;

            memcpy(cable_diag_result, &isc_reply.data.cable_diag, sizeof(SWDRV_CableDiagInfo_T));
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalGetCableDiagResult(unit, port, cable_diag_result) == FALSE)
            {
                return FALSE;
            }
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }
    return TRUE;
}

static BOOL_T SWDRV_LocalGetCableDiagResult(UI32_T unit, UI32_T port, SWDRV_CableDiagInfo_T *cable_diag_result)
{
    DEV_SWDRV_CableDiagResultGeneral_T diag_result;

    if (!SWDRV_CheckPortIsExist(port))
    {
        return FALSE;
    }

    if (!DEV_SWDRV_PMGR_GetCableDiagResult(unit, port, &diag_result))
    {
        return FALSE;
    }

    if (sizeof(DEV_SWDRV_CableDiagResultGeneral_T) == sizeof(SWDRV_CableDiagInfo_T))
        memcpy(cable_diag_result, &diag_result, sizeof(DEV_SWDRV_CableDiagResultGeneral_T));
    else
    {
        printf("cable diag data structure size is wrong between dev_swdrv and swdrv!!");
        return FALSE;
    }

    return TRUE;
}

static BOOL_T SlaveGetCableDiagResult(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_CABLE_DIAG_RESULT) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetCableDiagResult(request_p->unit, request_p->port, &isc_reply_p->data.cable_diag);

    return ISC_RemoteReply(mref_handle_p, key);
}
#endif
#endif


#if (SYS_CPNT_MLDSNP == TRUE)
static BOOL_T SWDRV_LocalEnableMldPacketTrap()
{
    return DEV_SWDRV_PMGR_EnableMLDTrap2CPU();
}
static BOOL_T SWDRV_LocalDisableMldPacketTrap()
{
    return DEV_SWDRV_PMGR_DisableMLDTrap2CPU();
}

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveEnableMldPacketTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    /* it is sent by ISC_SendMcastReliable() with is_ack_by_app = FALSE
     * no need to sent ACK back
     */
    return SWDRV_LocalEnableMldPacketTrap();
}

static BOOL_T SlaveDisableMldPacketTrap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    /* it is sent by ISC_SendMcastReliable() with is_ack_by_app = FALSE
     * no need to sent ACK back
     */
    return SWDRV_LocalDisableMldPacketTrap();
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableMldPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: Enable MLD packet trap to CPU
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableMldPacketTrap(void)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_MLD_PACKET_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }
            /* create vlan id of remote all unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_MLD_PACKET_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalEnableMldPacketTrap())
        {
            return FALSE;
        }

        return TRUE;
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DisableMldPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: Disable MLD packet trap to CPU
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DisableMldPacketTrap(void)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_OSPF_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }
            /* create vlan id of remote all unit
             */
            isc_buffer_p->ServiceID = SWDRV_DISABLE_MLD_PACKET_TRAP;
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalDisableMldPacketTrap())
        {

            return FALSE;
        }

        return TRUE;
    }
}
#endif /*#if (SYS_CPNT_MLDSNP == TRUE)*/

#if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE)
static BOOL_T SWDRV_LocalSetRaAndRrPacketTrap(
    BOOL_T  is_enabled)
{
#if (SYS_CPNT_IPV6_RA_GUARD_TRAP_BY_REG == TRUE)
    return DEV_SWDRV_PMGR_SetRaAndRrTrap2CPU(is_enabled);
#else
    /* not implement...
     */
    return FALSE;
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_TRAP_BY_REG == TRUE) */
}

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetRaAndRrPacketTrap(
    ISC_Key_T           *key,
    SWDRV_Rx_IscBuf_T   *request_p)
{
    /* it is sent by ISC_SendMcastReliable() with is_ack_by_app = FALSE
     * no need to sent ACK back
     */
    return SWDRV_LocalSetRaAndRrPacketTrap(request_p->info.set_ra_and_rr_trap.is_enabled);
}
#endif /* #if (SYS_CPNT_STACKING == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetRaAndRrPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: Enable/disable RA/RR packet trap to CPU
 * INPUT   : is_enabled - TRUE to enable
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetRaAndRrPacketTrap(
    BOOL_T  is_enabled)
{
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_RA_AND_RR_PACKET_TRAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }
            /* create vlan id of remote all unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_RA_AND_RR_PACKET_TRAP;
            isc_buffer_p->info.set_ra_and_rr_trap.is_enabled = is_enabled;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        if(!SWDRV_LocalSetRaAndRrPacketTrap(is_enabled))
        {
            return FALSE;
        }

        return TRUE;
    }
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE) */

#if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortRaAndRrPacketDrop
 * -------------------------------------------------------------------------
 * FUNCTION: Enable/disable RA/RR packet drop by specified unit/port.
 * INPUT   : unit       - unit to enable/disable
 *           port       - port to enable/disable
 *         : is_enabled - TRUE to enable
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortRaAndRrPacketDrop(UI32_T unit, UI32_T port, BOOL_T is_enabled)
{
    RULE_TYPE_INTERFACE_INFO_T interface_info;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* redirect to rule_ctrl, rule_ctrl will do the isc work by itself.
     */
    interface_info.type = RULE_TYPE_INTERFACE_UPORT;
    interface_info.uport.unit = unit;
    interface_info.uport.port = port;
    interface_info.direction = RULE_TYPE_INBOUND;

    RULE_CTRL_IP6_RA_Guard_DenyRAPacket(is_enabled, &interface_info);
    RULE_CTRL_IP6_RA_Guard_DenyRRPacket(is_enabled, &interface_info);

    return TRUE;
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE) */

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL == TRUE)

static BOOL_T SWDRV_LocalSetRateBasedStormControl(UI32_T unit, UI32_T port, UI32_T rate, UI32_T mode)
{
    return DEV_SWDRVL4_PMGR_SetRateBasedStormControl(unit, port, rate, mode);
}

static BOOL_T SlaveSetRateBasedStormControl(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetRateBasedStormControl(request_p->unit, request_p->port, request_p->storm_rate, request_p->storm_mode);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetRateBasedStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set rate based storm control
 * INPUT   : unit
 *           port
 *           rate
 *           mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : Forced mode only
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetRateBasedStormControl(UI32_T unit, UI32_T port, UI32_T rate, UI32_T mode)
{

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T stack_id;

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( stack_id != unit )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
            BOOL_T              is_option=FALSE;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_RATE_BASED_STORM_CONTROL) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* set forced port mode of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_RATE_BASED_STORM_CONTROL;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;
            isc_buffer_p->storm_rate = rate;
            isc_buffer_p->storm_mode = mode;
            unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE;
            }
        }
        else
        {
#endif /*SYS_CPNT_STACKING */
            /* if local unit or standalone
             */
            if (SWDRV_LocalSetRateBasedStormControl(unit, port, rate, mode) == FALSE)
            {
                return FALSE;
            }

#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING */
    }

    return TRUE;
}

#endif
static void SWDRV_BD_IncRxCounter(UI16_T type)
{
   if(type >SWDRV_NBR_OF_SERVICE_ID)  /*added by Jinhua Wei ,to remove warning ,becaued the type's value can't be smaller than 0*/
    swdrv_isc_rx_counter[SWDRV_NBR_OF_SERVICE_ID]++;
   else
    swdrv_isc_rx_counter[type]++;
}

void SWDRV_BD_ShowRxCounter()
{
    UI16_T i;
#if 0 /* JinhuaWei, 03 August, 2008 2:58:33 */
    UI16_T j;
#endif /* #if 0 */
    UI32_T allcounter =0;

    printf("===========SWDRV ISC COUNTER==============\n");
    for(i = 0 ;i <SWDRV_NBR_OF_SERVICE_ID+1; i++ )
    {
        if(swdrv_isc_rx_counter[i]!=0)
        {
            allcounter = allcounter + swdrv_isc_rx_counter[i];
            printf("type %5d counter %5ld         \n",i,(long)swdrv_isc_rx_counter[i]);
        }
    }
    printf("=============================================\n");
    printf("all counter %ld\n", (long)allcounter);
}
void SWDRV_BD_ClearRxCounter()
{
   memset(swdrv_isc_rx_counter,0,sizeof(swdrv_isc_rx_counter));
}

void SWDRV_BD_ClearRxMaxTick()
{
    memset(swdrv_isc_max_tick,0,sizeof(swdrv_isc_max_tick));

}
void SWDRV_BD_DumpRxMaxTick()
{
   printf("\r\n=======ISC Agent Speed=======");
   printf("\r\n max tick %ld ,service ID %lu", (long)swdrv_isc_max_tick[0], (long)swdrv_isc_max_tick[1]);

}

#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
#define SWDRV_IFINDEX_TO_UNIT(ifindex)             ( ((UI32_T)(((ifindex)-1)/(SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)))+1 )
#define SWDRV_IFINDEX_TO_PORT(ifindex)             ( (ifindex) - (SWDRV_IFINDEX_TO_UNIT(ifindex)-1)*(SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT) )
#define SWDRV_IS_PORTLIST_MEMBER(port_list, port)  (((port_list[((port) - 1) >> 3]) & (1 << (7 - (((port) - 1) & 7)))) != 0)


BOOL_T SWDRV_DisableIngressFilter_PortList(UI8_T *port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_DISABLE_INGRESS_FILTER;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_LocalDisableIngressFilter(unit, port) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */


BOOL_T SWDRV_EnableIngressFilter_PortList(UI8_T *port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_ENABLE_INGRESS_FILTER;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT; lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_LocalEnableIngressFilter(unit, port) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */

BOOL_T SWDRV_AdmitAllFrames_PortList(UI8_T *port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_ADMIT_ALL_FRAMES;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_LocalAdmitAllFrames(unit, port) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */


BOOL_T SWDRV_SetPortPVID_PortList(UI8_T *port_list,UI32_T pvid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_SET_PORT_PVID;
            isc_buffer_p->vlan_pvid = pvid;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_LocalSetPortPVID(unit, port,pvid) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */

BOOL_T SWDRV_AddPortToVlanMemberSet_PortList(UI8_T *port_list,UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_ADD_PORT_TO_VLAN_MEMBER_SET;
            isc_buffer_p->vlan_vid  = vid;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_LocalAddPortToVlanMemberSet(unit, port,vid) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */

BOOL_T SWDRV_AddPortToVlanUntaggedSet_PortList(UI8_T *port_list,UI32_T vid)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
    UI32_T              unit,port,lport;
    UI32_T  max_port_number;
    UI32_T  stack_id;


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                        /* create vlan id of remote all unit
                        */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
            isc_buffer_p->SubServiceID = SWDRV_ADD_PORT_TO_VLAN_UNTAGGED_SET;
            isc_buffer_p->vlan_vid  = vid;
            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                 mref_handle_p,
                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

    }
#endif
            /* if local unit or standalone
             */

   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport ++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
            continue;
        unit = SWDRV_IFINDEX_TO_UNIT(lport);
        port = SWDRV_IFINDEX_TO_PORT(lport);

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
           #endif
           )
           continue;
        else
        {
            if ( SWDRV_localAddPortToVlanUntaggedSet(unit, port,vid) == FALSE)
            {

                return FALSE;
            }
        }
    }
  }

    return TRUE;
} /* End of SWDRV_DisableIngressFilter() */

static BOOL_T SlaveSetLocalPortListInfo(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T  lport;
    UI32_T  stack_id;
    SWDRV_Switch_Info_T swdrv_system_info;

    SWDRV_OM_GetSystemInfo(&swdrv_system_info);
    SWDRV_OM_GetSystemInfoStackId(&stack_id);
    for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
    {
        if(!SWDRV_IS_PORTLIST_MEMBER(request_p->portlist,lport+1))
            continue;

        request_p->unit = SWDRV_IFINDEX_TO_UNIT(lport);

        if(stack_id != request_p->unit)
            continue;

        request_p->port = SWDRV_IFINDEX_TO_PORT(lport);
        if(request_p->port > swdrv_system_info.port_number)
         continue;

        if(!SWDRV_func_tab[request_p->SubServiceID](key,request_p))
            return FALSE;
    }
  return TRUE;
}

BOOL_T SWDRV_SetPortListComboForcedMode(UI8_T *port_list,UI32_T forcedmode)
{
#if (SYS_CPNT_STACKING == TRUE)
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
        UI32_T              unit,port,lport;
        UI32_T  max_port_number;
        UI32_T  stack_id;


        if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
        {

             /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }
        else
        {
            /* if remote unit
             */
#if (SYS_CPNT_STACKING == TRUE)
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
            if (unit_bmp!=0)
            {
                mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                if (isc_buffer_p==NULL)
                {

                    return FALSE;
                }
                            /* create vlan id of remote all unit
                            */
                isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                isc_buffer_p->SubServiceID = SWDRV_SET_PORT_FORCED_MODE;
                isc_buffer_p->combo_forcedmode  = forcedmode;
                memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                     mref_handle_p,
                                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

        }
#endif
                /* if local unit or standalone
                 */

       for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
        {
            if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                continue;
            unit = SWDRV_IFINDEX_TO_UNIT(lport);
            port = SWDRV_IFINDEX_TO_PORT(lport);

            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
            {

                return FALSE;
            }

            SWDRV_OM_GetSystemInfoStackId(&stack_id);
            if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                 && (port != SYS_ADPT_MGMT_PORT)
           #endif
               )
               continue;
            else
            {
                if ( SWDRV_LocalSetPortComboForcedMode(unit, port, forcedmode)==FALSE)
                {

                    return FALSE;
                }
            }
        }
      }

        return TRUE;
}

BOOL_T SWDRV_EnablePortListAdmin(UI8_T *port_list)
{
    {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
            UI32_T              unit,port,lport;
            UI32_T  max_port_number;
            UI32_T  stack_id;


            if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
            {

                 /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            else
            {
                /* if remote unit
                 */
#if (SYS_CPNT_STACKING == TRUE)
                unit_bmp = SWDRV_GetValidDrvUnitBmp();
                if (unit_bmp!=0)
                {
                    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                    if (isc_buffer_p==NULL)
                    {

                        return FALSE;
                    }
                                /* create vlan id of remote all unit
                                */
                    isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                    isc_buffer_p->SubServiceID = SWDRV_ENABLE_PORT_ADMIN;
                    memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                    ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                         mref_handle_p,
                                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

            }
#endif
                    /* if local unit or standalone
                     */

           for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
            {
                if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                    continue;
                unit = SWDRV_IFINDEX_TO_UNIT(lport);
                port = SWDRV_IFINDEX_TO_PORT(lport);

                if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                {

                    return FALSE;
                }

                SWDRV_OM_GetSystemInfoStackId(&stack_id);
                if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                     && (port != SYS_ADPT_MGMT_PORT)
           #endif
                   )
                   continue;
                else
                {
                    if ( SWDRV_LocalEnablePortAdmin(unit, port)==FALSE)
                    {

                        return FALSE;
                    }
                }
            }
          }

            return TRUE;
    }

}

BOOL_T SWDRV_DisablePortListAdmin(UI8_T *port_list)

{
    {
#if (SYS_CPNT_STACKING == TRUE)
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
            UI32_T              unit,port,lport;
            UI32_T  max_port_number;
            UI32_T  stack_id;


            if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
            {

                 /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            else
            {
                /* if remote unit
                 */
#if (SYS_CPNT_STACKING == TRUE)
                unit_bmp = SWDRV_GetValidDrvUnitBmp();
                if (unit_bmp!=0)
                {
                    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                          L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                    isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                    if (isc_buffer_p==NULL)
                    {

                        return FALSE;
                    }
                                /* create vlan id of remote all unit
                                */
                    isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                    isc_buffer_p->SubServiceID = SWDRV_DISABLE_PORT_ADMIN;
                    memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

                    ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                         mref_handle_p,
                                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

            }
#endif
                    /* if local unit or standalone
                     */

           for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
            {
                if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                    continue;
                unit = SWDRV_IFINDEX_TO_UNIT(lport);
                port = SWDRV_IFINDEX_TO_PORT(lport);

                if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                {

                    return FALSE;
                }

                SWDRV_OM_GetSystemInfoStackId(&stack_id);
                if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                     && (port != SYS_ADPT_MGMT_PORT)
           #endif
                   )
                   continue;
                else
                {
                    if ( SWDRV_LocalDisablePortAdmin(unit, port)==FALSE)
                    {

                        return FALSE;
                    }
                }
            }
          }

            return TRUE;
    }

}
BOOL_T SWDRV_SetPortListAutoNegCapability(UI8_T *port_list,UI32_T capability)
{
    UI32_T checkval;
    UI32_T swdrv_capability = 0;

       if (capability & SYS_VAL_portCapabilities_portCap10half)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap10half;
       if (capability & SYS_VAL_portCapabilities_portCap10full)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap10full;
       if (capability & SYS_VAL_portCapabilities_portCap100half)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap100half;
       if (capability & SYS_VAL_portCapabilities_portCap100full)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap100full;
       if (capability & SYS_VAL_portCapabilities_portCap1000half)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap1000half;
       if (capability & SYS_VAL_portCapabilities_portCap1000full)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap1000full;
       if (capability & SYS_VAL_portCapabilities_portCap10gFull)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap10gFull;
       if (capability & SYS_VAL_portCapabilities_portCap40gFull)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap40gFull;
       if (capability & SYS_VAL_portCapabilities_portCap100gFull)
           swdrv_capability |= SYS_VAL_portCapabilities_portCap100gFull;
       if (capability & SYS_VAL_portCapabilities_portCapSym)
           swdrv_capability |= SYS_VAL_portCapabilities_portCapSym;
       if (capability & SYS_VAL_portCapabilities_portCapFlowCtrl)
           swdrv_capability |= SYS_VAL_portCapabilities_portCapFlowCtrl;

       /* for combo port use */
       checkval = SYS_VAL_portCapabilities_portCap10half   | SYS_VAL_portCapabilities_portCap10full   |
                  SYS_VAL_portCapabilities_portCap100half  | SYS_VAL_portCapabilities_portCap100full  |
                  SYS_VAL_portCapabilities_portCap1000half | SYS_VAL_portCapabilities_portCap1000full |
                  SYS_VAL_portCapabilities_portCap10gFull  | SYS_VAL_portCapabilities_portCap40gFull  |
                  SYS_VAL_portCapabilities_portCap100gFull |
                  SYS_VAL_portCapabilities_portCapSym  | SYS_VAL_portCapabilities_portCapFlowCtrl;
       if(swdrv_capability & ~((UI32_T)checkval))
           return FALSE;

        {
#if (SYS_CPNT_STACKING == TRUE)
                L_MM_Mref_Handle_T* mref_handle_p;
                SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                UI32_T              pdu_len;
                UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                UI32_T              unit,port,lport;
                UI32_T  max_port_number;
                UI32_T  stack_id;


                if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                {

                     /* UIMSG_MGR_SetErrorCode() */
                    return FALSE;
                }
                else
                {
                    /* if remote unit
                     */
#if (SYS_CPNT_STACKING == TRUE)
                    unit_bmp = SWDRV_GetValidDrvUnitBmp();
                    if (unit_bmp!=0)
                    {
                        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                        if (isc_buffer_p==NULL)
                        {

                            return FALSE;
                        }
                                    /* create vlan id of remote all unit
                                    */
                        isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                        isc_buffer_p->SubServiceID = SWDRV_SET_PORT_AUTONEG_CAPABILITY;
                        isc_buffer_p->port_cfg_capability= swdrv_capability;
                        memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                             mref_handle_p,
                                                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                }
#endif
                        /* if local unit or standalone
                         */

               for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                {
                    if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                        continue;
                    unit = SWDRV_IFINDEX_TO_UNIT(lport);
                    port = SWDRV_IFINDEX_TO_PORT(lport);

                    if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                    {

                        return FALSE;
                    }

                    SWDRV_OM_GetSystemInfoStackId(&stack_id);
                    if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                         && (port != SYS_ADPT_MGMT_PORT)
           #endif
                       )
                       continue;
                    else
                    {
                        if ( SWDRV_LocalSetPortAutoNegCapability(unit, port,swdrv_capability)==FALSE)
                        {

                            return FALSE;
                        }
                    }
                }
              }

                return TRUE;
        }

}

BOOL_T SWDRV_DisablePortListSecurity(UI8_T *port_list)
{
        {
#if (SYS_CPNT_STACKING == TRUE)
                L_MM_Mref_Handle_T* mref_handle_p;
                SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                UI32_T              pdu_len;
                UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                UI32_T              unit,port,lport;
                UI32_T  max_port_number;
                UI32_T  stack_id;


                if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                {

                     /* UIMSG_MGR_SetErrorCode() */
                    return FALSE;
                }
                else
                {
                    /* if remote unit
                     */
#if (SYS_CPNT_STACKING == TRUE)
                    unit_bmp = SWDRV_GetValidDrvUnitBmp();
                    if (unit_bmp!=0)
                    {
                        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                        if (isc_buffer_p==NULL)
                        {

                            return FALSE;
                        }
                                    /* create vlan id of remote all unit
                                    */
                        isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                        isc_buffer_p->SubServiceID = SWDRV_DISABLE_PORT_SECURITY;
                        memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                        ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                             mref_handle_p,
                                                             SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                             SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                }
#endif
                        /* if local unit or standalone
                         */

               for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                {
                    if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                        continue;
                    unit = SWDRV_IFINDEX_TO_UNIT(lport);
                    port = SWDRV_IFINDEX_TO_PORT(lport);

                    if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                    {

                        return FALSE;
                    }

                    SWDRV_OM_GetSystemInfoStackId(&stack_id);
                    if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                         && (port != SYS_ADPT_MGMT_PORT)
           #endif
                       )
                       continue;
                    else
                    {
                        if ( SWDRV_LocalDisablePortSecurity(unit, port)==FALSE)
                        {

                            return FALSE;
                        }
                    }
                }
              }

                return TRUE;
        }

    }

BOOL_T SWDRV_PortListSecurityActionNone(UI8_T *port_list)
{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_PORT_SECURITY_ACTION_NONE;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalPortSecurityActionNone(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_EnablePortListMulticastStormControl(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_ENABLE_MULTICAST_STORM_CONTROL;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalEnableMulticastStormControl(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}
BOOL_T SWDRV_DisablePortListMulticastStormControl(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_DISABLE_MULTICAST_STORM_CONTROL;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalDisableMulticastStormControl(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}
BOOL_T SWDRV_SetPortListMulticastStormControlThreshold(UI8_T *port_list,
                                               UI32_T threshold,
                                               UI32_T mode)
{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;

/* TODO: wakka: dont change parameter validity here, should remove it.
 */
#ifdef BROADCOM
              if (threshold > 0x3ffff) /* the limitation of Broadcom chip */
                 return FALSE;
#endif

                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_MULTICAST_STORM_CONTROL_THRESHOLD;
                            isc_buffer_p->storm_control_threshold   = threshold;
                            isc_buffer_p->storm_control_mode        = mode;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if (  SWDRV_LocalSetMulticastStormControlThreshold(unit, port, threshold, mode) == FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_EnablePortListBroadcastStormControl(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_ENABLE_BROADCAST_STORM_CONTROL;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalEnableBroadcastStormControl(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_DisablePortListBroadcastStormControl(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_DISABLE_BROADCAST_STORM_CONTROL;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalDisableBroadcastStormControl(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_SetPortListBroadcastStormControlThreshold(UI8_T *port_list,UI32_T threshold,
                                               UI32_T mode)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;

/* TODO: wakka: dont change parameter validity here, should remove it.
 */
#ifdef BROADCOM
                 if (threshold > 0x3ffff) /* the limitation of Broadcom chip */
                    return FALSE;
#endif

                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_BROADCAST_STORM_CONTROL_THRESHOLD;
                            isc_buffer_p->storm_control_threshold   = threshold;
                            isc_buffer_p->storm_control_mode        = mode;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {

                            if ( SWDRV_LocalSetBroadcastStormControlThreshold(unit, port, threshold, mode) == FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}


BOOL_T SWDRV_EnablePortListIngressRateLimit(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_ENABLE_PORT_INGRESS_RATE_LIMIT;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalEnablePortIngressRateLimit(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_DisablePortListIngressRateLimit(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_DISABLE_PORT_INGRESS_RATE_LIMIT;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalDisablePortIngressRateLimit(unit, port, 0)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_SetPortListIngressRateLimit(UI8_T *port_list, UI32_T rate)
{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_PORT_INGRESS_RATE_LIMIT;
                            isc_buffer_p->ratelimit = rate;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if (SWDRV_LocalSetPortIngressRateLimit(unit, port,rate) == FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_SetPortListEgressRateLimit(UI8_T *port_list,UI32_T rate)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_PORT_EGRESS_RATE_LIMIT;
                            isc_buffer_p->ratelimit = rate;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalSetPortEgressRateLimit(unit, port,rate)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_DisablePortListEgressRateLimit(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_DISABLE_PORT_EGRESS_RATE_LIMIT;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalDisablePortEgressRateLimit(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_EnablePortListEgressRateLimit(UI8_T *port_list)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_ENABLE_PORT_EGRESS_RATE_LIMIT;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalEnablePortEgressRateLimit(unit, port)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_SetPortListWrrQueueWeight(UI8_T *port_list, UI32_T q_id, UI32_T weight)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_PORT_WRR_QUEUE_WEIGHT;
                            isc_buffer_p->wrr_queue_id      = q_id;
                            isc_buffer_p->wrr_queue_weight  = weight;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalSetPortWrrQueueWeight(unit, port,q_id,weight)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

BOOL_T SWDRV_SetPortListEgressSchedulingMethod(UI8_T *port_list,UI32_T method)

{
#if (SYS_CPNT_STACKING == TRUE)
                    L_MM_Mref_Handle_T* mref_handle_p;
                    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
                    UI32_T              pdu_len;
                    UI16_T              unit_bmp=0;
#endif /*SYS_CPNT_STACKING*/
                    UI32_T              unit,port,lport;
                    UI32_T  max_port_number;
                    UI32_T  stack_id;


                    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
                    {

                         /* UIMSG_MGR_SetErrorCode() */
                        return FALSE;
                    }
                    else
                    {
                        /* if remote unit
                         */
#if (SYS_CPNT_STACKING == TRUE)
                        unit_bmp = SWDRV_GetValidDrvUnitBmp();
                        if (unit_bmp!=0)
                        {
                            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_LIST_INFO) /* user_id */);
                            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

                            if (isc_buffer_p==NULL)
                            {

                                return FALSE;
                            }
                                        /* create vlan id of remote all unit
                                        */
                            isc_buffer_p->ServiceID = SWDRV_SET_PORT_LIST_INFO;
                            isc_buffer_p->SubServiceID = SWDRV_SET_PORT_EGRESS_SCHEDULING_METHOD;
                            isc_buffer_p->egress_method = method;
                            memcpy(isc_buffer_p->portlist, port_list,SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
                            ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                                                 mref_handle_p,
                                                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE);

                    }
#endif
                            /* if local unit or standalone
                             */

                   for(lport = 0;lport < SYS_ADPT_TOTAL_NBR_OF_LPORT;lport++)
                    {
                        if(!SWDRV_IS_PORTLIST_MEMBER(port_list,lport+1))
                            continue;
                        unit = SWDRV_IFINDEX_TO_UNIT(lport);
                        port = SWDRV_IFINDEX_TO_PORT(lport);

                        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
                        {

                            return FALSE;
                        }

                        SWDRV_OM_GetSystemInfoStackId(&stack_id);
                        if ( ((stack_id != unit) || (port > max_port_number))
           #if (SYS_CPNT_MGMT_PORT == TRUE)
                             && (port != SYS_ADPT_MGMT_PORT)
           #endif
                           )
                           continue;
                        else
                        {
                            if ( SWDRV_LocalSetPortEgressSchedulingMethod(unit, port,method)==FALSE)
                            {

                                return FALSE;
                            }
                        }
                    }
                  }

                    return TRUE;
}

#endif




#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMDIXMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set mdix mode
 * INPUT   : unit           -- unit id
 *           port           -- which port to set
 *           mode     -- automode enable or disable(normal/cross_over)
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight              2L
 *                       - VAL_portMdixMode_crossover             3L
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMDIXMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit             ) ||
            (port > max_port_number))
   #if (SYS_CPNT_MGMT_PORT == TRUE)
                 && (port != SYS_ADPT_MGMT_PORT)
   #endif
              )
        {

            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PRIORITY_MAPPING) /* user_id */);
      isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                /* a port of remote unit
                 */
            isc_buffer_p->ServiceID = SWDRV_SET_MDIX_MODE ;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->MDIXMode = mode;


        if (port > max_port_number)
      {
          if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
          {
               unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
          }
          else
          {

              return FALSE;
          }
      }
      else
      {
           unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
      }

      if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                               mref_handle_p,
                               SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                               SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
      {

          return FALSE; /* can't control remote unit */
      }
        }

        else
        {
#endif
            /* if local unit or standalone
             */
            if (!SWDRV_LocalSetMDIXMode(unit, port, mode))
            {
                /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/

    }


    return TRUE;


}


static BOOL_T SWDRV_LocalSetMDIXMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    if (DEV_PMGR_SWDRV_SetMDIXMode(unit, port, mode) == TRUE)
    {
#if 0
        SWDRV_OM_SetPortMdix(port, mode);
#endif
        return TRUE;
    }
    return FALSE;
}


static void SlaveSetMDIXMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetMDIXMode(request_p->unit,request_p->port,request_p->MDIXMode);
}
#endif


#if (SYS_CPNT_MAC_VLAN == TRUE)

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMacVlanEntry
 * -------------------------------------------------------------------------
 * PURPOSE : This function sets MAC based VLAN
 * INPUT   : mac_address        -- MAC address
 *           vid                -- VLAN id
 *           priority           -- priority
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMacVlanEntry(UI8_T *mac_address, UI8_T *mask, UI16_T vid, UI8_T priority)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MAC_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable IPMC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_SET_MAC_VLAN;
            memcpy(isc_buffer_p->info.mac_vlan_entry.mac_addr, mac_address, SYS_ADPT_MAC_ADDR_LEN);
            memcpy(isc_buffer_p->info.mac_vlan_entry.mask, mask, SYS_ADPT_MAC_ADDR_LEN);
            isc_buffer_p->info.mac_vlan_entry.vid = vid;
            isc_buffer_p->info.mac_vlan_entry.priority = priority;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalSetMacVlanEntry(mac_address, mask, vid, priority))
        {

            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_DeleteMacVlanEntry
 * -------------------------------------------------------------------------
 * PURPOSE : This function deletes MAC based VLAN
 * INPUT   : mac_address        -- MAC address
 * OUTPUT  : none
 * RETURN  : TRUE               -- Success
 *           FALSE              -- Failed
 * NOTE    : none
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DeleteMacVlanEntry(UI8_T *mac_address, UI8_T *mask)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif


    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {

        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_DELETE_MAC_VLAN) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* enable IPMC of all unit
             */
            isc_buffer_p->ServiceID  = SWDRV_DELETE_MAC_VLAN;
            memcpy(isc_buffer_p->info.mac_vlan_entry.mac_addr, mac_address, SYS_ADPT_MAC_ADDR_LEN);
            memcpy(isc_buffer_p->info.mac_vlan_entry.mask, mask, SYS_ADPT_MAC_ADDR_LEN);

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif
         if(!SWDRV_LocalDeleteMacVlanEntry(mac_address, mask))
        {

            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}

#endif /* #if (SYS_CPNT_MAC_VLAN == TRUE) */

#if (SYS_CPNT_POWER_SAVE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortPowerSave
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port power-save status
 * INPUT   : unit --which unit
 *               port -- which port to set
 *               status--TRUE:enable
 *                           FALSE:disable
 * OUTPUT  :
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortPowerSave(UI32_T unit, UI32_T port,BOOL_T status)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T max_port_number;
        UI32_T stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (((stack_id != unit) || (port > max_port_number))
   #if (SYS_CPNT_MGMT_PORT == TRUE)
         && (port != SYS_ADPT_MGMT_PORT)
   #endif
        )
        {
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
            UI32_T              drv_unit;
    UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
    {
        return FALSE;
    }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_POWER_SAVE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            /* a port of remote unit
             */
            isc_buffer_p->ServiceID  = SWDRV_SET_PORT_POWER_SAVE;
            isc_buffer_p->info.port_power_saving.unit= unit;
            isc_buffer_p->info.port_power_saving.port= port;
            isc_buffer_p->info.port_power_saving.status= status;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
             */
         if(!SWDRV_LocalSetPortPowerSave(unit,port,status))
        {
                /* UIMSG_MGR_SetErrorCode() */
            return FALSE;
        }

        return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/

    }

    return TRUE;
}
#endif /* end of #if (SYS_CPNT_POWER_SAVE == TRUE) */

#if (SYS_CPNT_RSPAN == TRUE)
/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_LocalSetRspanVlanTag
 * -------------------------------------------------------------------------------------------
 * PURPOSE : Set VLAN for egressing mirrored packets on a port. ( local unit )
 * INPUT   : port    - mirror-to port to set (-1 for all ports)
 *           tpid    - tag protocol id (tpid and vid are equal 0, meaning to disable RSPAN)
 *           vlan    - virtual lan number (tpid and vid are equal 0, meaning to disable RSPAN)
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If the specified specific-port is not available, or
 *                                 the ASIC can not support port mirroring function
 * NOTE    : For now RSPAN doesn't support stacking.
 * -------------------------------------------------------------------------------------------
 */
static BOOL_T SWDRV_LocalSetRspanVlanTag (SYS_TYPE_Uport_T target_port, UI16_T tpid, UI16_T vlan)
{
    return DEV_SWDRV_PMGR_SetRspanVlanTag (target_port, tpid, vlan);
}

static BOOL_T SlaveSetRspanVlanTag(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    SYS_TYPE_Uport_T target_port;

    target_port.unit = request_p->unit;
    target_port.port = request_p->port;

    return SWDRV_LocalSetRspanVlanTag(
        target_port,
        request_p->info.u32_u32.u32_a1,
        request_p->info.u32_u32.u32_a2);
}

/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetRspanVlanTag
 * -------------------------------------------------------------------------------------------
 * PURPOSE : Set VLAN for egressing mirrored packets on a port. ( remote and local )
 * INPUT   : port    - mirror-to port to set (-1 for all ports)
 *           tpid    - tag protocol id (tpid and vid are equal 0, meaning to disable RSPAN)
 *           vlan    - virtual lan number (tpid and vid are equal 0, meaning to disable RSPAN)
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If the specified specific-port is not available, or
 *                                 the ASIC can not support port mirroring function
 * NOTE    : For now RSPAN doesn't support stacking.
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetRspanVlanTag (SYS_TYPE_Uport_T target_port, UI16_T tpid, UI16_T vlan)
{
    UI32_T unit, port;

    unit = target_port.unit;
    port = target_port.port;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_RSPAN_VLAN_TAG) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_RSPAN_VLAN_TAG;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.u32_u32.u32_a1 = tpid;
            isc_buffer_p->info.u32_u32.u32_a2 = vlan;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetRspanVlanTag(target_port, tpid, vlan))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalModifyMaxFrameSize (UI32_T port, BOOL_T is_increase)
{
    return DEV_SWDRV_PMGR_ModifyMaxFrameSize(port, is_increase);
}

static BOOL_T SlaveModifyMaxFrameSize(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalModifyMaxFrameSize(
        request_p->port,
        request_p->info.general_32_bits);
}

/* -------------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_ModifyMaxFrameSize
 * -------------------------------------------------------------------------------------------------
 * FUNCTION: This function will modify maximum fram size of RSPAN
 * INPUT   : port -- in which port
 *           is_increase -- TRUE:add RSPAN tag size (4 bytes)
 *                       -- FALSE:delete RSPAN tag size (4 bytes)
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : For now RSPAN doesn't support stacking.
 * ------------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_ModifyMaxFrameSize (UI32_T unit, UI32_T port, BOOL_T is_increase)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;
        UI16_T  unit_bmp = 0;

        if (unit == 0) /* set all unit */
        {
             unit_bmp = SWDRV_GetValidDrvUnitBmp();
        }
        else
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
            {
                return FALSE;
            }

            /* if remote unit
             */
            SWDRV_OM_GetSystemInfoStackId(&stack_id);
            if ( ((stack_id != unit) ||
                 (port > max_port_number))
               )
            {
                UI32_T  drv_unit;

                if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
                {
                    return FALSE;
                }

                if (port > max_port_number)
                {
                    if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                    {
                         unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                    }
                    else
                    {

                        return FALSE;
                    }
                }
                else
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
                }
            }
        }

        /* if remote unit
         */
        if (unit_bmp != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_MODIFY_MAX_FRAME_SIZE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_MODIFY_MAX_FRAME_SIZE;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.general_32_bits = is_increase;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }

        if (unit_bmp == 0 || unit == 0)
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalModifyMaxFrameSize(port, is_increase))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif /*#if (SYS_CPNT_RSPAN == TRUE)*/

#if (SYS_CPNT_SFLOW == TRUE)
/*******************
 * sFlow APIs *
 *******************/
 /* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnableSystemSflow
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable the system sFlow
 * INPUT   : enable-- TRUE:enable
 *                    FALSE:disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_EnableSystemSflow(BOOL_T enable)
{
    /*bcm do not have system status*/
    return TRUE;
} /* End of BOOL_T SWDRV_EnableSystemSflow () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_EnablePortSflow
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable specific port sFlow
 * INPUT   : port -- which port to enable/disable sFlow source
 *           enable-- TRUE:enable
 *                    FALSE:disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_LocalEnablePortSflow(UI32_T unit, UI32_T port, BOOL_T enable)
{
    if(DEV_SWDRVL4_PMGR_EnablePortSflow(unit, port, enable))
    {
        return TRUE;
    }

    return FALSE;

} /* End of BOOL_T SWDRV_EnablePortSflow () */

static BOOL_T SlaveEnablePortSflow(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortSflow( request_p->unit,  request_p->port,  request_p->sflow_cfg_enable );
}

BOOL_T SWDRV_EnablePortSflow(UI32_T unit, UI32_T port, BOOL_T enable)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
        */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit)||(port > max_port_number))
            #if (SYS_CPNT_MGMT_PORT == TRUE)
                && (port != SYS_ADPT_MGMT_PORT)
            #endif
        )
        {

            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;
            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_SFLOW) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
            /* a port of remote unit
            */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_SFLOW ;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->sflow_cfg_enable = enable;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                    unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                               mref_handle_p,
                               SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                               SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
        {
#endif
            /* if local unit or standalone
            */
            if (!SWDRV_LocalEnablePortSflow(unit, port, enable))
            {
                /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/

    }

    return TRUE;


}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortSflowRate
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set specific port  sFlow rate
 * INPUT   : port -- which port to set sFlow rate
 *           rate--sFlow rate
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_LocalSetPortSflowRate(UI32_T unit, UI32_T port, UI32_T rate)
{
    if(DEV_SWDRVL4_PMGR_SetPortSflowRate(unit, port, rate))
    {
        return TRUE;
    }

    return FALSE;

} /* End of BOOL_T SWDRV_SetPortSflowRate () */

static BOOL_T SlaveSetPortSflowRate(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortSflowRate( request_p->unit,  request_p->port,  request_p->sflow_cfg_rate );
}

BOOL_T SWDRV_SetPortSflowRate(UI32_T unit, UI32_T port, UI32_T rate)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }
    else
    {
        /* if remote unit
         */
#if (SYS_CPNT_STACKING == TRUE)

        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {

            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit             ) ||
            (port > max_port_number))
   #if (SYS_CPNT_MGMT_PORT == TRUE)
                 && (port != SYS_ADPT_MGMT_PORT)
   #endif
              )
        {

            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ((FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_SFLOW_RATE) /* user_id */);
      isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }
                /* a port of remote unit
                 */
            isc_buffer_p->ServiceID = SWDRV_SET_PORT_SFLOW_RATE ;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->sflow_cfg_rate = rate;


        if (port > max_port_number)
      {
          if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
          {
               unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
          }
          else
          {

              return FALSE;
          }
      }
      else
      {
           unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
      }

      if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                               mref_handle_p,
                               SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                               SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
      {

          return FALSE; /* can't control remote unit */
      }
        }

        else
        {
#endif
            /* if local unit or standalone
             */
            if (!SWDRV_LocalSetPortSflowRate(unit, port, rate))
            {
                /* UIMSG_MGR_SetErrorCode() */
                return FALSE;
            }
            return TRUE;
#if (SYS_CPNT_STACKING == TRUE)
        }
#endif /*SYS_CPNT_STACKING*/

    }


    return TRUE;


}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetSflowSampleCount
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the sFlow sample count
 * INPUT   : port --sflow source
 * OUTPUT  : count--sFlow sample counter
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetSflowSampleCount(UI32_T unit, UI32_T port,UI32_T *count)
{
        return TRUE;
} /* End of BOOL_T SWDRV_GetSflowSampleCount () */

static void SWDRV_BackDoor_Enable_Sflow()
{
    UI32_T  unit;
    UI32_T  port;
    UI32_T  enable;
    UI8_T   ch;
    char    inputStr[32];


    BACKDOOR_MGR_Printf("\n");
    BACKDOOR_MGR_Printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    BACKDOOR_MGR_Printf("         Enable Port sFlow         \n");
    BACKDOOR_MGR_Printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    BACKDOOR_MGR_Printf("\nWhich unit you address [1]:");
    BACKDOOR_MGR_RequestKeyIn(inputStr, 1);
    unit = atoi(inputStr);
    BACKDOOR_MGR_Printf("\r\n");
    BACKDOOR_MGR_Printf("\nPlease input port num [1-24]: ");
    BACKDOOR_MGR_RequestKeyIn(inputStr, 31);
    BACKDOOR_MGR_Printf("\r\n");
    port = atoi(inputStr);

    if (port > 24)
    {
        BACKDOOR_MGR_Printf("Port too large. Do nothing!\n");
        return;
    }

    BACKDOOR_MGR_Printf("\nStatus[0(disable)/1(enable)]:");

    BACKDOOR_MGR_RequestKeyIn(inputStr, 1);
    enable = atoi(inputStr);
    BACKDOOR_MGR_Printf("\r\n");

    if (SWDRV_EnablePortSflow(unit, port, enable))
    {
        BACKDOOR_MGR_Printf("Unit %lu Port %lu %s Success\n", (unsigned long)unit, (unsigned long)port, (enable == 0)? "disable":"enable");
    }
    else
    {
        BACKDOOR_MGR_Printf("!!!Fail!!!\n");
    }
    return;
}

static void SWDRV_BackDoor_Set_Sflow_Rate()
{
    UI32_T  unit;
    UI32_T  port;
    UI32_T  rate;
    UI8_T   ch;
    char    inputStr[32];


    printf("\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("       Setup Port sFlow Rate        \n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    BACKDOOR_MGR_Printf("\nWhich unit you address [1]:");
    BACKDOOR_MGR_RequestKeyIn(inputStr, 1);
    unit = atoi(inputStr);
    BACKDOOR_MGR_Printf("\r\n");
    BACKDOOR_MGR_Printf("\nPlease input port num [1-24]: ");
    BACKDOOR_MGR_RequestKeyIn(inputStr, 31);
    BACKDOOR_MGR_Printf("\r\n");
    port = atoi(inputStr);

    if (port > 24)
    {
        printf("Port too large. Do nothing!\n");
        return;
    }

    BACKDOOR_MGR_Printf("\nPlease input rate (0, %lu - %lu): ",
        (unsigned long)SYS_ADPT_SFLOW_MIN_SAMPLING_RATE, (unsigned long)SYS_ADPT_SFLOW_MAX_SAMPLING_RATE);
    BACKDOOR_MGR_RequestKeyIn(inputStr, 31);
    rate = atoi(inputStr);

    if (SWDRV_SetPortSflowRate(unit, port, rate))
    {
        printf("\nSWDRV_SetPortSflowRate(): Success, Unit = %lu, Port = %lu, Rate = %lu\n", (unsigned long)unit, (unsigned long)port, (unsigned long)rate);
    }
    else
    {
        printf("\nSWDRV_SetPortSflowRate(): Fail!!!, Unit = %lu, Port = %lu, Rate = %lu\n", (unsigned long)unit, (unsigned long)port, (unsigned long)rate);
    }
    return;
}
#endif/*#if (SYS_CPNT_SFLOW == TRUE)*/

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
static BOOL_T SWDRV_SlaveDropIpv6MulticastData(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return RULE_CTRL_IPV6_DenyMulticastData(request_p->info.u32_u32_b.bool_a1, request_p->info.u32_u32_b.u32_a1, request_p->info.u32_u32_b.u32_a2);
}

static BOOL_T SWDRV_LocalDropIpv6MulticastData(UI32_T unit, UI32_T port, BOOL_T enabled)
{
    return RULE_CTRL_IPV6_DenyMulticastData(enabled, unit, port);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DropIpv6MulticastData
 * -------------------------------------------------------------------------
 * PURPOSE : This function will enable/disable ip multicast data drop
 *            for specified unit and port
 * INPUT   : unit      -- which unit.
 *           port      -- which port.
 *           enabled -- enable/disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_DropIpv6MulticastData(UI32_T unit, UI32_T port, BOOL_T enabled)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }
    else
    {
         if(!SWDRV_LocalDropIpv6MulticastData(unit, port, enabled))
        {

            return FALSE;
        }

        return TRUE;
    }

    return TRUE;

}
#endif

#if (SYS_CPNT_PPPOE_IA == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPPPoEDPktToCpu
 * -------------------------------------------------------------------------
 * PURPOSE: This function will enable/disable traping
 *          PPPoE discover packets to cpu for specified unit/port.
 * INPUT  : unit      - unit to enable/disable
 *          port      - port to enable/disable
 *          is_enable - enable or disable the feature.
 * OUTPUT : None
 * RETURN : True: Successfully, False: Failed.
 * NOTE    : 1. for projects who can install rule on trunk's member ports.
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetPPPoEDPktToCpu(
    UI32_T  unit,
    UI32_T  port,
    BOOL_T  is_enable)
{
    BOOL_T  ret = FALSE;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    /* redirect to rule_ctrl, rule_ctrl will do the isc work by itself.
     *
     * currently it's done by set fp rule only...
     */
    ret = RULE_CTRL_SetPPPoEDPktToCpu(unit, port, is_enable);
    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPPPoEDPktToCpuPerSystem
 * -------------------------------------------------------------------------
 * PURPOSE: This function will enable/disable traping
 *          PPPoE discover packets to cpu for entire system.
 * INPUT  : is_enable - enable or disable the feature.
 * OUTPUT : None
 * RETURN : True: Successfully, False: Failed.
 * NOTE   : 1. for projects who encounter problems to install rule on
 *             trunk's member ports.
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetPPPoEDPktToCpuPerSystem(
    BOOL_T  is_enable)
{
    BOOL_T  ret = FALSE;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    /* redirect to rule_ctrl, rule_ctrl will do the isc work by itself.
     *
     * currently it's done by set fp rule only...
     */
    ret = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
    return ret;
}

#endif /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

#if (SYS_CPNT_DOS == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDosProtectionFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           enable - TRUE to enable; FALSE to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDosProtectionFilter(UI32_T type, BOOL_T enable)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    if (FALSE
        #if (SYS_CPNT_DOS_SMURF_IMPLEMENTED_BY_RULE == TRUE)
        || type == SWDRV_DOS_FILTER_SMURF
        #endif
        )
    {
        if (!RULE_CTRL_SetDosProtectionFilter(type, enable))
        {
            return FALSE;
        }
    }
    else
    {
        /* if stacking
         */
#if (SYS_CPNT_STACKING == TRUE)
        unit_bmp = SWDRV_GetValidDrvUnitBmp();
        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_DOS_PROTECTION_FILTER) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID  = SWDRV_SET_DOS_PROTECTION_FILTER;
            isc_buffer_p->info.u32_u32.u32_a1 = type;
            isc_buffer_p->info.u32_u32.u32_a2 = enable;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /*SYS_CPNT_STACKING*/

        if(!SWDRV_LocalSetDosProtectionFilter(type, enable))
        {

            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SlaveSetDosProtectionFilter(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetDosProtectionFilter(request_p->info.u32_u32.u32_a1, request_p->info.u32_u32.u32_a2);
}

static BOOL_T SWDRV_LocalSetDosProtectionFilter(UI32_T type, BOOL_T enable)
{
    return DEV_SWDRVL4_PMGR_SetDosProtectionFilter(type, enable);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDosProtectionRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           rate   - rate in kbps. 0 to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetDosProtectionRateLimit(UI32_T type, UI32_T rate)
{
    BOOL_T ret;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    ret = RULE_CTRL_SetDosProtectionRateLimit(type, rate);

    return ret;
}
#endif /* (SYS_CPNT_DOS == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPktTrapStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : unit      - 0 for all unit
 *           port      - 0 for all port
 *           pkt_type  - which packet to trap
 *           to_cpu    - trap to cpu or not
 *           drop      - drop packet or not
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPktTrapStatus(UI32_T unit, UI32_T port, UI32_T pkt_type, BOOL_T to_cpu, BOOL_T drop)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* implemented by rule
     */
    {
        RULE_TYPE_PacketType_T packet_type[RULE_TYPE_PacketType_MAX];
        RULE_TYPE_CpuRuleInfo_T rule_info;
        int packet_type_num, i;
        BOOL_T enabled;

        enabled = (to_cpu || drop);
        packet_type_num = 0;

        switch (pkt_type)
        {
#if (SYS_CPNT_SWDRV_TRAP_IGMP_BY_RULE == TRUE)
            case SWDRV_PKTTYPE_IGMP:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_IGMP;
                enabled = TRUE;
                break;
#endif
#if (SYS_CPNT_SWDRV_TRAP_MLD_BY_RULE && (SYS_CPNT_MLDSNP))
            case SWDRV_PKTTYPE_MLD:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_MLD_Query;
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_MLD_Report;
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_MLD_Done;
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_MLDV2_Reports;
                enabled = (to_cpu && drop) ? TRUE : FALSE;
                break;
#endif
#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE == TRUE)
            case SWDRV_PKTTYPE_IPMC:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_UNKNOWN_IPMC;
                break;
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE == TRUE)
            case SWDRV_PKTTYPE_IPMC6:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_UNKNOWN_IPV6MC;
                break;
#endif
#endif
            case SWDRV_PKTTYPE_DHCP_SERVER:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_DHCP_SERVER;
                break;
            case SWDRV_PKTTYPE_DHCP_CLIENT:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_DHCP_CLIENT;
                break;
            case SWDRV_PKTTYPE_DHCP6_SERVER:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_DHCP6_SERVER;
                break;
            case SWDRV_PKTTYPE_DHCP6_CLIENT:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_DHCP6_CLIENT;
                break;
            case SWDRV_PKTTYPE_ORG_SPECIFIC:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_ORG_SPECIFIC;
                break;
            case SWDRV_PKTTYPE_ORG_SPECIFIC1:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_ORG_SPECIFIC1;
                break;
            case SWDRV_PKTTYPE_ORG_SPECIFIC3:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_ORG_SPECIFIC3;
                break;
            case SWDRV_PKTTYPE_CDP:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_CDP;
                break;
            case SWDRV_PKTTYPE_PVST:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_PVST;
                break;
#if (SYS_CPNT_MLDSNP == TRUE)
            case SWDRV_PKTTYPE_PIM6:
                packet_type[packet_type_num ++] = RULE_TYPE_PacketType_PIM6;
                break;
#endif
        }

        for (i = 0; i < packet_type_num; i ++)
        {
            if (packet_type[i] < RULE_TYPE_PacketType_MAX)
            {
                memset(&rule_info, 0, sizeof(rule_info));
                rule_info.common.to_cpu = to_cpu;
                rule_info.common.flood = !drop;

                if (unit == 0)
                {
                    return RULE_CTRL_TrapPacket2Cpu(enabled, packet_type[i], &rule_info);
                }
                else
                {
                    /* not implemented
                     * just workaround for it
                     */
                    if (unit == 1 && port == 1)
                    {
                        return RULE_CTRL_TrapPacket2Cpu(enabled, packet_type[i], &rule_info);
                    }
                    else
                    {
                        return TRUE;
                    }
                }
            }
        }
    }

    {
#if (SYS_CPNT_STACKING == TRUE)

        if (!SWDRV_GetValidDrvUnitBmpByUnitPort(unit, port, &unit_bmp))
        {
            return FALSE;
        }

        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PKT_TRAP_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID  = SWDRV_SET_PKT_TRAP_STATUS;
            isc_buffer_p->port = port;
            isc_buffer_p->info.packet_trap_info.pkt_type = pkt_type;
            isc_buffer_p->info.packet_trap_info.to_cpu = to_cpu;
            isc_buffer_p->info.packet_trap_info.flood = !drop;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

        if (unit_bmp == 0 || unit == 0)
#endif /*SYS_CPNT_STACKING*/
        {
            if(!SWDRV_LocalSetPktTrapStatus(port, pkt_type, to_cpu, drop))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL_T SlaveSetPktTrapStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPktTrapStatus(
        request_p->port,
        request_p->info.packet_trap_info.pkt_type,
        request_p->info.packet_trap_info.to_cpu,
        !request_p->info.packet_trap_info.flood);
}

static BOOL_T SWDRV_LocalSetPktTrapStatus(UI32_T port, UI32_T pkt_type, BOOL_T to_cpu, BOOL_T drop)
{
    UI32_T unit;
    BOOL_T ret;

    SWDRV_OM_GetSystemInfoStackId(&unit);

    switch (pkt_type)
    {
#if (SYS_CPNT_SWDRV_TRAP_IGMP_BY_RULE != TRUE)
        case SWDRV_PKTTYPE_IGMP:
            ret = DEV_SWDRV_PMGR_TrapIGMPToCPU(to_cpu, drop);
            break;
#endif
#if (SYS_CPNT_SWDRV_TRAP_MLD_BY_RULE != TRUE && (SYS_CPNT_MLDSNP))
        case SWDRV_PKTTYPE_MLD:
            ret = DEV_SWDRV_PMGR_TrapMLDToCPU(to_cpu, drop);
            break;
#endif

#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE != TRUE)
        case SWDRV_PKTTYPE_IPMC:
            ret = DEV_SWDRV_PMGR_TrapUnknownIpMcastToCPU(to_cpu, !drop, 0);
            break;
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
#if (SYS_CPNT_SWDRV_TRAP_UNKNOWN_IPMC_BY_RULE != TRUE)
        case SWDRV_PKTTYPE_IPMC6:
            ret = DEV_SWDRV_PMGR_TrapUnknownIpv6McastToCPU(to_cpu, !drop, 0);
            break;
#endif
#endif
#if (SYS_CPNT_NDSNP == TRUE)
        case SWDRV_PKTTYPE_ND:
#if (SYS_CPNT_ND_BY_RULE == TRUE)
            {
                BOOL_T enable = FALSE;
                if(to_cpu&&drop)
                    enable = TRUE;

                ret = RULE_CTRL_IP6_SetNdNaPacketToCpu(enable);
                ret |= RULE_CTRL_IP6_SetNdNsPacketToCpu(enable);
                ret |= RULE_CTRL_IP6_SetNdRsPacketToCpu(enable);
                ret |= RULE_CTRL_IP6_SetNdRaPacketToCpu(enable);
                ret |= RULE_CTRL_IP6_SetNdRedirectPacketToCpu(enable);

            }
#else
            ret = DEV_SWDRV_PMGR_TrapNDToCPU(to_cpu, drop);
#endif
            break;
#endif

        case SWDRV_PKTTYPE_INTRUDER:
            ret = DEV_SWDRV_PMGR_SetPortLearningStatus(unit, port, FALSE, to_cpu, drop);
            break;

        default:
            ret = FALSE;
    }

    return ret;
}

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPSECheckStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set PSE check status
 * INPUT   : pse_check_status  --  PSE check status
 * OUTPUT  : None
 * RETURN  : TRUE:Success, FALSE:Failed
 * NOTE    : When PSE check status is enabled, all of the ports with POE PD
 *           capability are able to link up when the link partner is a PSE port.
 *           When PSE check status is disabled, all of the ports with POE PD
 *           capability will not be blocked by SWDRV to link up. However, if
 *           upper layer CSC shutdown the port, the port is never link up.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPSECheckStatus(BOOL_T pse_check_status)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if stacking
     */
#if (SYS_CPNT_STACKING == TRUE)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    if (unit_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PSE_CHECK_STATUS) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {

            return FALSE;
        }

        isc_buffer_p->ServiceID  = SWDRV_SET_PSE_CHECK_STATUS;
        isc_buffer_p->info.general_32_bits = pse_check_status;
        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
    }
#endif /*SYS_CPNT_STACKING*/

    if(!SWDRV_LocalSetPSECheckStatus(pse_check_status))
    {

        return FALSE;
    }

    return TRUE;
}

static BOOL_T SlaveSetPSECheckStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPSECheckStatus((BOOL_T)(request_p->info.general_32_bits));
}

static BOOL_T SWDRV_LocalSetPSECheckStatus(BOOL_T pse_check_status)
{
    SWDRV_OM_SetPSECheckStatus(pse_check_status);
    return TRUE;
}

#endif /* end of #if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE)) */

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_SlaveSetPortMacAddr(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortMacAddr(
        request_p->unit,
        request_p->port,
        request_p->cpu_mac_addr);
}
#endif

static BOOL_T SWDRV_LocalSetPortMacAddr(UI32_T unit, UI32_T port, UI8_T *mac_addr)
{
    return DEV_SWDRV_PMGR_SetPortMacAddr(unit, port, mac_addr);
}

/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortMacAddr
 * -------------------------------------------------------------------------------------------
 * PURPOSE : This function configure source MAC address of chip port.
 * INPUT   : unit
 *           port
 *           mac_addr
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetPortMacAddr(UI32_T unit, UI32_T port, UI8_T *mac_addr)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_MAC_ADDR) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_MAC_ADDR;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            memcpy(isc_buffer_p->cpu_mac_addr, mac_addr, sizeof(isc_buffer_p->cpu_mac_addr));

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortMacAddr(unit, port, mac_addr))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#if (SYS_CPNT_PFC == TRUE)
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_SlaveSetPortPfcStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortPfcStatus(
        request_p->unit,
        request_p->port,
        (BOOL_T)request_p->info.u32_u32_u32.u32_a1,
        (BOOL_T)request_p->info.u32_u32_u32.u32_a2,
        (UI16_T)request_p->info.u32_u32_u32.u32_a3);
}
#endif

static BOOL_T SWDRV_LocalSetPortPfcStatus(UI32_T unit, UI32_T port, BOOL_T rx_en, BOOL_T tx_en, UI16_T pri_en_vec)
{
    return DEV_SWDRV_PMGR_SetPortPfcStatus(unit, port, rx_en, tx_en, pri_en_vec);
}

/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortPfcStatus
 * -------------------------------------------------------------------------------------------
 * PURPOSE : This function configure PFC status.
 * INPUT   : unit
 *           port
 *           rx_en      -- enable/disable PFC response
 *           tx_en      -- enable/disable PFC triggering
 *           pri_en_vec -- bitmap of enable status per priority
 *                         set bit to enable PFC; clear to disable.
 * OUTPUT  : None
 * RETURN  : TRUE  --  get next succuess
             FALSE --  don't exist the next chip id
 * NOTE    : None
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetPortPfcStatus(UI32_T unit, UI32_T port, BOOL_T rx_en, BOOL_T tx_en, UI16_T pri_en_vec)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_PFC_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_PFC_STATUS;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.u32_u32_u32.u32_a1 = rx_en;
            isc_buffer_p->info.u32_u32_u32.u32_a2 = tx_en;
            isc_buffer_p->info.u32_u32_u32.u32_a3 = pri_en_vec;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortPfcStatus(unit, port, rx_en, tx_en, pri_en_vec))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_SlaveUpdatePfcPriMap(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalUpdatePfcPriMap();
}
#endif

static BOOL_T SWDRV_LocalUpdatePfcPriMap(void)
{
    return DEV_SWDRV_PMGR_UpdatePfcPriMap();
}

/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_UpdatePfcPriMap
 * -------------------------------------------------------------------------------------------
 * PURPOSE : This function update PFC priority to queue mapping.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWDRV_UpdatePfcPriMap(void)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_STACKING == TRUE)
    {
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI16_T              unit_bmp=0;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_UPDATE_PFC_PRI_MAP) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID  = SWDRV_UPDATE_PFC_PRI_MAP;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
    }
#endif /*SYS_CPNT_STACKING*/

    if(!SWDRV_LocalUpdatePfcPriMap())
    {
        return FALSE;
    }

    return TRUE;
}
#endif /* (SYS_CPNT_PFC == TRUE) */

#if (SYS_CPNT_ETS == TRUE)
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_SlaveSetPortCosGroupMapping(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortCosGroupMapping(
        request_p->unit,
        request_p->port,
        (request_p->info.cos_group_mapping.cosq2group_is_valid ?
            request_p->info.cos_group_mapping.cosq2group : NULL));
}

static BOOL_T SWDRV_SlaveSetPortCosGroupSchedulingMethod(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortCosGroupSchedulingMethod(
        request_p->unit,
        request_p->port,
        request_p->info.cos_group_scheduling.method,
        (request_p->info.cos_group_scheduling.weights_is_valid ?
            request_p->info.cos_group_scheduling.weights : NULL));
}
#endif

static BOOL_T SWDRV_LocalSetPortCosGroupMapping(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq2group[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE])
{
    return DEV_SWDRVL4_PMGR_SetPortCosGroupMapping(unit, port, cosq2group);
}

static BOOL_T SWDRV_LocalSetPortCosGroupSchedulingMethod(
    UI32_T unit,
    UI32_T port,
    UI32_T method,
    UI32_T weights[SYS_ADPT_ETS_MAX_NBR_OF_TRAFFIC_CLASS])
{
    return DEV_SWDRVL4_PMGR_SetPortCosGroupSchedulingMethod(unit, port, method, weights);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortCosGroupMapping
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets mapping between CoS Queue and CoS group
 * INPUT   : unit
 *           port
 *           cosq2group -- array of cos groups.
 *                         element 0 is cos group of cosq 0,
 *                         element 1 is cos group of cosq 1, ...
 *                         NULL to map all cos to single cos group
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortCosGroupMapping(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq2group[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE])
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_COS_GROUP_MAPPING) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_COS_GROUP_MAPPING;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;

            if (cosq2group)
            {
                memcpy(isc_buffer_p->info.cos_group_mapping.cosq2group, cosq2group, sizeof(isc_buffer_p->info.cos_group_mapping.cosq2group));
                isc_buffer_p->info.cos_group_mapping.cosq2group_is_valid = TRUE;
            }
            else
            {
                isc_buffer_p->info.cos_group_mapping.cosq2group_is_valid = FALSE;
            }

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortCosGroupMapping(unit, port, cosq2group))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortCosGroupSchedulingMethod
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets scheduling method for CoS groups
 * INPUT   : unit
 *           port
 *           method  -- DEV_SWDRVL4_EgressSchedulingMethod_T
 *           weights -- weights for cos groups.
 *                      NULL if method is STRICT
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortCosGroupSchedulingMethod(
    UI32_T unit,
    UI32_T port,
    UI32_T method,
    UI32_T weights[SYS_ADPT_ETS_MAX_NBR_OF_TRAFFIC_CLASS])
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_COS_GROUP_SCHEDULING_METHOD) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_COS_GROUP_SCHEDULING_METHOD;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.cos_group_scheduling.method = method;

            if (weights)
            {
                memcpy(isc_buffer_p->info.cos_group_scheduling.weights, weights, sizeof(isc_buffer_p->info.cos_group_scheduling.weights));
                isc_buffer_p->info.cos_group_scheduling.weights_is_valid = TRUE;
            }
            else
            {
                isc_buffer_p->info.cos_group_scheduling.weights_is_valid = FALSE;
            }

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortCosGroupSchedulingMethod(unit, port, method, weights))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif /* (SYS_CPNT_ETS == TRUE) */

#if (SYS_CPNT_CN == TRUE)
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SWDRV_SlaveSetQcnCnmPriority(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetQcnCnmPriority(request_p->info.general_32_bits);
}

static BOOL_T SWDRV_SlaveSetPortQcnCpq(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortQcnCpq(
        request_p->unit,
        request_p->port,
        request_p->info.u32_u32.u32_a1,
        request_p->info.u32_u32.u32_a2);
}

static BOOL_T SWDRV_SlaveSetPortQcnEgrCnTagRemoval(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortQcnEgrCnTagRemoval(
        request_p->unit,
        request_p->port,
        request_p->info.general_32_bits & 0xff);
}

static BOOL_T SWDRV_SlaveGetPortQcnCpid(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_QCN_CPID) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortQcnCpid(
        request_p->unit,
        request_p->port,
        request_p->info.general_32_bits,
        isc_reply_p->data.port_qcn_cpid);

    return ISC_RemoteReply(mref_handle_p, key);
}
#endif

static BOOL_T SWDRV_LocalSetQcnCnmPriority(UI32_T pri)
{
    return DEV_SWDRVL4_PMGR_SetQcnCnmPriority(pri);
}

static BOOL_T SWDRV_LocalSetPortQcnCpq(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI32_T cpq)
{
    return DEV_SWDRVL4_PMGR_SetPortQcnCpq(unit, port, cosq, cpq);
}

static BOOL_T SWDRV_LocalSetPortQcnEgrCnTagRemoval(
    UI32_T unit,
    UI32_T port,
    UI8_T no_cntag_bitmap)
{
    return DEV_SWDRVL4_PMGR_SetPortQcnEgrCnTagRemoval(unit, port, no_cntag_bitmap);
}

static BOOL_T SWDRV_LocalGetPortQcnCpid(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI8_T cpid[8])
{
    return DEV_SWDRVL4_PMGR_GetPortQcnCpid(unit, port, cosq, cpid);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetQcnCnmPriority
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets 802.1p priority of egress QCN CNM
 * INPUT   : pri -- 802.1p priority of egress QCN CNM
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_SetQcnCnmPriority(UI32_T pri)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T  unit_bmp = 0;

        if (!SWDRV_GetValidDrvUnitBmpByUnitPort(0, 0, &unit_bmp))
        {
            return FALSE;
        }

        /* if remote unit
         */
        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_QCN_CNM_PRIORITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_QCN_CNM_PRIORITY;
            isc_buffer_p->info.general_32_bits = pri;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetQcnCnmPriority(pri))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortQcnCpq
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets CP Queue of the CoS Queue
 * INPUT   : unit
 *           port
 *           cosq -- CoS Queue
 *           cpq  -- CP Queue. 0xffffffff means to disable QCN
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortQcnCpq(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI32_T cpq)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_QCN_CPQ) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_QCN_CPQ;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.u32_u32.u32_a1 = cosq;
            isc_buffer_p->info.u32_u32.u32_a2 = cpq;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortQcnCpq(unit, port, cosq, cpq))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortQcnEgrCnTagRemoval
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets removal of CN-Tag of egress pkts
 * INPUT   : unit
 *           port
 *           no_cntag_bitmap - bit 0 for pri 0, and so on.
 *                             set the bit to remove CN-tag of packets with the pri.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortQcnEgrCnTagRemoval(
    UI32_T unit,
    UI32_T port,
    UI8_T no_cntag_bitmap)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_QCN_EGR_CNTAG_REMOVAL) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_QCN_EGR_CNTAG_REMOVAL;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.general_32_bits = no_cntag_bitmap;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalSetPortQcnEgrCnTagRemoval(unit, port, no_cntag_bitmap))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortQcnCpid
 *------------------------------------------------------------------------------
 * FUNCTION: This function gets CPID
 * INPUT   : unit
 *           port
 *           cosq -- CoS Queue
 *           cpid -- CPID
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortQcnCpid(
    UI32_T unit,
    UI32_T port,
    UI32_T cosq,
    UI8_T cpid[8])
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        /* if remote unit
         */
        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp=0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {

                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_QCN_CPID) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_GET_PORT_QCN_CPID;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.general_32_bits = cosq;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {

                    return FALSE;
                }
            }
            else
            {
                 unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE; /* can't control remote unit */
            }

            if (!isc_reply.return_value.bool)
            {
                return FALSE;
            }

            memcpy(cpid, isc_reply.data.port_qcn_cpid, sizeof(isc_reply.data.port_qcn_cpid));
        }
        else
#endif /* (SYS_CPNT_STACKING == TRUE) */
        {
            if (!SWDRV_LocalGetPortQcnCpid(unit, port, cosq, cpid))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif /* (SYS_CPNT_CN == TRUE) */

#if (SYS_CPNT_MAC_IN_MAC == TRUE)
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetMimService(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetMimService(
        &request_p->info.mim_service.mim,
        request_p->info.mim_service.is_valid);
}

static BOOL_T SlaveSetMimServicePort(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MIM_SERVICE_PORT) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalSetMimServicePort(
        &request_p->info.mim_service_port.mim_port,
        request_p->info.mim_service_port.is_valid);

    if (isc_reply_p->return_value.bool)
    {
        isc_reply_p->data.u32 = request_p->info.mim_service_port.mim_port.hw_idx;
    }

    return ISC_RemoteReply(mref_handle_p, key);
}
#endif

static BOOL_T SWDRV_LocalSetMimService(SWDRV_MimServiceInfo_T *mim_p, BOOL_T is_valid)
{
    /* NOTE:
     *   should make sure definition of SWDRV_MimServiceInfo_T is the same with
     *   DEV_SWDRV_MimServiceInfo_T
     */
    assert(sizeof(*mim_p) == sizeof(DEV_SWDRV_MimServiceInfo_T));

    return DEV_SWDRV_PMGR_SetMimService((DEV_SWDRV_MimServiceInfo_T *)mim_p, is_valid);
}

static BOOL_T SWDRV_LocalSetMimServicePort(SWDRV_MimPortInfo_T *mim_port_p, BOOL_T is_valid)
{
    /* NOTE:
     *   should make sure definition of SWDRV_MimPortInfo_T is the same with
     *   DEV_SWDRV_MimPortInfo_T
     */
    assert(sizeof(*mim_port_p) == sizeof(DEV_SWDRV_MimPortInfo_T));

    return DEV_SWDRV_PMGR_SetMimServicePort((DEV_SWDRV_MimPortInfo_T *)mim_port_p, is_valid);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMimService
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create/destroy a MiM service instance.
 * INPUT   : mim_p            -- MiM service instance info.
 *           is_valid         -- TRUE to create/update; FALSE to destroy.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMimService(SWDRV_MimServiceInfo_T *mim_p, BOOL_T is_valid)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MIM_SERVICE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_MIM_SERVICE;
            isc_buffer_p->info.mim_service.mim = *mim_p;
            isc_buffer_p->info.mim_service.is_valid = is_valid;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

#endif /* (SYS_CPNT_STACKING == TRUE) */
        if (!SWDRV_LocalSetMimService(mim_p, is_valid))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetMimServicePort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add/delete member port to a MiM service instance.
 * INPUT   : mim_port_p       -- MiM port info.
 *           is_valid         -- TRUE to add; FALSE to delete.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetMimServicePort(SWDRV_MimPortInfo_T *mim_port_p, BOOL_T is_valid)
{
    UI32_T unit = mim_port_p->unit;
    UI32_T port = mim_port_p->port;
    BOOL_T del_by_hw_idx = !is_valid && mim_port_p->port_type == SWDRV_MIM_PORT_TYPE_HWIDX;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
        UI32_T  drv_unit = 0;
        UI16_T  unit_bmp = 0;

#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (del_by_hw_idx)
        {
            unit_bmp = SWDRV_GetValidDrvUnitBmp();
        }
        else
        {
            if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
            {
                return FALSE;
            }

            SWDRV_OM_GetSystemInfoStackId(&stack_id);

            if ( ((stack_id != unit) ||
                 (port > max_port_number))
               )
            {
                if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
                {
                    return FALSE;
                }

                if (port > max_port_number)
                {
                    if (!STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
                    {
                        return FALSE;
                    }
                }
                else
                {
                     drv_unit = unit;
                }
            }
        }

        /* if remote unit
         */
        if (unit_bmp != 0 || drv_unit != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MIM_SERVICE_PORT) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_MIM_SERVICE_PORT;
            isc_buffer_p->info.mim_service_port.mim_port = *mim_port_p;
            isc_buffer_p->info.mim_service_port.is_valid = is_valid;

            if (unit_bmp != 0)
            {
                if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                         mref_handle_p,
                                         SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                         SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
                {
                    return FALSE; /* can't control remote unit */
                }
            }
            else
            {
                if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                                    SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                    sizeof(isc_reply), (UI8_T *)&isc_reply,
                                    SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
                {
                    return FALSE;
                }
            }

            if (!isc_reply.return_value.bool)
            {
                return FALSE;
            }

            mim_port_p->hw_idx = isc_reply.data.u32;
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */

        if (unit_bmp != 0 || drv_unit == 0)
        {
            if (!SWDRV_LocalSetMimServicePort(mim_port_p, is_valid))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#if (SYS_CPNT_IAAS == TRUE)
#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetMimServicePortLearningStatusForStationMove(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetMimServicePortLearningStatusForStationMove(
        request_p->info.u32_u32_u32.u32_a1,
        request_p->info.u32_u32_u32.u32_a2,
        request_p->info.u32_u32_u32.u32_a3);
}
#endif

static BOOL_T SWDRV_LocalSetMimServicePortLearningStatusForStationMove(BOOL_T learning, BOOL_T to_cpu, BOOL_T drop)
{
    return DEV_SWDRV_PMGR_SetMimServicePortLearningStatusForStationMove(learning, to_cpu, drop);
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetMimServicePortLearningStatusForStationMove
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set MiM port learning status
 *              for station move handling only
 * INPUT    :   learning
 *              to_cpu
 *              drop
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetMimServicePortLearningStatusForStationMove(BOOL_T learning, BOOL_T to_cpu, BOOL_T drop)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_MIM_SERVICE_PORT_LEARNING_STATUS_FOR_STATION_MOVE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_MIM_SERVICE_PORT_LEARNING_STATUS_FOR_STATION_MOVE;
            isc_buffer_p->info.u32_u32_u32.u32_a1 = learning;
            isc_buffer_p->info.u32_u32_u32.u32_a2 = to_cpu;
            isc_buffer_p->info.u32_u32_u32.u32_a3 = drop;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }

#endif /* (SYS_CPNT_STACKING == TRUE) */
        if (!SWDRV_LocalSetMimServicePortLearningStatusForStationMove(learning, to_cpu, drop))
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif /* (SYS_CPNT_IAAS == TRUE) */
#endif /* (SYS_CPNT_MAC_IN_MAC == TRUE) */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetCpuRateLimit
 * -------------------------------------------------------------------------
 * PURPOSE : To configure CPU rate limit
 * INPUT   : pkt_type  -- SWDRV_PKTTYPE_XXX
 *           rate      -- in pkt/s. 0 to disable.
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetCpuRateLimit(UI32_T pkt_type, UI32_T rate)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
         /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if stacking
     */
#if (SYS_CPNT_STACKING == TRUE)
    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    if (unit_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_CPU_RATE_LIMIT) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {

            return FALSE;
        }

        isc_buffer_p->ServiceID  = SWDRV_SET_CPU_RATE_LIMIT;
        isc_buffer_p->info.u32_u32.u32_a1 = pkt_type;
        isc_buffer_p->info.u32_u32.u32_a2 = rate;

        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
    }
#endif /*SYS_CPNT_STACKING*/

    if(!SWDRV_LocalSetCpuRateLimit(pkt_type, rate))
    {

        return FALSE;
    }

    return TRUE;
}

static BOOL_T SlaveSetCpuRateLimit(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetCpuRateLimit(
        request_p->info.u32_u32.u32_a1,
        request_p->info.u32_u32.u32_a2);
}

static BOOL_T SWDRV_LocalSetCpuRateLimit(UI32_T pkt_type, UI32_T rate)
{
    return DEV_SWDRV_PMGR_SetCpuRateLimit(pkt_type, rate);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_GetPortAbility
 * -------------------------------------------------------------------------
 * PURPOSE : To get port abilities
 * INPUT   : unit
 *           port
 * OUTPUT  : ability_p
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_GetPortAbility(UI32_T unit, UI32_T port, SWDRV_PortAbility_T *ability_p)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
        UI32_T  drv_unit = 0;

#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            if (port > max_port_number)
            {
                if (!STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
                {
                    return FALSE;
                }
            }
            else
            {
                 drv_unit = unit;
            }
        }

        /* if remote unit
         */
        if (drv_unit != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_ABILITY) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_GET_PORT_ABILITY;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;

            if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
            {
                return FALSE;
            }

            *ability_p = isc_reply.data.port_ability;
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */

        if (drv_unit == 0)
        {
            if (!SWDRV_LocalGetPortAbility(unit, port, ability_p))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL_T SlaveGetPortAbility(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_ABILITY) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = SWDRV_LocalGetPortAbility(
        request_p->unit,
        request_p->port,
        &isc_reply_p->data.port_ability);

    return ISC_RemoteReply(mref_handle_p, key);
}

static BOOL_T SWDRV_LocalGetPortAbility(UI32_T unit, UI32_T port, SWDRV_PortAbility_T *ability_p)
{
    /* NOTE:
     *   should make sure definition of SWDRV_PortAbility_T is the same with
     *   DEV_SWDRV_PortAbility_T
     */
    assert(sizeof(*ability_p) == sizeof(DEV_SWDRV_PortAbility_T));

    return DEV_SWDRV_PMGR_GetPortAbility(unit, port, (DEV_SWDRV_PortAbility_T *)ability_p);
}

#if (SYS_CPNT_VRRP == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_TrapVrrpTpCpu
 * -------------------------------------------------------------------------
 * PURPOSE : trap Vrrp message to cpu
 * INPUT   : is_trap - trap or not
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_TrapVrrpTpCpu(BOOL_T is_trap)
{
    BOOL_T ret = TRUE;

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    if(FALSE == (ret = RULE_CTRL_TrapPacket2Cpu(is_trap, RULE_TYPE_PacketType_VRRP, NULL)))
        return ret;

    return TRUE;
}
#endif


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_Notify_LocalPortSfpPresent
 * -------------------------------------------------------------------------
 * FUNCTION: Master notify port sfp present status to upper layer
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This function is only called in Master.
 * -------------------------------------------------------------------------
 */
static void SWDRV_Notify_LocalPortSfpPresent(void)
{
    UI32_T unit_index ;
    UI32_T pooling_index = 0;
    UI32_T unit;
    UI32_T stack_id;
    UI32_T start_port;
    UI32_T end_port;
    UI32_T swdrv_receive_events = 0;
    UI8_T  array_index;
    UI8_T  bit_index;
    UI8_T  changed_bitmap;
    SWDRV_Switch_Info_T swdrv_system_info;
    SWDRV_TYPE_SfpPresentStatus_T sfp_present_status;

    SYSFUN_ReceiveEvent(SWDRV_EVENT_UPDATE_PORT_SFP_PRESENT_STATUS,
                         SYSFUN_EVENT_WAIT_ANY,
                         SYSFUN_TIMEOUT_NOWAIT,/* timeout */
                         &swdrv_receive_events);

    if(!(swdrv_receive_events & SWDRV_EVENT_UPDATE_PORT_SFP_PRESENT_STATUS))
    {
        return;
    }

    memset(&swdrv_system_info, 0, sizeof(SWDRV_Switch_Info_T));
    SWDRV_OM_GetSystemInfo(&swdrv_system_info);

    SWDRV_OM_GetSystemInfoStackId(&stack_id);

    /* There are "swdrv_system_info.num_of_units" units in stacking.
     */
    for(unit_index = 0; unit_index<swdrv_system_info.num_of_units; unit_index++)
    {
        unit = swdrv_system_info.stack_unit_tbl[unit_index];

        /* check eack element of array bitmap of this unit.
         */
        for(pooling_index = 0; pooling_index < SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST; pooling_index++)
        {
            memset(&sfp_present_status, 0, sizeof(SWDRV_TYPE_SfpPresentStatus_T));
            SWDRV_OM_GetPortSfpPresentStatusBitmaps(unit, &sfp_present_status);
            changed_bitmap = sfp_present_status.sfp_present_st_bitmap[pooling_index]
                             ^sfp_present_status.previous_sfp_present_st_bitmap[pooling_index];
            if(changed_bitmap)
            {
                /* if previous array element(previous_sfp_present_st_bitmap[pooling_index]) and
                 * new array element(sfp_present_st_bitmap[pooling_index]) are different.
                 * Check each bit in array element.
                 */
                start_port = pooling_index * 8 + 1;
                end_port = start_port + 7;
                for(; start_port <= end_port; start_port++)
                {
                    array_index = SWDRV_LPORT_INDEX(start_port);
                    bit_index = SWDRV_LPORT_BIT_IN_UI8_T(start_port);

                    if(changed_bitmap & bit_index)
                    {
                        if(sfp_present_status.sfp_present_st_bitmap[array_index] & bit_index)
                        {
                            /* update previous port sfp_present status bit
                             */
                            //printf("%s-%d bit_index:%ld present \r\n", __FUNCTION__, __LINE__, bit_index);
                            sfp_present_status.previous_sfp_present_st_bitmap[array_index] |= bit_index;
                            SWDRV_OM_SetPortSfpPresentStatusBitmaps(unit, &sfp_present_status, SWDRV_OM_F_ANNOUNCED);
                            SYS_CALLBACK_MGR_SWDRV_PortSfpPresent(SYS_MODULE_SWDRV, unit, start_port, TRUE);
                        }
                        else
                        {
                            //printf("%s-%d bit_index:%ld not present \r\n", __FUNCTION__, __LINE__, bit_index);
                            sfp_present_status.previous_sfp_present_st_bitmap[array_index] &= (~bit_index);
                            SWDRV_OM_SetPortSfpPresentStatusBitmaps(unit, &sfp_present_status, SWDRV_OM_F_ANNOUNCED);
                            SYS_CALLBACK_MGR_SWDRV_PortSfpPresent(SYS_MODULE_SWDRV, unit, start_port, FALSE);
                        }
                    }/*End if (changed_bitmap& bit_index)*/
                }/*End for (; start_port <= end_port ;start_port++)*/
            }/*End if (changed_bitmap)*/
        }/*End for (pooling_index = 0; pooling_index <SWDRV_TOTAL_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST; pooling_index++)*/
    }/*End for (unit_index=0; unit_index<swdrv_system_info.num_of_units;unit_index++)*/

    return;
}


#if (SYS_CPNT_STACKING == TRUE)
static BOOL_T SlaveSetPortEgressBlock(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetPortEgressBlock(
            request_p->unit,
            request_p->port,
            request_p->portlist);
}
#endif

static BOOL_T SWDRV_LocalSetPortEgressBlock(
    UI32_T unit,
    UI32_T port,
    UI8_T egr_blk_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST])
{
    UI32_T stack_id;

    SWDRV_OM_GetSystemInfoStackId(&stack_id);

    egr_blk_uport_list += (stack_id - 1) * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST;

    return DEV_SWDRV_PMGR_SetPortEgressBlock(unit, port, egr_blk_uport_list);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortEgressBlock
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block ports.
 * INPUT   : unit
 *           port
 *           egr_blk_uport_list - uport list to block.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortEgressBlock(
    UI32_T unit,
    UI32_T port,
    UI8_T egr_blk_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST])
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_EGRESS_BLOCK) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_EGRESS_BLOCK;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            memcpy(
                isc_buffer_p->portlist,
                egr_blk_uport_list,
                SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {
                return FALSE; /* can't control remote unit */
            }
        }

#endif /* (SYS_CPNT_STACKING == TRUE) */
        if (!SWDRV_LocalSetPortEgressBlock(unit, port, egr_blk_uport_list))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_EnablePortOpenFlowMode
 * -------------------------------------------------------------------------
 * PURPOSE : This function will configure the following settings for
 *           specified port to meet OpenFlow requirements.
 *           1. Turn off flow control on each port.
 *           2. Disable MAC learning on new addresses and copy SLF packet
 *              to CPU.
 *           3. Disable MAC learning on station moves and copy SLF packet
 *              to CPU.
 *           4. Disable IPv4 Multicast
 *           5. Disable IPv6 Multicast
 *           6. Discard untagged traffic
 *           7. Filter traffic for a VLAN which is not a member of a port.
 * INPUT   : unit -- which unit
 *           port -- which port to enable OpenFlow mode
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_EnablePortOpenFlowMode(UI32_T unit, UI32_T port)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            DBG_PRINT("STKTPLG_POM_GetMaxPortNumberOnBoard fail");
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);
        if (    ((stack_id != unit) || (port > max_port_number))
#if (SYS_CPNT_MGMT_PORT == TRUE)
             && (port != SYS_ADPT_MGMT_PORT)
#endif
           )
        {
            /* if remote unit
             */
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;
            UI32_T              drv_unit;
            UI16_T              unit_bmp = 0;

            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_ENABLE_PORT_OPENFLOW_MODE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_ENABLE_PORT_OPENFLOW_MODE;
            isc_buffer_p->unit      = unit;
            isc_buffer_p->port      = port;

            if (port > max_port_number)
            {
                if (STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit) == TRUE)
                {
                     unit_bmp = SWDRV_UNIT_TO_UNITBMP(drv_unit);
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                unit_bmp = SWDRV_UNIT_TO_UNITBMP(unit);
            }

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
        else
#endif
        {
            /* if local unit or standalone
             */
            if (FALSE == SWDRV_LocalEnablePortOpenFlowMode(unit, port))
            {
                DBG_PRINT("SWDRV_LocalEnablePortOpenFlowMode fail");
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalEnablePortOpenFlowMode(UI32_T unit, UI32_T port)
{
    return DEV_SWDRV_PMGR_EnablePortOpenFlowMode(unit, port);
}

static BOOL_T SlaveEnablePortOpenFlowMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalEnablePortOpenFlowMode(request_p->unit, request_p->port);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetVlanFloodingForUknUC
 * -------------------------------------------------------------------------
 * PURPOSE : This function will drop and disable unknown UC/MC/BC flooding.
 *           1. Drop unicast packets in the VLAN that miss the L2 lookup and
 *              do not copy to CPU. Multicast packets must not be dropped.
 *           2. Block flooding of unknown unicast, unknown multicast and
 *              broadcast by default.
 * INPUT   : vid   -- which VLAN to disable flooding
 *           flood -- TRUE = flooding, FALSE = not flooding
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetVlanFloodingForUknUC(UI32_T vid, BOOL_T flood)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T              unit_bmp = 0;
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VLAN_FLOODING_FOR_UKN_UC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_VLAN_FLOODING_FOR_UKN_UC;
            isc_buffer_p->info.u32_b.u32_a1  = vid;
            isc_buffer_p->info.u32_b.bool_a1 = flood;

            if (ISC_SendMcastReliable(unit_bmp, ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if local unit or standalone
         */
        if (FALSE == SWDRV_LocalSetVlanFloodingForUknUC(vid, flood))
        {
            DBG_PRINT("SWDRV_LocalSetVlanFloodingForUknUC fail");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalSetVlanFloodingForUknUC(UI32_T vid, BOOL_T flood)
{
    return DEV_SWDRV_PMGR_SetVlanFlooding(vid, DEV_SWDRV_VLAN_FLOODING_UKN_UC, flood);
}

static BOOL_T SlaveSetVlanFloodingForUknUC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVlanFloodingForUknUC(request_p->info.u32_b.u32_a1, request_p->info.u32_b.bool_a1);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetVlanFloodingForUknMC
 * -------------------------------------------------------------------------
 * PURPOSE : This function will drop and disable unknown UC/MC/BC flooding.
 *           1. Drop unicast packets in the VLAN that miss the L2 lookup and
 *              do not copy to CPU. Multicast packets must not be dropped.
 *           2. Block flooding of unknown unicast, unknown multicast and
 *              broadcast by default.
 * INPUT   : vid   -- which VLAN to disable flooding
 *           flood -- TRUE = flooding, FALSE = not flooding
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetVlanFloodingForUknMC(UI32_T vid, BOOL_T flood)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T              unit_bmp = 0;
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VLAN_FLOODING_FOR_UKN_MC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_VLAN_FLOODING_FOR_UKN_MC;
            isc_buffer_p->info.u32_b.u32_a1  = vid;
            isc_buffer_p->info.u32_b.bool_a1 = flood;

            if (ISC_SendMcastReliable(unit_bmp, ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if local unit or standalone
         */
        if (FALSE == SWDRV_LocalSetVlanFloodingForUknMC(vid, flood))
        {
            DBG_PRINT("SWDRV_LocalSetVlanFloodingForUknUC fail");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalSetVlanFloodingForUknMC(UI32_T vid, BOOL_T flood)
{
    return DEV_SWDRV_PMGR_SetVlanFlooding(vid, DEV_SWDRV_VLAN_FLOODING_UKN_MC, flood);
}

static BOOL_T SlaveSetVlanFloodingForUknMC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVlanFloodingForUknMC(request_p->info.u32_b.u32_a1, request_p->info.u32_b.bool_a1);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_SetVlanFloodingForBC
 * -------------------------------------------------------------------------
 * PURPOSE : This function will drop and disable unknown UC/MC/BC flooding.
 *           1. Drop unicast packets in the VLAN that miss the L2 lookup and
 *              do not copy to CPU. Multicast packets must not be dropped.
 *           2. Block flooding of unknown unicast, unknown multicast and
 *              broadcast by default.
 * INPUT   : vid   -- which VLAN to disable flooding
 *           flood -- TRUE = flooding, FALSE = not flooding
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_SetVlanFloodingForBC(UI32_T vid, BOOL_T flood)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T              unit_bmp = 0;
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VLAN_FLOODING_FOR_BC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_SET_VLAN_FLOODING_FOR_BC;
            isc_buffer_p->info.u32_b.u32_a1  = vid;
            isc_buffer_p->info.u32_b.bool_a1 = flood;

            if (ISC_SendMcastReliable(unit_bmp, ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if local unit or standalone
         */
        if (FALSE == SWDRV_LocalSetVlanFloodingForBC(vid, flood))
        {
            DBG_PRINT("SWDRV_LocalSetVlanFloodingForUknUC fail");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalSetVlanFloodingForBC(UI32_T vid, BOOL_T flood)
{
    return DEV_SWDRV_PMGR_SetVlanFlooding(vid, DEV_SWDRV_VLAN_FLOODING_BC, flood);
}

static BOOL_T SlaveSetVlanFloodingForBC(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalSetVlanFloodingForBC(request_p->info.u32_b.u32_a1, request_p->info.u32_b.bool_a1);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_DeleteAllPortFromVlan
 * -------------------------------------------------------------------------
 * PURPOSE : Remove all ports from specified VLAN
 * INPUT   : vid -- which VLAN to remove all members
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_DeleteAllPortFromVlan(UI32_T vid)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T              unit_bmp = 0;
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_VLAN_FLOODING_FOR_UKN_UC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_DELETE_ALL_PORT_FROM_VLAN;
            isc_buffer_p->info.u32_b.u32_a1  = vid;

            if (ISC_SendMcastReliable(unit_bmp, ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if local unit or standalone
         */
        if (FALSE == SWDRV_LocalDeleteAllPortFromVlan(vid))
        {
            DBG_PRINT("SWDRV_LocalDeleteAllPortFromVlan fail");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalDeleteAllPortFromVlan(UI32_T vid)
{
    return DEV_SWDRV_PMGR_DeleteAllPortFromVlan(vid);
}

static BOOL_T SlaveDeleteAllPortFromVlan(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return DEV_SWDRV_PMGR_DeleteAllPortFromVlan(request_p->info.u32_b.u32_a1);
}


/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_StaticMacMovePktToCpu
 * -------------------------------------------------------------------------
 * PURPOSE : The operation for static MAC address port move event.
 * INPUT   : is_enable -- TRUE will trap packet to CPU. FASLE will not.
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWDRV_StaticMacMovePktToCpu(UI32_T is_enable)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        DBG_PRINT("SYS_TYPE_STACKING_MASTER_MODE fail");
        return FALSE;
    }
    else
    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T              unit_bmp = 0;
        L_MM_Mref_Handle_T* mref_handle_p;
        SWDRV_Rx_IscBuf_T*  isc_buffer_p;
        UI32_T              pdu_len;
        UI32_T              drv_unit;

        unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp != 0)
        {
            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_STATIC_MAC_MOVE_PKT_TO_CPU) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);

            if (isc_buffer_p == NULL)
            {
                return FALSE;
            }

            /* disable port flow control of remote unit
             */
            isc_buffer_p->ServiceID = SWDRV_STATIC_MAC_MOVE_PKT_TO_CPU;
            isc_buffer_p->info.u32_b.u32_a1  = is_enable;

            if (ISC_SendMcastReliable(unit_bmp, ISC_SWDRV_SID,
                                      mref_handle_p,
                                      SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                      SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE) != 0)
            {
                return FALSE; /* can't control remote unit */
            }
        }
#endif
        /* if local unit or standalone
         */
        if (FALSE == SWDRV_LocalStaticMacMovePktToCpu(is_enable))
        {
            DBG_PRINT("SWDRV_LocalStaticMacMovePktToCpu fail");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T SWDRV_LocalStaticMacMovePktToCpu(UI32_T is_enable)
{
    return DEV_SWDRV_PMGR_StaticMacMovePktToCpu(is_enable);
}

static BOOL_T SlaveStaticMacMovePktToCpu(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return DEV_SWDRV_PMGR_StaticMacMovePktToCpu(request_p->info.u32_b.u32_a1);
}

#if (SYS_CPNT_HASH_SELECTION == TRUE)
static BOOL_T SlaveBindHashSelForService(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalBindHashSelForService(request_p->info.bind_hash_sel_for_service.service,
                                            &request_p->info.bind_hash_sel_for_service.block_info);
}

static BOOL_T SWDRV_LocalBindHashSelForService(
    SWDRV_HashSelService_T service,
    SWDRV_HashSelBlockInfo_T *block_info_p)
{
    BOOL_T ret_val=TRUE;
    UI8_T hw_block_index, org_list_index;
    BOOL_T share;

    if (TRUE == SWDRV_OM_GetHashSelDevBlockIndex(service, &org_list_index, &hw_block_index))
    {
        if (org_list_index == block_info_p->list_index)
        {
            /* had bound */
            return TRUE;
        }
        else
        {
            /* had bound another hash-selection list*/
            return FALSE;
        }
    }

    if (TRUE != SWDRV_OM_BindHashSelForService(service, block_info_p->list_index, &hw_block_index, &share))
    {
        return FALSE;
    }

    if (share == FALSE)
    {
        /* The hash-selection is used first. */
        DEV_SWDRV_HashSelBlockInfo_T  dev_block_info;

        dev_block_info.hw_block_index = hw_block_index;
        memcpy(&dev_block_info.pkt_l2, &block_info_p->pkt_l2, sizeof(DEV_SWDRV_HashSelection_L2_T));
        memcpy(&dev_block_info.pkt_ipv4, &block_info_p->pkt_ipv4, sizeof(DEV_SWDRV_HashSelection_IPv4_T));
        memcpy(&dev_block_info.pkt_ipv6, &block_info_p->pkt_ipv6, sizeof(DEV_SWDRV_HashSelection_IPv6_T));

        if (TRUE != DEV_SWDRV_PMGR_SetHashSelBlock(&dev_block_info))
        {
           return FALSE;
        }
    }

    if (service & SWDRV_HASH_SEL_SERVICE_ECMP)
    {
        /* bind rtag7 for ECMP */
        if (DEV_SWDRV_PMGR_SetHashSelectionForECMP(hw_block_index)==FALSE)
            ret_val=FALSE;
    }
    else if (service & SWDRV_HASH_SEL_SERVICE_TRUNK)
    {
        /* not implement yet */
        ret_val=FALSE;
    }
    else
    {
        /* unknown service bit */
        ret_val=FALSE;
    }

    return ret_val;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_BindHashSelForService
 * -------------------------------------------------------------------------
 * FUNCTION: To bind the specified hash-selection block index for service
 * INPUT   : service - SWDRV_HASH_SEL_SERVICE_ECMP
 *                     SWDRV_HASH_SEL_SERVICE_TRUNK (Not implement yet)
 *           block_info_p - block info
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_BindHashSelForService(
    SWDRV_HashSelService_T service,
    SWDRV_HashSelBlockInfo_T *block_info_p)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_BIND_HASH_SEL_FOR_SERVICE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_BIND_HASH_SEL_FOR_SERVICE;
            isc_buffer_p->info.bind_hash_sel_for_service.service = service;
            memcpy(&isc_buffer_p->info.bind_hash_sel_for_service.block_info,
                                     block_info_p, sizeof(SWDRV_HashSelService_T));

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

#endif /* (SYS_CPNT_STACKING == TRUE) */
        if (TRUE != SWDRV_LocalBindHashSelForService(service, block_info_p))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_UnBindHashSelForService
 * -------------------------------------------------------------------------
 * FUNCTION: To unbind the specified hash-selection block index for service
 * INPUT   : service - SWDRV_HASH_SEL_SERVICE_ECMP
 *                     SWDRV_HASH_SEL_SERVICE_TRUNK (Not implement yet)
 *           list_index - the index of hash-selection list
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_UnBindHashSelForService(
    SWDRV_HashSelService_T service,
    UI8_T list_index)
{
    DEV_SWDRV_PMGR_UnBindHashSelForECMP();

    return SWDRV_OM_UnBindHashSelForService(service, list_index);
}
#endif /*#if (SYS_CPNT_HASH_SELECTION == TRUE)*/

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
static BOOL_T SlaveSetSwitchingMode(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return DEV_SWDRV_PMGR_SetSwitchingMode(request_p->info.u32_u32_u32.u32_a1,
		                                   request_p->info.u32_u32_u32.u32_a2,
		                                   request_p->info.u32_u32_u32.u32_a3);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetSwitchingMode
 * -------------------------------------------------------------------------
 * FUNCTION: To set switching mode
 * INPUT   : unit
 *           port
 *           mode - VAL_swctrlSwitchModeSF
 *                  VAL_swctrlSwitchModeCT
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetSwitchingMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    {
#if (SYS_CPNT_STACKING == TRUE)
        UI16_T unit_bmp = SWDRV_GetValidDrvUnitBmp();

        if (unit_bmp!=0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_SWITCHING_MODE) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {

                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_SWITCHING_MODE;
            isc_buffer_p->info.u32_u32_u32.u32_a1 = unit;
			isc_buffer_p->info.u32_u32_u32.u32_a2 = port;
			isc_buffer_p->info.u32_u32_u32.u32_a3 = mode;

            if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                     mref_handle_p,
                                     SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                     SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
            {

                return FALSE; /* can't control remote unit */
            }
        }

#endif /* (SYS_CPNT_STACKING == TRUE) */
        if (TRUE != DEV_SWDRV_PMGR_SetSwitchingMode(unit, port, mode))
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif /*#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)*/

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
static BOOL_T SlaveSetPortFec(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return DEV_SWDRV_PMGR_SetPortFec(
        request_p->unit,
        request_p->port,
        request_p->info.general_32_bits);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetPortFec
 * -------------------------------------------------------------------------
 * FUNCTION: To enable/disable FEC
 * INPUT   : unit
 *           port
 *           fec_mode - VAL_portFecMode_XXX
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_SetPortFec(UI32_T unit, UI32_T port, UI32_T fec_mode)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
        UI32_T  drv_unit = 0;

#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            if (port > max_port_number)
            {
                if (!STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
                {
                    return FALSE;
                }
            }
            else
            {
                 drv_unit = unit;
            }
        }

        /* if remote unit
         */
        if (drv_unit != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_PORT_FEC) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_SET_PORT_FEC;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;
            isc_buffer_p->info.general_32_bits = fec_mode;

            if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */

        if (drv_unit == 0)
        {
            if (!DEV_SWDRV_PMGR_SetPortFec(unit, port, fec_mode))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL_T SlaveGetPortFecStatus(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    UI32_T              pdu_len;
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_IscReplyBuf_T), /* tx_buffer_size */
                              L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_FEC_STATUS) /* user_id */);

    if (NULL == (isc_reply_p = (SWDRV_IscReplyBuf_T*)L_MM_Mref_GetPdu (mref_handle_p, &pdu_len)))
    {
        return FALSE;
    }

    isc_reply_p->return_value.bool = DEV_SWDRV_PMGR_GetPortFecStatus(
        request_p->unit,
        request_p->port,
        &isc_reply_p->data.u32);

    return ISC_RemoteReply(mref_handle_p, key);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_GetPortFecStatus
 * -------------------------------------------------------------------------
 * FUNCTION: To get FEC status
 * INPUT   : unit
 *           port
 * OUTPUT  : fec_mode_p - VAL_portFecMode_XXX
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWDRV_GetPortFecStatus(UI32_T unit, UI32_T port, UI32_T *fec_mode_p)
{
    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
        return FALSE;
    }
#endif

    {
        UI32_T  drv_unit = 0;

#if (SYS_CPNT_STACKING == TRUE)
        UI32_T  max_port_number;
        UI32_T  stack_id;

        if (STKTPLG_POM_GetMaxPortNumberOnBoard(unit, &max_port_number) == FALSE)
        {
            return FALSE;
        }

        SWDRV_OM_GetSystemInfoStackId(&stack_id);

        if ( ((stack_id != unit) ||
             (port > max_port_number))
           )
        {
            if ( (FALSE == STKTPLG_POM_UnitExist(unit)) || (FALSE == STKTPLG_POM_PortExist(unit, port)) )
            {
                return FALSE;
            }

            if (port > max_port_number)
            {
                if (!STKTPLG_POM_OptionModuleIsExist(unit, &drv_unit))
                {
                    return FALSE;
                }
            }
            else
            {
                 drv_unit = unit;
            }
        }

        /* if remote unit
         */
        if (drv_unit != 0)
        {
            L_MM_Mref_Handle_T* mref_handle_p;
            SWDRV_Rx_IscBuf_T*  isc_buffer_p;
            SWDRV_IscReplyBuf_T isc_reply;
            UI32_T              pdu_len;

            mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                      L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_GET_PORT_FEC_STATUS) /* user_id */);
            isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

            if (isc_buffer_p==NULL)
            {
                return FALSE;
            }

            isc_buffer_p->ServiceID = SWDRV_GET_PORT_FEC_STATUS;
            isc_buffer_p->unit = unit;
            isc_buffer_p->port = port;

            if (!ISC_RemoteCall((UI8_T)drv_unit, ISC_SWDRV_SID, mref_handle_p,
                                SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                sizeof(isc_reply), (UI8_T *)&isc_reply,
                                SWDRV_TRY_TIMES,SWDRV_TIME_OUT))
            {
                return FALSE;
            }

            if (!isc_reply.return_value.bool)
            {
                return FALSE;
            }

            *fec_mode_p = isc_reply.data.u32;
        }
#endif /* (SYS_CPNT_STACKING == TRUE) */

        if (drv_unit == 0)
        {
            if (!DEV_SWDRV_PMGR_GetPortFecStatus(unit, port, fec_mode_p))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif /* (SYS_CPNT_SWCTRL_FEC == TRUE) */

#if(SYS_CPNT_WRED == TRUE)
static BOOL_T SWDRV_LocalRandomDetect(UI32_T unit, UI32_T port, SWDRV_RandomDetec_T *value_p)
{
    DEV_SWDRV_RandomDetect_T v;
	
    v.queue_id = value_p->queue_id;
    v.min      = value_p->min;
    v.max      = value_p->max;
    v.drop     = value_p->drop;
    v.ecn      = value_p->ecn;	
	
    return DEV_SWDRV_PMGR_RandomDetect(unit, port, v);
}

static BOOL_T SWDRV_SlaveRandomDetect(ISC_Key_T *key, SWDRV_Rx_IscBuf_T *request_p)
{
    return SWDRV_LocalRandomDetect(request_p->unit, request_p->port, &request_p->info.random_detect);
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_RandomDetect
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port ecn marking percentage
 * INPUT    :   unit       - which unit
 *              port       - which port
 *              value_p    - what percantage
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   percentage =0 means disable
 * ------------------------------------------------------------------------
 */
BOOL_T SWDRV_RandomDetect(UI32_T unit, UI32_T port, SWDRV_RandomDetec_T *value_p)
{
#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Mref_Handle_T* mref_handle_p;
    SWDRV_Rx_IscBuf_T*  isc_buffer_p;
    UI32_T              pdu_len, stack_id;
    UI16_T              unit_bmp=0;
#endif

    if (SWDRV_OM_GetOperatingMode() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        /* UIMSG_MGR_SetErrorCode() */
        return FALSE;
    }

    /* if stacking
     */
#if (SYS_CPNT_STACKING == TRUE)
    SWDRV_OM_GetSystemInfoStackId(&stack_id);

    unit_bmp = SWDRV_GetValidDrvUnitBmp();
    if (unit_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(SWDRV_Rx_IscBuf_T), /* tx_buffer_size */
                                  L_MM_USER_ID2(SYS_MODULE_SWDRV, SWDRV_SET_RANDOM_DETECT) /* user_id */);
        isc_buffer_p = L_MM_Mref_GetPdu (mref_handle_p, &pdu_len);

        if (isc_buffer_p==NULL)
        {
            return FALSE;
        }

        /* enable IPMC of all unit
         */
        isc_buffer_p->ServiceID  = SWDRV_SET_RANDOM_DETECT;
        isc_buffer_p->unit = unit;
        isc_buffer_p->port = port;
        isc_buffer_p->info.random_detect = *value_p;
        if (ISC_SendMcastReliable(unit_bmp,ISC_SWDRV_SID,
                                 mref_handle_p,
                                 SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                 SWDRV_TRY_TIMES, SWDRV_TIME_OUT, FALSE)!=0)
        {

            return FALSE; /* can't control remote unit */
        }
        return TRUE;
    }
    else
#endif
    return SWDRV_LocalRandomDetect(unit, port, value_p);
}
#endif /*#if(SYS_CPNT_WRED == TRUE)*/
